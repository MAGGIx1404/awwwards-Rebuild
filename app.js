/*! For license information please see bundle.ed070500c303d23e3f9c.js.LICENSE.txt */
(() => {
  var __webpack_modules__ = {
      766: (e, t, n) => {
        var i;
        !(function () {
          "use strict";
          var r = function () {
            this.init();
          };
          r.prototype = {
            init: function () {
              var e = this || a;
              return (
                (e._counter = 1e3),
                (e._html5AudioPool = []),
                (e.html5PoolSize = 10),
                (e._codecs = {}),
                (e._howls = []),
                (e._muted = !1),
                (e._volume = 1),
                (e._canPlayEvent = "canplaythrough"),
                (e._navigator =
                  "undefined" != typeof window && window.navigator
                    ? window.navigator
                    : null),
                (e.masterGain = null),
                (e.noAudio = !1),
                (e.usingWebAudio = !0),
                (e.autoSuspend = !0),
                (e.ctx = null),
                (e.autoUnlock = !0),
                e._setup(),
                e
              );
            },
            volume: function (e) {
              var t = this || a;
              if (
                ((e = parseFloat(e)),
                t.ctx || d(),
                void 0 !== e && e >= 0 && e <= 1)
              ) {
                if (((t._volume = e), t._muted)) return t;
                t.usingWebAudio &&
                  t.masterGain.gain.setValueAtTime(e, a.ctx.currentTime);
                for (var n = 0; n < t._howls.length; n++)
                  if (!t._howls[n]._webAudio)
                    for (
                      var i = t._howls[n]._getSoundIds(), r = 0;
                      r < i.length;
                      r++
                    ) {
                      var o = t._howls[n]._soundById(i[r]);
                      o && o._node && (o._node.volume = o._volume * e);
                    }
                return t;
              }
              return t._volume;
            },
            mute: function (e) {
              var t = this || a;
              t.ctx || d(),
                (t._muted = e),
                t.usingWebAudio &&
                  t.masterGain.gain.setValueAtTime(
                    e ? 0 : t._volume,
                    a.ctx.currentTime
                  );
              for (var n = 0; n < t._howls.length; n++)
                if (!t._howls[n]._webAudio)
                  for (
                    var i = t._howls[n]._getSoundIds(), r = 0;
                    r < i.length;
                    r++
                  ) {
                    var o = t._howls[n]._soundById(i[r]);
                    o && o._node && (o._node.muted = !!e || o._muted);
                  }
              return t;
            },
            stop: function () {
              for (var e = this || a, t = 0; t < e._howls.length; t++)
                e._howls[t].stop();
              return e;
            },
            unload: function () {
              for (var e = this || a, t = e._howls.length - 1; t >= 0; t--)
                e._howls[t].unload();
              return (
                e.usingWebAudio &&
                  e.ctx &&
                  void 0 !== e.ctx.close &&
                  (e.ctx.close(), (e.ctx = null), d()),
                e
              );
            },
            codecs: function (e) {
              return (this || a)._codecs[e.replace(/^x-/, "")];
            },
            _setup: function () {
              var e = this || a;
              if (
                ((e.state = (e.ctx && e.ctx.state) || "suspended"),
                e._autoSuspend(),
                !e.usingWebAudio)
              )
                if ("undefined" != typeof Audio)
                  try {
                    void 0 === new Audio().oncanplaythrough &&
                      (e._canPlayEvent = "canplay");
                  } catch (t) {
                    e.noAudio = !0;
                  }
                else e.noAudio = !0;
              try {
                new Audio().muted && (e.noAudio = !0);
              } catch (e) {}
              return e.noAudio || e._setupCodecs(), e;
            },
            _setupCodecs: function () {
              var e = this || a,
                t = null;
              try {
                t = "undefined" != typeof Audio ? new Audio() : null;
              } catch (t) {
                return e;
              }
              if (!t || "function" != typeof t.canPlayType) return e;
              var n = t.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                i =
                  e._navigator &&
                  e._navigator.userAgent.match(/OPR\/([0-6].)/g),
                r = i && parseInt(i[0].split("/")[1], 10) < 33;
              return (
                (e._codecs = {
                  mp3: !(
                    r ||
                    (!n && !t.canPlayType("audio/mp3;").replace(/^no$/, ""))
                  ),
                  mpeg: !!n,
                  opus: !!t
                    .canPlayType('audio/ogg; codecs="opus"')
                    .replace(/^no$/, ""),
                  ogg: !!t
                    .canPlayType('audio/ogg; codecs="vorbis"')
                    .replace(/^no$/, ""),
                  oga: !!t
                    .canPlayType('audio/ogg; codecs="vorbis"')
                    .replace(/^no$/, ""),
                  wav: !!(
                    t.canPlayType('audio/wav; codecs="1"') ||
                    t.canPlayType("audio/wav")
                  ).replace(/^no$/, ""),
                  aac: !!t.canPlayType("audio/aac;").replace(/^no$/, ""),
                  caf: !!t.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                  m4a: !!(
                    t.canPlayType("audio/x-m4a;") ||
                    t.canPlayType("audio/m4a;") ||
                    t.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  m4b: !!(
                    t.canPlayType("audio/x-m4b;") ||
                    t.canPlayType("audio/m4b;") ||
                    t.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  mp4: !!(
                    t.canPlayType("audio/x-mp4;") ||
                    t.canPlayType("audio/mp4;") ||
                    t.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  weba: !!t
                    .canPlayType('audio/webm; codecs="vorbis"')
                    .replace(/^no$/, ""),
                  webm: !!t
                    .canPlayType('audio/webm; codecs="vorbis"')
                    .replace(/^no$/, ""),
                  dolby: !!t
                    .canPlayType('audio/mp4; codecs="ec-3"')
                    .replace(/^no$/, ""),
                  flac: !!(
                    t.canPlayType("audio/x-flac;") ||
                    t.canPlayType("audio/flac;")
                  ).replace(/^no$/, ""),
                }),
                e
              );
            },
            _unlockAudio: function () {
              var e = this || a;
              if (!e._audioUnlocked && e.ctx) {
                (e._audioUnlocked = !1),
                  (e.autoUnlock = !1),
                  e._mobileUnloaded ||
                    44100 === e.ctx.sampleRate ||
                    ((e._mobileUnloaded = !0), e.unload()),
                  (e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050));
                var t = function (n) {
                  for (; e._html5AudioPool.length < e.html5PoolSize; )
                    try {
                      var i = new Audio();
                      (i._unlocked = !0), e._releaseHtml5Audio(i);
                    } catch (n) {
                      e.noAudio = !0;
                      break;
                    }
                  for (var r = 0; r < e._howls.length; r++)
                    if (!e._howls[r]._webAudio)
                      for (
                        var a = e._howls[r]._getSoundIds(), o = 0;
                        o < a.length;
                        o++
                      ) {
                        var s = e._howls[r]._soundById(a[o]);
                        s &&
                          s._node &&
                          !s._node._unlocked &&
                          ((s._node._unlocked = !0), s._node.load());
                      }
                  e._autoResume();
                  var c = e.ctx.createBufferSource();
                  (c.buffer = e._scratchBuffer),
                    c.connect(e.ctx.destination),
                    void 0 === c.start ? c.noteOn(0) : c.start(0),
                    "function" == typeof e.ctx.resume && e.ctx.resume(),
                    (c.onended = function () {
                      c.disconnect(0),
                        (e._audioUnlocked = !0),
                        document.removeEventListener("touchstart", t, !0),
                        document.removeEventListener("touchend", t, !0),
                        document.removeEventListener("click", t, !0);
                      for (var n = 0; n < e._howls.length; n++)
                        e._howls[n]._emit("unlock");
                    });
                };
                return (
                  document.addEventListener("touchstart", t, !0),
                  document.addEventListener("touchend", t, !0),
                  document.addEventListener("click", t, !0),
                  e
                );
              }
            },
            _obtainHtml5Audio: function () {
              var e = this || a;
              if (e._html5AudioPool.length) return e._html5AudioPool.pop();
              var t = new Audio().play();
              return (
                t &&
                  "undefined" != typeof Promise &&
                  (t instanceof Promise || "function" == typeof t.then) &&
                  t.catch(function () {
                    console.warn(
                      "HTML5 Audio pool exhausted, returning potentially locked audio object."
                    );
                  }),
                new Audio()
              );
            },
            _releaseHtml5Audio: function (e) {
              var t = this || a;
              return e._unlocked && t._html5AudioPool.push(e), t;
            },
            _autoSuspend: function () {
              var e = this;
              if (
                e.autoSuspend &&
                e.ctx &&
                void 0 !== e.ctx.suspend &&
                a.usingWebAudio
              ) {
                for (var t = 0; t < e._howls.length; t++)
                  if (e._howls[t]._webAudio)
                    for (var n = 0; n < e._howls[t]._sounds.length; n++)
                      if (!e._howls[t]._sounds[n]._paused) return e;
                return (
                  e._suspendTimer && clearTimeout(e._suspendTimer),
                  (e._suspendTimer = setTimeout(function () {
                    if (e.autoSuspend) {
                      (e._suspendTimer = null), (e.state = "suspending");
                      var t = function () {
                        (e.state = "suspended"),
                          e._resumeAfterSuspend &&
                            (delete e._resumeAfterSuspend, e._autoResume());
                      };
                      e.ctx.suspend().then(t, t);
                    }
                  }, 3e4)),
                  e
                );
              }
            },
            _autoResume: function () {
              var e = this;
              if (e.ctx && void 0 !== e.ctx.resume && a.usingWebAudio)
                return (
                  "running" === e.state &&
                  "interrupted" !== e.ctx.state &&
                  e._suspendTimer
                    ? (clearTimeout(e._suspendTimer), (e._suspendTimer = null))
                    : "suspended" === e.state ||
                      ("running" === e.state && "interrupted" === e.ctx.state)
                    ? (e.ctx.resume().then(function () {
                        e.state = "running";
                        for (var t = 0; t < e._howls.length; t++)
                          e._howls[t]._emit("resume");
                      }),
                      e._suspendTimer &&
                        (clearTimeout(e._suspendTimer),
                        (e._suspendTimer = null)))
                    : "suspending" === e.state && (e._resumeAfterSuspend = !0),
                  e
                );
            },
          };
          var a = new r(),
            o = function (e) {
              e.src && 0 !== e.src.length
                ? this.init(e)
                : console.error(
                    "An array of source files must be passed with any new Howl."
                  );
            };
          o.prototype = {
            init: function (e) {
              var t = this;
              return (
                a.ctx || d(),
                (t._autoplay = e.autoplay || !1),
                (t._format =
                  "string" != typeof e.format ? e.format : [e.format]),
                (t._html5 = e.html5 || !1),
                (t._muted = e.mute || !1),
                (t._loop = e.loop || !1),
                (t._pool = e.pool || 5),
                (t._preload =
                  ("boolean" != typeof e.preload && "metadata" !== e.preload) ||
                  e.preload),
                (t._rate = e.rate || 1),
                (t._sprite = e.sprite || {}),
                (t._src = "string" != typeof e.src ? e.src : [e.src]),
                (t._volume = void 0 !== e.volume ? e.volume : 1),
                (t._xhr = {
                  method: e.xhr && e.xhr.method ? e.xhr.method : "GET",
                  headers: e.xhr && e.xhr.headers ? e.xhr.headers : null,
                  withCredentials:
                    !(!e.xhr || !e.xhr.withCredentials) &&
                    e.xhr.withCredentials,
                }),
                (t._duration = 0),
                (t._state = "unloaded"),
                (t._sounds = []),
                (t._endTimers = {}),
                (t._queue = []),
                (t._playLock = !1),
                (t._onend = e.onend ? [{ fn: e.onend }] : []),
                (t._onfade = e.onfade ? [{ fn: e.onfade }] : []),
                (t._onload = e.onload ? [{ fn: e.onload }] : []),
                (t._onloaderror = e.onloaderror ? [{ fn: e.onloaderror }] : []),
                (t._onplayerror = e.onplayerror ? [{ fn: e.onplayerror }] : []),
                (t._onpause = e.onpause ? [{ fn: e.onpause }] : []),
                (t._onplay = e.onplay ? [{ fn: e.onplay }] : []),
                (t._onstop = e.onstop ? [{ fn: e.onstop }] : []),
                (t._onmute = e.onmute ? [{ fn: e.onmute }] : []),
                (t._onvolume = e.onvolume ? [{ fn: e.onvolume }] : []),
                (t._onrate = e.onrate ? [{ fn: e.onrate }] : []),
                (t._onseek = e.onseek ? [{ fn: e.onseek }] : []),
                (t._onunlock = e.onunlock ? [{ fn: e.onunlock }] : []),
                (t._onresume = []),
                (t._webAudio = a.usingWebAudio && !t._html5),
                void 0 !== a.ctx && a.ctx && a.autoUnlock && a._unlockAudio(),
                a._howls.push(t),
                t._autoplay &&
                  t._queue.push({
                    event: "play",
                    action: function () {
                      t.play();
                    },
                  }),
                t._preload && "none" !== t._preload && t.load(),
                t
              );
            },
            load: function () {
              var e = this,
                t = null;
              if (a.noAudio) e._emit("loaderror", null, "No audio support.");
              else {
                "string" == typeof e._src && (e._src = [e._src]);
                for (var n = 0; n < e._src.length; n++) {
                  var i, r;
                  if (e._format && e._format[n]) i = e._format[n];
                  else {
                    if ("string" != typeof (r = e._src[n])) {
                      e._emit(
                        "loaderror",
                        null,
                        "Non-string found in selected audio sources - ignoring."
                      );
                      continue;
                    }
                    (i = /^data:audio\/([^;,]+);/i.exec(r)) ||
                      (i = /\.([^.]+)$/.exec(r.split("?", 1)[0])),
                      i && (i = i[1].toLowerCase());
                  }
                  if (
                    (i ||
                      console.warn(
                        'No file extension was found. Consider using the "format" property or specify an extension.'
                      ),
                    i && a.codecs(i))
                  ) {
                    t = e._src[n];
                    break;
                  }
                }
                if (t)
                  return (
                    (e._src = t),
                    (e._state = "loading"),
                    "https:" === window.location.protocol &&
                      "http:" === t.slice(0, 5) &&
                      ((e._html5 = !0), (e._webAudio = !1)),
                    new s(e),
                    e._webAudio && l(e),
                    e
                  );
                e._emit(
                  "loaderror",
                  null,
                  "No codec support for selected audio sources."
                );
              }
            },
            play: function (e, t) {
              var n = this,
                i = null;
              if ("number" == typeof e) (i = e), (e = null);
              else {
                if (
                  "string" == typeof e &&
                  "loaded" === n._state &&
                  !n._sprite[e]
                )
                  return null;
                if (void 0 === e && ((e = "__default"), !n._playLock)) {
                  for (var r = 0, o = 0; o < n._sounds.length; o++)
                    n._sounds[o]._paused &&
                      !n._sounds[o]._ended &&
                      (r++, (i = n._sounds[o]._id));
                  1 === r ? (e = null) : (i = null);
                }
              }
              var s = i ? n._soundById(i) : n._inactiveSound();
              if (!s) return null;
              if (
                (i && !e && (e = s._sprite || "__default"),
                "loaded" !== n._state)
              ) {
                (s._sprite = e), (s._ended = !1);
                var c = s._id;
                return (
                  n._queue.push({
                    event: "play",
                    action: function () {
                      n.play(c);
                    },
                  }),
                  c
                );
              }
              if (i && !s._paused) return t || n._loadQueue("play"), s._id;
              n._webAudio && a._autoResume();
              var l = Math.max(
                  0,
                  s._seek > 0 ? s._seek : n._sprite[e][0] / 1e3
                ),
                h = Math.max(0, (n._sprite[e][0] + n._sprite[e][1]) / 1e3 - l),
                u = (1e3 * h) / Math.abs(s._rate),
                p = n._sprite[e][0] / 1e3,
                d = (n._sprite[e][0] + n._sprite[e][1]) / 1e3;
              (s._sprite = e), (s._ended = !1);
              var f = function () {
                (s._paused = !1),
                  (s._seek = l),
                  (s._start = p),
                  (s._stop = d),
                  (s._loop = !(!s._loop && !n._sprite[e][2]));
              };
              if (!(l >= d)) {
                var m = s._node;
                if (n._webAudio) {
                  var g = function () {
                    (n._playLock = !1), f(), n._refreshBuffer(s);
                    var e = s._muted || n._muted ? 0 : s._volume;
                    m.gain.setValueAtTime(e, a.ctx.currentTime),
                      (s._playStart = a.ctx.currentTime),
                      void 0 === m.bufferSource.start
                        ? s._loop
                          ? m.bufferSource.noteGrainOn(0, l, 86400)
                          : m.bufferSource.noteGrainOn(0, l, h)
                        : s._loop
                        ? m.bufferSource.start(0, l, 86400)
                        : m.bufferSource.start(0, l, h),
                      u !== 1 / 0 &&
                        (n._endTimers[s._id] = setTimeout(
                          n._ended.bind(n, s),
                          u
                        )),
                      t ||
                        setTimeout(function () {
                          n._emit("play", s._id), n._loadQueue();
                        }, 0);
                  };
                  "running" === a.state && "interrupted" !== a.ctx.state
                    ? g()
                    : ((n._playLock = !0),
                      n.once("resume", g),
                      n._clearTimer(s._id));
                } else {
                  var v = function () {
                    (m.currentTime = l),
                      (m.muted = s._muted || n._muted || a._muted || m.muted),
                      (m.volume = s._volume * a.volume()),
                      (m.playbackRate = s._rate);
                    try {
                      var i = m.play();
                      if (
                        (i &&
                        "undefined" != typeof Promise &&
                        (i instanceof Promise || "function" == typeof i.then)
                          ? ((n._playLock = !0),
                            f(),
                            i
                              .then(function () {
                                (n._playLock = !1),
                                  (m._unlocked = !0),
                                  t || (n._emit("play", s._id), n._loadQueue());
                              })
                              .catch(function () {
                                (n._playLock = !1),
                                  n._emit(
                                    "playerror",
                                    s._id,
                                    "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                                  ),
                                  (s._ended = !0),
                                  (s._paused = !0);
                              }))
                          : t ||
                            ((n._playLock = !1),
                            f(),
                            n._emit("play", s._id),
                            n._loadQueue()),
                        (m.playbackRate = s._rate),
                        m.paused)
                      )
                        return void n._emit(
                          "playerror",
                          s._id,
                          "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                        );
                      "__default" !== e || s._loop
                        ? (n._endTimers[s._id] = setTimeout(
                            n._ended.bind(n, s),
                            u
                          ))
                        : ((n._endTimers[s._id] = function () {
                            n._ended(s),
                              m.removeEventListener(
                                "ended",
                                n._endTimers[s._id],
                                !1
                              );
                          }),
                          m.addEventListener("ended", n._endTimers[s._id], !1));
                    } catch (e) {
                      n._emit("playerror", s._id, e);
                    }
                  };
                  "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" ===
                    m.src && ((m.src = n._src), m.load());
                  var y =
                    (window && window.ejecta) ||
                    (!m.readyState && a._navigator.isCocoonJS);
                  if (m.readyState >= 3 || y) v();
                  else {
                    n._playLock = !0;
                    var _ = function () {
                      v(), m.removeEventListener(a._canPlayEvent, _, !1);
                    };
                    m.addEventListener(a._canPlayEvent, _, !1),
                      n._clearTimer(s._id);
                  }
                }
                return s._id;
              }
              n._ended(s);
            },
            pause: function (e) {
              var t = this;
              if ("loaded" !== t._state || t._playLock)
                return (
                  t._queue.push({
                    event: "pause",
                    action: function () {
                      t.pause(e);
                    },
                  }),
                  t
                );
              for (var n = t._getSoundIds(e), i = 0; i < n.length; i++) {
                t._clearTimer(n[i]);
                var r = t._soundById(n[i]);
                if (
                  r &&
                  !r._paused &&
                  ((r._seek = t.seek(n[i])),
                  (r._rateSeek = 0),
                  (r._paused = !0),
                  t._stopFade(n[i]),
                  r._node)
                )
                  if (t._webAudio) {
                    if (!r._node.bufferSource) continue;
                    void 0 === r._node.bufferSource.stop
                      ? r._node.bufferSource.noteOff(0)
                      : r._node.bufferSource.stop(0),
                      t._cleanBuffer(r._node);
                  } else
                    (isNaN(r._node.duration) && r._node.duration !== 1 / 0) ||
                      r._node.pause();
                arguments[1] || t._emit("pause", r ? r._id : null);
              }
              return t;
            },
            stop: function (e, t) {
              var n = this;
              if ("loaded" !== n._state || n._playLock)
                return (
                  n._queue.push({
                    event: "stop",
                    action: function () {
                      n.stop(e);
                    },
                  }),
                  n
                );
              for (var i = n._getSoundIds(e), r = 0; r < i.length; r++) {
                n._clearTimer(i[r]);
                var a = n._soundById(i[r]);
                a &&
                  ((a._seek = a._start || 0),
                  (a._rateSeek = 0),
                  (a._paused = !0),
                  (a._ended = !0),
                  n._stopFade(i[r]),
                  a._node &&
                    (n._webAudio
                      ? a._node.bufferSource &&
                        (void 0 === a._node.bufferSource.stop
                          ? a._node.bufferSource.noteOff(0)
                          : a._node.bufferSource.stop(0),
                        n._cleanBuffer(a._node))
                      : (isNaN(a._node.duration) &&
                          a._node.duration !== 1 / 0) ||
                        ((a._node.currentTime = a._start || 0),
                        a._node.pause(),
                        a._node.duration === 1 / 0 && n._clearSound(a._node))),
                  t || n._emit("stop", a._id));
              }
              return n;
            },
            mute: function (e, t) {
              var n = this;
              if ("loaded" !== n._state || n._playLock)
                return (
                  n._queue.push({
                    event: "mute",
                    action: function () {
                      n.mute(e, t);
                    },
                  }),
                  n
                );
              if (void 0 === t) {
                if ("boolean" != typeof e) return n._muted;
                n._muted = e;
              }
              for (var i = n._getSoundIds(t), r = 0; r < i.length; r++) {
                var o = n._soundById(i[r]);
                o &&
                  ((o._muted = e),
                  o._interval && n._stopFade(o._id),
                  n._webAudio && o._node
                    ? o._node.gain.setValueAtTime(
                        e ? 0 : o._volume,
                        a.ctx.currentTime
                      )
                    : o._node && (o._node.muted = !!a._muted || e),
                  n._emit("mute", o._id));
              }
              return n;
            },
            volume: function () {
              var e,
                t,
                n,
                i = this,
                r = arguments;
              if (0 === r.length) return i._volume;
              if (1 === r.length || (2 === r.length && void 0 === r[1])) {
                var o = i._getSoundIds(),
                  s = o.indexOf(r[0]);
                s >= 0 ? (t = parseInt(r[0], 10)) : (e = parseFloat(r[0]));
              } else
                r.length >= 2 &&
                  ((e = parseFloat(r[0])), (t = parseInt(r[1], 10)));
              if (!(void 0 !== e && e >= 0 && e <= 1))
                return (n = t ? i._soundById(t) : i._sounds[0]) ? n._volume : 0;
              if ("loaded" !== i._state || i._playLock)
                return (
                  i._queue.push({
                    event: "volume",
                    action: function () {
                      i.volume.apply(i, r);
                    },
                  }),
                  i
                );
              void 0 === t && (i._volume = e), (t = i._getSoundIds(t));
              for (var c = 0; c < t.length; c++)
                (n = i._soundById(t[c])) &&
                  ((n._volume = e),
                  r[2] || i._stopFade(t[c]),
                  i._webAudio && n._node && !n._muted
                    ? n._node.gain.setValueAtTime(e, a.ctx.currentTime)
                    : n._node && !n._muted && (n._node.volume = e * a.volume()),
                  i._emit("volume", n._id));
              return i;
            },
            fade: function (e, t, n, i) {
              var r = this;
              if ("loaded" !== r._state || r._playLock)
                return (
                  r._queue.push({
                    event: "fade",
                    action: function () {
                      r.fade(e, t, n, i);
                    },
                  }),
                  r
                );
              (e = Math.min(Math.max(0, parseFloat(e)), 1)),
                (t = Math.min(Math.max(0, parseFloat(t)), 1)),
                (n = parseFloat(n)),
                r.volume(e, i);
              for (var o = r._getSoundIds(i), s = 0; s < o.length; s++) {
                var c = r._soundById(o[s]);
                if (c) {
                  if ((i || r._stopFade(o[s]), r._webAudio && !c._muted)) {
                    var l = a.ctx.currentTime,
                      h = l + n / 1e3;
                    (c._volume = e),
                      c._node.gain.setValueAtTime(e, l),
                      c._node.gain.linearRampToValueAtTime(t, h);
                  }
                  r._startFadeInterval(c, e, t, n, o[s], void 0 === i);
                }
              }
              return r;
            },
            _startFadeInterval: function (e, t, n, i, r, a) {
              var o = this,
                s = t,
                c = n - t,
                l = Math.abs(c / 0.01),
                h = Math.max(4, l > 0 ? i / l : i),
                u = Date.now();
              (e._fadeTo = n),
                (e._interval = setInterval(function () {
                  var r = (Date.now() - u) / i;
                  (u = Date.now()),
                    (s += c * r),
                    (s = Math.round(100 * s) / 100),
                    (s = c < 0 ? Math.max(n, s) : Math.min(n, s)),
                    o._webAudio ? (e._volume = s) : o.volume(s, e._id, !0),
                    a && (o._volume = s),
                    ((n < t && s <= n) || (n > t && s >= n)) &&
                      (clearInterval(e._interval),
                      (e._interval = null),
                      (e._fadeTo = null),
                      o.volume(n, e._id),
                      o._emit("fade", e._id));
                }, h));
            },
            _stopFade: function (e) {
              var t = this,
                n = t._soundById(e);
              return (
                n &&
                  n._interval &&
                  (t._webAudio &&
                    n._node.gain.cancelScheduledValues(a.ctx.currentTime),
                  clearInterval(n._interval),
                  (n._interval = null),
                  t.volume(n._fadeTo, e),
                  (n._fadeTo = null),
                  t._emit("fade", e)),
                t
              );
            },
            loop: function () {
              var e,
                t,
                n,
                i = this,
                r = arguments;
              if (0 === r.length) return i._loop;
              if (1 === r.length) {
                if ("boolean" != typeof r[0])
                  return !!(n = i._soundById(parseInt(r[0], 10))) && n._loop;
                (e = r[0]), (i._loop = e);
              } else 2 === r.length && ((e = r[0]), (t = parseInt(r[1], 10)));
              for (var a = i._getSoundIds(t), o = 0; o < a.length; o++)
                (n = i._soundById(a[o])) &&
                  ((n._loop = e),
                  i._webAudio &&
                    n._node &&
                    n._node.bufferSource &&
                    ((n._node.bufferSource.loop = e),
                    e &&
                      ((n._node.bufferSource.loopStart = n._start || 0),
                      (n._node.bufferSource.loopEnd = n._stop))));
              return i;
            },
            rate: function () {
              var e,
                t,
                n,
                i = this,
                r = arguments;
              if (0 === r.length) t = i._sounds[0]._id;
              else if (1 === r.length) {
                var o = i._getSoundIds(),
                  s = o.indexOf(r[0]);
                s >= 0 ? (t = parseInt(r[0], 10)) : (e = parseFloat(r[0]));
              } else
                2 === r.length &&
                  ((e = parseFloat(r[0])), (t = parseInt(r[1], 10)));
              if ("number" != typeof e)
                return (n = i._soundById(t)) ? n._rate : i._rate;
              if ("loaded" !== i._state || i._playLock)
                return (
                  i._queue.push({
                    event: "rate",
                    action: function () {
                      i.rate.apply(i, r);
                    },
                  }),
                  i
                );
              void 0 === t && (i._rate = e), (t = i._getSoundIds(t));
              for (var c = 0; c < t.length; c++)
                if ((n = i._soundById(t[c]))) {
                  i.playing(t[c]) &&
                    ((n._rateSeek = i.seek(t[c])),
                    (n._playStart = i._webAudio
                      ? a.ctx.currentTime
                      : n._playStart)),
                    (n._rate = e),
                    i._webAudio && n._node && n._node.bufferSource
                      ? n._node.bufferSource.playbackRate.setValueAtTime(
                          e,
                          a.ctx.currentTime
                        )
                      : n._node && (n._node.playbackRate = e);
                  var l = i.seek(t[c]),
                    h =
                      (i._sprite[n._sprite][0] + i._sprite[n._sprite][1]) /
                        1e3 -
                      l,
                    u = (1e3 * h) / Math.abs(n._rate);
                  (!i._endTimers[t[c]] && n._paused) ||
                    (i._clearTimer(t[c]),
                    (i._endTimers[t[c]] = setTimeout(i._ended.bind(i, n), u))),
                    i._emit("rate", n._id);
                }
              return i;
            },
            seek: function () {
              var e,
                t,
                n = this,
                i = arguments;
              if (0 === i.length) t = n._sounds[0]._id;
              else if (1 === i.length) {
                var r = n._getSoundIds(),
                  o = r.indexOf(i[0]);
                o >= 0
                  ? (t = parseInt(i[0], 10))
                  : n._sounds.length &&
                    ((t = n._sounds[0]._id), (e = parseFloat(i[0])));
              } else
                2 === i.length &&
                  ((e = parseFloat(i[0])), (t = parseInt(i[1], 10)));
              if (void 0 === t) return n;
              if (
                "number" == typeof e &&
                ("loaded" !== n._state || n._playLock)
              )
                return (
                  n._queue.push({
                    event: "seek",
                    action: function () {
                      n.seek.apply(n, i);
                    },
                  }),
                  n
                );
              var s = n._soundById(t);
              if (s) {
                if (!("number" == typeof e && e >= 0)) {
                  if (n._webAudio) {
                    var c = n.playing(t) ? a.ctx.currentTime - s._playStart : 0,
                      l = s._rateSeek ? s._rateSeek - s._seek : 0;
                    return s._seek + (l + c * Math.abs(s._rate));
                  }
                  return s._node.currentTime;
                }
                var h = n.playing(t);
                h && n.pause(t, !0),
                  (s._seek = e),
                  (s._ended = !1),
                  n._clearTimer(t),
                  n._webAudio ||
                    !s._node ||
                    isNaN(s._node.duration) ||
                    (s._node.currentTime = e);
                var u = function () {
                  n._emit("seek", t), h && n.play(t, !0);
                };
                if (h && !n._webAudio) {
                  var p = function () {
                    n._playLock ? setTimeout(p, 0) : u();
                  };
                  setTimeout(p, 0);
                } else u();
              }
              return n;
            },
            playing: function (e) {
              var t = this;
              if ("number" == typeof e) {
                var n = t._soundById(e);
                return !!n && !n._paused;
              }
              for (var i = 0; i < t._sounds.length; i++)
                if (!t._sounds[i]._paused) return !0;
              return !1;
            },
            duration: function (e) {
              var t = this,
                n = t._duration,
                i = t._soundById(e);
              return i && (n = t._sprite[i._sprite][1] / 1e3), n;
            },
            state: function () {
              return this._state;
            },
            unload: function () {
              for (var e = this, t = e._sounds, n = 0; n < t.length; n++)
                t[n]._paused || e.stop(t[n]._id),
                  e._webAudio ||
                    (e._clearSound(t[n]._node),
                    t[n]._node.removeEventListener("error", t[n]._errorFn, !1),
                    t[n]._node.removeEventListener(
                      a._canPlayEvent,
                      t[n]._loadFn,
                      !1
                    ),
                    t[n]._node.removeEventListener("ended", t[n]._endFn, !1),
                    a._releaseHtml5Audio(t[n]._node)),
                  delete t[n]._node,
                  e._clearTimer(t[n]._id);
              var i = a._howls.indexOf(e);
              i >= 0 && a._howls.splice(i, 1);
              var r = !0;
              for (n = 0; n < a._howls.length; n++)
                if (
                  a._howls[n]._src === e._src ||
                  e._src.indexOf(a._howls[n]._src) >= 0
                ) {
                  r = !1;
                  break;
                }
              return (
                c && r && delete c[e._src],
                (a.noAudio = !1),
                (e._state = "unloaded"),
                (e._sounds = []),
                (e = null),
                null
              );
            },
            on: function (e, t, n, i) {
              var r = this["_on" + e];
              return (
                "function" == typeof t &&
                  r.push(i ? { id: n, fn: t, once: i } : { id: n, fn: t }),
                this
              );
            },
            off: function (e, t, n) {
              var i = this,
                r = i["_on" + e],
                a = 0;
              if (("number" == typeof t && ((n = t), (t = null)), t || n))
                for (a = 0; a < r.length; a++) {
                  var o = n === r[a].id;
                  if ((t === r[a].fn && o) || (!t && o)) {
                    r.splice(a, 1);
                    break;
                  }
                }
              else if (e) i["_on" + e] = [];
              else {
                var s = Object.keys(i);
                for (a = 0; a < s.length; a++)
                  0 === s[a].indexOf("_on") &&
                    Array.isArray(i[s[a]]) &&
                    (i[s[a]] = []);
              }
              return i;
            },
            once: function (e, t, n) {
              return this.on(e, t, n, 1), this;
            },
            _emit: function (e, t, n) {
              for (
                var i = this, r = i["_on" + e], a = r.length - 1;
                a >= 0;
                a--
              )
                (r[a].id && r[a].id !== t && "load" !== e) ||
                  (setTimeout(
                    function (e) {
                      e.call(this, t, n);
                    }.bind(i, r[a].fn),
                    0
                  ),
                  r[a].once && i.off(e, r[a].fn, r[a].id));
              return i._loadQueue(e), i;
            },
            _loadQueue: function (e) {
              var t = this;
              if (t._queue.length > 0) {
                var n = t._queue[0];
                n.event === e && (t._queue.shift(), t._loadQueue()),
                  e || n.action();
              }
              return t;
            },
            _ended: function (e) {
              var t = this,
                n = e._sprite;
              if (
                !t._webAudio &&
                e._node &&
                !e._node.paused &&
                !e._node.ended &&
                e._node.currentTime < e._stop
              )
                return setTimeout(t._ended.bind(t, e), 100), t;
              var i = !(!e._loop && !t._sprite[n][2]);
              if (
                (t._emit("end", e._id),
                !t._webAudio && i && t.stop(e._id, !0).play(e._id),
                t._webAudio && i)
              ) {
                t._emit("play", e._id),
                  (e._seek = e._start || 0),
                  (e._rateSeek = 0),
                  (e._playStart = a.ctx.currentTime);
                var r = (1e3 * (e._stop - e._start)) / Math.abs(e._rate);
                t._endTimers[e._id] = setTimeout(t._ended.bind(t, e), r);
              }
              return (
                t._webAudio &&
                  !i &&
                  ((e._paused = !0),
                  (e._ended = !0),
                  (e._seek = e._start || 0),
                  (e._rateSeek = 0),
                  t._clearTimer(e._id),
                  t._cleanBuffer(e._node),
                  a._autoSuspend()),
                t._webAudio || i || t.stop(e._id, !0),
                t
              );
            },
            _clearTimer: function (e) {
              var t = this;
              if (t._endTimers[e]) {
                if ("function" != typeof t._endTimers[e])
                  clearTimeout(t._endTimers[e]);
                else {
                  var n = t._soundById(e);
                  n &&
                    n._node &&
                    n._node.removeEventListener("ended", t._endTimers[e], !1);
                }
                delete t._endTimers[e];
              }
              return t;
            },
            _soundById: function (e) {
              for (var t = this, n = 0; n < t._sounds.length; n++)
                if (e === t._sounds[n]._id) return t._sounds[n];
              return null;
            },
            _inactiveSound: function () {
              var e = this;
              e._drain();
              for (var t = 0; t < e._sounds.length; t++)
                if (e._sounds[t]._ended) return e._sounds[t].reset();
              return new s(e);
            },
            _drain: function () {
              var e = this,
                t = e._pool,
                n = 0,
                i = 0;
              if (!(e._sounds.length < t)) {
                for (i = 0; i < e._sounds.length; i++)
                  e._sounds[i]._ended && n++;
                for (i = e._sounds.length - 1; i >= 0; i--) {
                  if (n <= t) return;
                  e._sounds[i]._ended &&
                    (e._webAudio &&
                      e._sounds[i]._node &&
                      e._sounds[i]._node.disconnect(0),
                    e._sounds.splice(i, 1),
                    n--);
                }
              }
            },
            _getSoundIds: function (e) {
              if (void 0 === e) {
                for (var t = [], n = 0; n < this._sounds.length; n++)
                  t.push(this._sounds[n]._id);
                return t;
              }
              return [e];
            },
            _refreshBuffer: function (e) {
              return (
                (e._node.bufferSource = a.ctx.createBufferSource()),
                (e._node.bufferSource.buffer = c[this._src]),
                e._panner
                  ? e._node.bufferSource.connect(e._panner)
                  : e._node.bufferSource.connect(e._node),
                (e._node.bufferSource.loop = e._loop),
                e._loop &&
                  ((e._node.bufferSource.loopStart = e._start || 0),
                  (e._node.bufferSource.loopEnd = e._stop || 0)),
                e._node.bufferSource.playbackRate.setValueAtTime(
                  e._rate,
                  a.ctx.currentTime
                ),
                this
              );
            },
            _cleanBuffer: function (e) {
              var t = a._navigator && a._navigator.vendor.indexOf("Apple") >= 0;
              if (
                a._scratchBuffer &&
                e.bufferSource &&
                ((e.bufferSource.onended = null),
                e.bufferSource.disconnect(0),
                t)
              )
                try {
                  e.bufferSource.buffer = a._scratchBuffer;
                } catch (e) {}
              return (e.bufferSource = null), this;
            },
            _clearSound: function (e) {
              /MSIE |Trident\//.test(a._navigator && a._navigator.userAgent) ||
                (e.src =
                  "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
            },
          };
          var s = function (e) {
            (this._parent = e), this.init();
          };
          s.prototype = {
            init: function () {
              var e = this,
                t = e._parent;
              return (
                (e._muted = t._muted),
                (e._loop = t._loop),
                (e._volume = t._volume),
                (e._rate = t._rate),
                (e._seek = 0),
                (e._paused = !0),
                (e._ended = !0),
                (e._sprite = "__default"),
                (e._id = ++a._counter),
                t._sounds.push(e),
                e.create(),
                e
              );
            },
            create: function () {
              var e = this,
                t = e._parent,
                n = a._muted || e._muted || e._parent._muted ? 0 : e._volume;
              return (
                t._webAudio
                  ? ((e._node =
                      void 0 === a.ctx.createGain
                        ? a.ctx.createGainNode()
                        : a.ctx.createGain()),
                    e._node.gain.setValueAtTime(n, a.ctx.currentTime),
                    (e._node.paused = !0),
                    e._node.connect(a.masterGain))
                  : a.noAudio ||
                    ((e._node = a._obtainHtml5Audio()),
                    (e._errorFn = e._errorListener.bind(e)),
                    e._node.addEventListener("error", e._errorFn, !1),
                    (e._loadFn = e._loadListener.bind(e)),
                    e._node.addEventListener(a._canPlayEvent, e._loadFn, !1),
                    (e._endFn = e._endListener.bind(e)),
                    e._node.addEventListener("ended", e._endFn, !1),
                    (e._node.src = t._src),
                    (e._node.preload = !0 === t._preload ? "auto" : t._preload),
                    (e._node.volume = n * a.volume()),
                    e._node.load()),
                e
              );
            },
            reset: function () {
              var e = this,
                t = e._parent;
              return (
                (e._muted = t._muted),
                (e._loop = t._loop),
                (e._volume = t._volume),
                (e._rate = t._rate),
                (e._seek = 0),
                (e._rateSeek = 0),
                (e._paused = !0),
                (e._ended = !0),
                (e._sprite = "__default"),
                (e._id = ++a._counter),
                e
              );
            },
            _errorListener: function () {
              var e = this;
              e._parent._emit(
                "loaderror",
                e._id,
                e._node.error ? e._node.error.code : 0
              ),
                e._node.removeEventListener("error", e._errorFn, !1);
            },
            _loadListener: function () {
              var e = this,
                t = e._parent;
              (t._duration = Math.ceil(10 * e._node.duration) / 10),
                0 === Object.keys(t._sprite).length &&
                  (t._sprite = { __default: [0, 1e3 * t._duration] }),
                "loaded" !== t._state &&
                  ((t._state = "loaded"), t._emit("load"), t._loadQueue()),
                e._node.removeEventListener(a._canPlayEvent, e._loadFn, !1);
            },
            _endListener: function () {
              var e = this,
                t = e._parent;
              t._duration === 1 / 0 &&
                ((t._duration = Math.ceil(10 * e._node.duration) / 10),
                t._sprite.__default[1] === 1 / 0 &&
                  (t._sprite.__default[1] = 1e3 * t._duration),
                t._ended(e)),
                e._node.removeEventListener("ended", e._endFn, !1);
            },
          };
          var c = {},
            l = function (e) {
              var t = e._src;
              if (c[t]) return (e._duration = c[t].duration), void p(e);
              if (/^data:[^;]+;base64,/.test(t)) {
                for (
                  var n = atob(t.split(",")[1]),
                    i = new Uint8Array(n.length),
                    r = 0;
                  r < n.length;
                  ++r
                )
                  i[r] = n.charCodeAt(r);
                u(i.buffer, e);
              } else {
                var a = new XMLHttpRequest();
                a.open(e._xhr.method, t, !0),
                  (a.withCredentials = e._xhr.withCredentials),
                  (a.responseType = "arraybuffer"),
                  e._xhr.headers &&
                    Object.keys(e._xhr.headers).forEach(function (t) {
                      a.setRequestHeader(t, e._xhr.headers[t]);
                    }),
                  (a.onload = function () {
                    var t = (a.status + "")[0];
                    "0" === t || "2" === t || "3" === t
                      ? u(a.response, e)
                      : e._emit(
                          "loaderror",
                          null,
                          "Failed loading audio file with status: " +
                            a.status +
                            "."
                        );
                  }),
                  (a.onerror = function () {
                    e._webAudio &&
                      ((e._html5 = !0),
                      (e._webAudio = !1),
                      (e._sounds = []),
                      delete c[t],
                      e.load());
                  }),
                  h(a);
              }
            },
            h = function (e) {
              try {
                e.send();
              } catch (t) {
                e.onerror();
              }
            },
            u = function (e, t) {
              var n = function () {
                  t._emit("loaderror", null, "Decoding audio data failed.");
                },
                i = function (e) {
                  e && t._sounds.length > 0 ? ((c[t._src] = e), p(t, e)) : n();
                };
              "undefined" != typeof Promise &&
              1 === a.ctx.decodeAudioData.length
                ? a.ctx.decodeAudioData(e).then(i).catch(n)
                : a.ctx.decodeAudioData(e, i, n);
            },
            p = function (e, t) {
              t && !e._duration && (e._duration = t.duration),
                0 === Object.keys(e._sprite).length &&
                  (e._sprite = { __default: [0, 1e3 * e._duration] }),
                "loaded" !== e._state &&
                  ((e._state = "loaded"), e._emit("load"), e._loadQueue());
            },
            d = function () {
              if (a.usingWebAudio) {
                try {
                  "undefined" != typeof AudioContext
                    ? (a.ctx = new AudioContext())
                    : "undefined" != typeof webkitAudioContext
                    ? (a.ctx = new webkitAudioContext())
                    : (a.usingWebAudio = !1);
                } catch (e) {
                  a.usingWebAudio = !1;
                }
                a.ctx || (a.usingWebAudio = !1);
                var e = /iP(hone|od|ad)/.test(
                    a._navigator && a._navigator.platform
                  ),
                  t =
                    a._navigator &&
                    a._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                  n = t ? parseInt(t[1], 10) : null;
                if (e && n && n < 9) {
                  var i = /safari/.test(
                    a._navigator && a._navigator.userAgent.toLowerCase()
                  );
                  a._navigator && !i && (a.usingWebAudio = !1);
                }
                a.usingWebAudio &&
                  ((a.masterGain =
                    void 0 === a.ctx.createGain
                      ? a.ctx.createGainNode()
                      : a.ctx.createGain()),
                  a.masterGain.gain.setValueAtTime(
                    a._muted ? 0 : a._volume,
                    a.ctx.currentTime
                  ),
                  a.masterGain.connect(a.ctx.destination)),
                  a._setup();
              }
            };
          void 0 ===
            (i = function () {
              return { Howler: a, Howl: o };
            }.apply(t, [])) || (e.exports = i),
            (t.Howler = a),
            (t.Howl = o),
            void 0 !== n.g
              ? ((n.g.HowlerGlobal = r),
                (n.g.Howler = a),
                (n.g.Howl = o),
                (n.g.Sound = s))
              : "undefined" != typeof window &&
                ((window.HowlerGlobal = r),
                (window.Howler = a),
                (window.Howl = o),
                (window.Sound = s));
        })(),
          (function () {
            "use strict";
            var e;
            (HowlerGlobal.prototype._pos = [0, 0, 0]),
              (HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0]),
              (HowlerGlobal.prototype.stereo = function (e) {
                var t = this;
                if (!t.ctx || !t.ctx.listener) return t;
                for (var n = t._howls.length - 1; n >= 0; n--)
                  t._howls[n].stereo(e);
                return t;
              }),
              (HowlerGlobal.prototype.pos = function (e, t, n) {
                var i = this;
                return i.ctx && i.ctx.listener
                  ? ((t = "number" != typeof t ? i._pos[1] : t),
                    (n = "number" != typeof n ? i._pos[2] : n),
                    "number" != typeof e
                      ? i._pos
                      : ((i._pos = [e, t, n]),
                        void 0 !== i.ctx.listener.positionX
                          ? (i.ctx.listener.positionX.setTargetAtTime(
                              i._pos[0],
                              Howler.ctx.currentTime,
                              0.1
                            ),
                            i.ctx.listener.positionY.setTargetAtTime(
                              i._pos[1],
                              Howler.ctx.currentTime,
                              0.1
                            ),
                            i.ctx.listener.positionZ.setTargetAtTime(
                              i._pos[2],
                              Howler.ctx.currentTime,
                              0.1
                            ))
                          : i.ctx.listener.setPosition(
                              i._pos[0],
                              i._pos[1],
                              i._pos[2]
                            ),
                        i))
                  : i;
              }),
              (HowlerGlobal.prototype.orientation = function (
                e,
                t,
                n,
                i,
                r,
                a
              ) {
                var o = this;
                if (!o.ctx || !o.ctx.listener) return o;
                var s = o._orientation;
                return (
                  (t = "number" != typeof t ? s[1] : t),
                  (n = "number" != typeof n ? s[2] : n),
                  (i = "number" != typeof i ? s[3] : i),
                  (r = "number" != typeof r ? s[4] : r),
                  (a = "number" != typeof a ? s[5] : a),
                  "number" != typeof e
                    ? s
                    : ((o._orientation = [e, t, n, i, r, a]),
                      void 0 !== o.ctx.listener.forwardX
                        ? (o.ctx.listener.forwardX.setTargetAtTime(
                            e,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          o.ctx.listener.forwardY.setTargetAtTime(
                            t,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          o.ctx.listener.forwardZ.setTargetAtTime(
                            n,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          o.ctx.listener.upX.setTargetAtTime(
                            i,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          o.ctx.listener.upY.setTargetAtTime(
                            r,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          o.ctx.listener.upZ.setTargetAtTime(
                            a,
                            Howler.ctx.currentTime,
                            0.1
                          ))
                        : o.ctx.listener.setOrientation(e, t, n, i, r, a),
                      o)
                );
              }),
              (Howl.prototype.init =
                ((e = Howl.prototype.init),
                function (t) {
                  var n = this;
                  return (
                    (n._orientation = t.orientation || [1, 0, 0]),
                    (n._stereo = t.stereo || null),
                    (n._pos = t.pos || null),
                    (n._pannerAttr = {
                      coneInnerAngle:
                        void 0 !== t.coneInnerAngle ? t.coneInnerAngle : 360,
                      coneOuterAngle:
                        void 0 !== t.coneOuterAngle ? t.coneOuterAngle : 360,
                      coneOuterGain:
                        void 0 !== t.coneOuterGain ? t.coneOuterGain : 0,
                      distanceModel:
                        void 0 !== t.distanceModel
                          ? t.distanceModel
                          : "inverse",
                      maxDistance:
                        void 0 !== t.maxDistance ? t.maxDistance : 1e4,
                      panningModel:
                        void 0 !== t.panningModel ? t.panningModel : "HRTF",
                      refDistance: void 0 !== t.refDistance ? t.refDistance : 1,
                      rolloffFactor:
                        void 0 !== t.rolloffFactor ? t.rolloffFactor : 1,
                    }),
                    (n._onstereo = t.onstereo ? [{ fn: t.onstereo }] : []),
                    (n._onpos = t.onpos ? [{ fn: t.onpos }] : []),
                    (n._onorientation = t.onorientation
                      ? [{ fn: t.onorientation }]
                      : []),
                    e.call(this, t)
                  );
                })),
              (Howl.prototype.stereo = function (e, n) {
                var i = this;
                if (!i._webAudio) return i;
                if ("loaded" !== i._state)
                  return (
                    i._queue.push({
                      event: "stereo",
                      action: function () {
                        i.stereo(e, n);
                      },
                    }),
                    i
                  );
                var r =
                  void 0 === Howler.ctx.createStereoPanner
                    ? "spatial"
                    : "stereo";
                if (void 0 === n) {
                  if ("number" != typeof e) return i._stereo;
                  (i._stereo = e), (i._pos = [e, 0, 0]);
                }
                for (var a = i._getSoundIds(n), o = 0; o < a.length; o++) {
                  var s = i._soundById(a[o]);
                  if (s) {
                    if ("number" != typeof e) return s._stereo;
                    (s._stereo = e),
                      (s._pos = [e, 0, 0]),
                      s._node &&
                        ((s._pannerAttr.panningModel = "equalpower"),
                        (s._panner && s._panner.pan) || t(s, r),
                        "spatial" === r
                          ? void 0 !== s._panner.positionX
                            ? (s._panner.positionX.setValueAtTime(
                                e,
                                Howler.ctx.currentTime
                              ),
                              s._panner.positionY.setValueAtTime(
                                0,
                                Howler.ctx.currentTime
                              ),
                              s._panner.positionZ.setValueAtTime(
                                0,
                                Howler.ctx.currentTime
                              ))
                            : s._panner.setPosition(e, 0, 0)
                          : s._panner.pan.setValueAtTime(
                              e,
                              Howler.ctx.currentTime
                            )),
                      i._emit("stereo", s._id);
                  }
                }
                return i;
              }),
              (Howl.prototype.pos = function (e, n, i, r) {
                var a = this;
                if (!a._webAudio) return a;
                if ("loaded" !== a._state)
                  return (
                    a._queue.push({
                      event: "pos",
                      action: function () {
                        a.pos(e, n, i, r);
                      },
                    }),
                    a
                  );
                if (
                  ((n = "number" != typeof n ? 0 : n),
                  (i = "number" != typeof i ? -0.5 : i),
                  void 0 === r)
                ) {
                  if ("number" != typeof e) return a._pos;
                  a._pos = [e, n, i];
                }
                for (var o = a._getSoundIds(r), s = 0; s < o.length; s++) {
                  var c = a._soundById(o[s]);
                  if (c) {
                    if ("number" != typeof e) return c._pos;
                    (c._pos = [e, n, i]),
                      c._node &&
                        ((c._panner && !c._panner.pan) || t(c, "spatial"),
                        void 0 !== c._panner.positionX
                          ? (c._panner.positionX.setValueAtTime(
                              e,
                              Howler.ctx.currentTime
                            ),
                            c._panner.positionY.setValueAtTime(
                              n,
                              Howler.ctx.currentTime
                            ),
                            c._panner.positionZ.setValueAtTime(
                              i,
                              Howler.ctx.currentTime
                            ))
                          : c._panner.setPosition(e, n, i)),
                      a._emit("pos", c._id);
                  }
                }
                return a;
              }),
              (Howl.prototype.orientation = function (e, n, i, r) {
                var a = this;
                if (!a._webAudio) return a;
                if ("loaded" !== a._state)
                  return (
                    a._queue.push({
                      event: "orientation",
                      action: function () {
                        a.orientation(e, n, i, r);
                      },
                    }),
                    a
                  );
                if (
                  ((n = "number" != typeof n ? a._orientation[1] : n),
                  (i = "number" != typeof i ? a._orientation[2] : i),
                  void 0 === r)
                ) {
                  if ("number" != typeof e) return a._orientation;
                  a._orientation = [e, n, i];
                }
                for (var o = a._getSoundIds(r), s = 0; s < o.length; s++) {
                  var c = a._soundById(o[s]);
                  if (c) {
                    if ("number" != typeof e) return c._orientation;
                    (c._orientation = [e, n, i]),
                      c._node &&
                        (c._panner ||
                          (c._pos || (c._pos = a._pos || [0, 0, -0.5]),
                          t(c, "spatial")),
                        void 0 !== c._panner.orientationX
                          ? (c._panner.orientationX.setValueAtTime(
                              e,
                              Howler.ctx.currentTime
                            ),
                            c._panner.orientationY.setValueAtTime(
                              n,
                              Howler.ctx.currentTime
                            ),
                            c._panner.orientationZ.setValueAtTime(
                              i,
                              Howler.ctx.currentTime
                            ))
                          : c._panner.setOrientation(e, n, i)),
                      a._emit("orientation", c._id);
                  }
                }
                return a;
              }),
              (Howl.prototype.pannerAttr = function () {
                var e,
                  n,
                  i,
                  r = this,
                  a = arguments;
                if (!r._webAudio) return r;
                if (0 === a.length) return r._pannerAttr;
                if (1 === a.length) {
                  if ("object" != typeof a[0])
                    return (i = r._soundById(parseInt(a[0], 10)))
                      ? i._pannerAttr
                      : r._pannerAttr;
                  (e = a[0]),
                    void 0 === n &&
                      (e.pannerAttr ||
                        (e.pannerAttr = {
                          coneInnerAngle: e.coneInnerAngle,
                          coneOuterAngle: e.coneOuterAngle,
                          coneOuterGain: e.coneOuterGain,
                          distanceModel: e.distanceModel,
                          maxDistance: e.maxDistance,
                          refDistance: e.refDistance,
                          rolloffFactor: e.rolloffFactor,
                          panningModel: e.panningModel,
                        }),
                      (r._pannerAttr = {
                        coneInnerAngle:
                          void 0 !== e.pannerAttr.coneInnerAngle
                            ? e.pannerAttr.coneInnerAngle
                            : r._coneInnerAngle,
                        coneOuterAngle:
                          void 0 !== e.pannerAttr.coneOuterAngle
                            ? e.pannerAttr.coneOuterAngle
                            : r._coneOuterAngle,
                        coneOuterGain:
                          void 0 !== e.pannerAttr.coneOuterGain
                            ? e.pannerAttr.coneOuterGain
                            : r._coneOuterGain,
                        distanceModel:
                          void 0 !== e.pannerAttr.distanceModel
                            ? e.pannerAttr.distanceModel
                            : r._distanceModel,
                        maxDistance:
                          void 0 !== e.pannerAttr.maxDistance
                            ? e.pannerAttr.maxDistance
                            : r._maxDistance,
                        refDistance:
                          void 0 !== e.pannerAttr.refDistance
                            ? e.pannerAttr.refDistance
                            : r._refDistance,
                        rolloffFactor:
                          void 0 !== e.pannerAttr.rolloffFactor
                            ? e.pannerAttr.rolloffFactor
                            : r._rolloffFactor,
                        panningModel:
                          void 0 !== e.pannerAttr.panningModel
                            ? e.pannerAttr.panningModel
                            : r._panningModel,
                      }));
                } else 2 === a.length && ((e = a[0]), (n = parseInt(a[1], 10)));
                for (var o = r._getSoundIds(n), s = 0; s < o.length; s++)
                  if ((i = r._soundById(o[s]))) {
                    var c = i._pannerAttr;
                    c = {
                      coneInnerAngle:
                        void 0 !== e.coneInnerAngle
                          ? e.coneInnerAngle
                          : c.coneInnerAngle,
                      coneOuterAngle:
                        void 0 !== e.coneOuterAngle
                          ? e.coneOuterAngle
                          : c.coneOuterAngle,
                      coneOuterGain:
                        void 0 !== e.coneOuterGain
                          ? e.coneOuterGain
                          : c.coneOuterGain,
                      distanceModel:
                        void 0 !== e.distanceModel
                          ? e.distanceModel
                          : c.distanceModel,
                      maxDistance:
                        void 0 !== e.maxDistance
                          ? e.maxDistance
                          : c.maxDistance,
                      refDistance:
                        void 0 !== e.refDistance
                          ? e.refDistance
                          : c.refDistance,
                      rolloffFactor:
                        void 0 !== e.rolloffFactor
                          ? e.rolloffFactor
                          : c.rolloffFactor,
                      panningModel:
                        void 0 !== e.panningModel
                          ? e.panningModel
                          : c.panningModel,
                    };
                    var l = i._panner;
                    l
                      ? ((l.coneInnerAngle = c.coneInnerAngle),
                        (l.coneOuterAngle = c.coneOuterAngle),
                        (l.coneOuterGain = c.coneOuterGain),
                        (l.distanceModel = c.distanceModel),
                        (l.maxDistance = c.maxDistance),
                        (l.refDistance = c.refDistance),
                        (l.rolloffFactor = c.rolloffFactor),
                        (l.panningModel = c.panningModel))
                      : (i._pos || (i._pos = r._pos || [0, 0, -0.5]),
                        t(i, "spatial"));
                  }
                return r;
              }),
              (Sound.prototype.init = (function (e) {
                return function () {
                  var t = this,
                    n = t._parent;
                  (t._orientation = n._orientation),
                    (t._stereo = n._stereo),
                    (t._pos = n._pos),
                    (t._pannerAttr = n._pannerAttr),
                    e.call(this),
                    t._stereo
                      ? n.stereo(t._stereo)
                      : t._pos && n.pos(t._pos[0], t._pos[1], t._pos[2], t._id);
                };
              })(Sound.prototype.init)),
              (Sound.prototype.reset = (function (e) {
                return function () {
                  var t = this,
                    n = t._parent;
                  return (
                    (t._orientation = n._orientation),
                    (t._stereo = n._stereo),
                    (t._pos = n._pos),
                    (t._pannerAttr = n._pannerAttr),
                    t._stereo
                      ? n.stereo(t._stereo)
                      : t._pos
                      ? n.pos(t._pos[0], t._pos[1], t._pos[2], t._id)
                      : t._panner &&
                        (t._panner.disconnect(0),
                        (t._panner = void 0),
                        n._refreshBuffer(t)),
                    e.call(this)
                  );
                };
              })(Sound.prototype.reset));
            var t = function (e, t) {
              "spatial" === (t = t || "spatial")
                ? ((e._panner = Howler.ctx.createPanner()),
                  (e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle),
                  (e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle),
                  (e._panner.coneOuterGain = e._pannerAttr.coneOuterGain),
                  (e._panner.distanceModel = e._pannerAttr.distanceModel),
                  (e._panner.maxDistance = e._pannerAttr.maxDistance),
                  (e._panner.refDistance = e._pannerAttr.refDistance),
                  (e._panner.rolloffFactor = e._pannerAttr.rolloffFactor),
                  (e._panner.panningModel = e._pannerAttr.panningModel),
                  void 0 !== e._panner.positionX
                    ? (e._panner.positionX.setValueAtTime(
                        e._pos[0],
                        Howler.ctx.currentTime
                      ),
                      e._panner.positionY.setValueAtTime(
                        e._pos[1],
                        Howler.ctx.currentTime
                      ),
                      e._panner.positionZ.setValueAtTime(
                        e._pos[2],
                        Howler.ctx.currentTime
                      ))
                    : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]),
                  void 0 !== e._panner.orientationX
                    ? (e._panner.orientationX.setValueAtTime(
                        e._orientation[0],
                        Howler.ctx.currentTime
                      ),
                      e._panner.orientationY.setValueAtTime(
                        e._orientation[1],
                        Howler.ctx.currentTime
                      ),
                      e._panner.orientationZ.setValueAtTime(
                        e._orientation[2],
                        Howler.ctx.currentTime
                      ))
                    : e._panner.setOrientation(
                        e._orientation[0],
                        e._orientation[1],
                        e._orientation[2]
                      ))
                : ((e._panner = Howler.ctx.createStereoPanner()),
                  e._panner.pan.setValueAtTime(
                    e._stereo,
                    Howler.ctx.currentTime
                  )),
                e._panner.connect(e._node),
                e._paused || e._parent.pause(e._id, !0).play(e._id, !0);
            };
          })();
      },
      503: (module) => {
        (window.createjs = window.createjs || {}),
          (function () {
            "use strict";
            var e = (createjs.PreloadJS = createjs.PreloadJS || {});
            (e.version = "0.4.1"),
              (e.buildDate = "Thu, 12 Dec 2013 23:33:38 GMT");
          })(),
          (function () {
            "use strict";
            var e = function (e, t, n) {
                this.initialize(e, t, n);
              },
              t = e.prototype;
            (t.type = null),
              (t.target = null),
              (t.currentTarget = null),
              (t.eventPhase = 0),
              (t.bubbles = !1),
              (t.cancelable = !1),
              (t.timeStamp = 0),
              (t.defaultPrevented = !1),
              (t.propagationStopped = !1),
              (t.immediatePropagationStopped = !1),
              (t.removed = !1),
              (t.initialize = function (e, t, n) {
                (this.type = e),
                  (this.bubbles = t),
                  (this.cancelable = n),
                  (this.timeStamp = new Date().getTime());
              }),
              (t.preventDefault = function () {
                this.defaultPrevented = !0;
              }),
              (t.stopPropagation = function () {
                this.propagationStopped = !0;
              }),
              (t.stopImmediatePropagation = function () {
                this.immediatePropagationStopped = this.propagationStopped = !0;
              }),
              (t.remove = function () {
                this.removed = !0;
              }),
              (t.clone = function () {
                return new e(this.type, this.bubbles, this.cancelable);
              }),
              (t.toString = function () {
                return "[Event (type=" + this.type + ")]";
              }),
              (createjs.Event = e);
          })(),
          (function () {
            "use strict";
            var e = function () {},
              t = e.prototype;
            (e.initialize = function (e) {
              (e.addEventListener = t.addEventListener),
                (e.on = t.on),
                (e.removeEventListener = e.off = t.removeEventListener),
                (e.removeAllEventListeners = t.removeAllEventListeners),
                (e.hasEventListener = t.hasEventListener),
                (e.dispatchEvent = t.dispatchEvent),
                (e._dispatchEvent = t._dispatchEvent),
                (e.willTrigger = t.willTrigger);
            }),
              (t._listeners = null),
              (t._captureListeners = null),
              (t.initialize = function () {}),
              (t.addEventListener = function (e, t, n) {
                var i,
                  r = (i = n
                    ? (this._captureListeners = this._captureListeners || {})
                    : (this._listeners = this._listeners || {}))[e];
                return (
                  r && this.removeEventListener(e, t, n),
                  (r = i[e]) ? r.push(t) : (i[e] = [t]),
                  t
                );
              }),
              (t.on = function (e, t, n, i, r, a) {
                return (
                  t.handleEvent && ((n = n || t), (t = t.handleEvent)),
                  (n = n || this),
                  this.addEventListener(
                    e,
                    function (e) {
                      t.call(n, e, r), i && e.remove();
                    },
                    a
                  )
                );
              }),
              (t.removeEventListener = function (e, t, n) {
                var i = n ? this._captureListeners : this._listeners;
                if (i) {
                  var r = i[e];
                  if (r)
                    for (var a = 0, o = r.length; o > a; a++)
                      if (r[a] == t) {
                        1 == o ? delete i[e] : r.splice(a, 1);
                        break;
                      }
                }
              }),
              (t.off = t.removeEventListener),
              (t.removeAllEventListeners = function (e) {
                e
                  ? (this._listeners && delete this._listeners[e],
                    this._captureListeners && delete this._captureListeners[e])
                  : (this._listeners = this._captureListeners = null);
              }),
              (t.dispatchEvent = function (e, t) {
                if ("string" == typeof e) {
                  var n = this._listeners;
                  if (!n || !n[e]) return !1;
                  e = new createjs.Event(e);
                }
                if (((e.target = t || this), e.bubbles && this.parent)) {
                  for (var i = this, r = [i]; i.parent; )
                    r.push((i = i.parent));
                  var a,
                    o = r.length;
                  for (a = o - 1; a >= 0 && !e.propagationStopped; a--)
                    r[a]._dispatchEvent(e, 1 + (0 == a));
                  for (a = 1; o > a && !e.propagationStopped; a++)
                    r[a]._dispatchEvent(e, 3);
                } else this._dispatchEvent(e, 2);
                return e.defaultPrevented;
              }),
              (t.hasEventListener = function (e) {
                var t = this._listeners,
                  n = this._captureListeners;
                return !!((t && t[e]) || (n && n[e]));
              }),
              (t.willTrigger = function (e) {
                for (var t = this; t; ) {
                  if (t.hasEventListener(e)) return !0;
                  t = t.parent;
                }
                return !1;
              }),
              (t.toString = function () {
                return "[EventDispatcher]";
              }),
              (t._dispatchEvent = function (e, t) {
                var n,
                  i = 1 == t ? this._captureListeners : this._listeners;
                if (e && i) {
                  var r = i[e.type];
                  if (!r || !(n = r.length)) return;
                  (e.currentTarget = this),
                    (e.eventPhase = t),
                    (e.removed = !1),
                    (r = r.slice());
                  for (
                    var a = 0;
                    n > a && !e.immediatePropagationStopped;
                    a++
                  ) {
                    var o = r[a];
                    o.handleEvent ? o.handleEvent(e) : o(e),
                      e.removed &&
                        (this.off(e.type, o, 1 == t), (e.removed = !1));
                  }
                }
              }),
              (createjs.EventDispatcher = e);
          })(),
          (function () {
            "use strict";
            createjs.indexOf = function (e, t) {
              for (var n = 0, i = e.length; i > n; n++)
                if (t === e[n]) return n;
              return -1;
            };
          })(),
          (function () {
            "use strict";
            createjs.proxy = function (e, t) {
              var n = Array.prototype.slice.call(arguments, 2);
              return function () {
                return e.apply(
                  t,
                  Array.prototype.slice.call(arguments, 0).concat(n)
                );
              };
            };
          })(),
          (function () {
            "use strict";
            var e = function () {
                this.init();
              },
              t = (e.prototype = new createjs.EventDispatcher()),
              n = e;
            (n.FILE_PATTERN =
              /^(?:(\w+:)\/{2}(\w+(?:\.\w+)*\/?)|(.{0,2}\/{1}))?([/.]*?(?:[^?]+)?\/)?((?:[^/?]+)\.(\w+))(?:\?(\S+)?)?$/),
              (n.PATH_PATTERN =
                /^(?:(\w+:)\/{2})|(.{0,2}\/{1})?([/.]*?(?:[^?]+)?\/?)?$/),
              (t.loaded = !1),
              (t.canceled = !1),
              (t.progress = 0),
              (t._item = null),
              (t.getItem = function () {
                return this._item;
              }),
              (t.init = function () {}),
              (t.load = function () {}),
              (t.close = function () {}),
              (t._sendLoadStart = function () {
                this._isCanceled() || this.dispatchEvent("loadstart");
              }),
              (t._sendProgress = function (e) {
                if (!this._isCanceled()) {
                  var t = null;
                  "number" == typeof e
                    ? ((this.progress = e),
                      ((t = new createjs.Event("progress")).loaded =
                        this.progress),
                      (t.total = 1))
                    : ((t = e),
                      (this.progress = e.loaded / e.total),
                      (isNaN(this.progress) || 1 / 0 == this.progress) &&
                        (this.progress = 0)),
                    (t.progress = this.progress),
                    this.hasEventListener("progress") && this.dispatchEvent(t);
                }
              }),
              (t._sendComplete = function () {
                this._isCanceled() || this.dispatchEvent("complete");
              }),
              (t._sendError = function (e) {
                !this._isCanceled() &&
                  this.hasEventListener("error") &&
                  (null == e && (e = new createjs.Event("error")),
                  this.dispatchEvent(e));
              }),
              (t._isCanceled = function () {
                return !(null != window.createjs && !this.canceled);
              }),
              (t._parseURI = function (e) {
                return e ? e.match(n.FILE_PATTERN) : null;
              }),
              (t._parsePath = function (e) {
                return e ? e.match(n.PATH_PATTERN) : null;
              }),
              (t._formatQueryString = function (e, t) {
                if (null == e) throw new Error("You must specify data.");
                var n = [];
                for (var i in e) n.push(i + "=" + escape(e[i]));
                return t && (n = n.concat(t)), n.join("&");
              }),
              (t.buildPath = function (e, t) {
                if (null == t) return e;
                var n = [],
                  i = e.indexOf("?");
                if (-1 != i) {
                  var r = e.slice(i + 1);
                  n = n.concat(r.split("&"));
                }
                return -1 != i
                  ? e.slice(0, i) + "?" + this._formatQueryString(t, n)
                  : e + "?" + this._formatQueryString(t, n);
              }),
              (t._isCrossDomain = function (e) {
                var t = document.createElement("a");
                t.href = e.src;
                var n = document.createElement("a");
                return (
                  (n.href = location.href),
                  "" != t.hostname &&
                    (t.port != n.port ||
                      t.protocol != n.protocol ||
                      t.hostname != n.hostname)
                );
              }),
              (t._isLocal = function (e) {
                var t = document.createElement("a");
                return (
                  (t.href = e.src), "" == t.hostname && "file:" == t.protocol
                );
              }),
              (t.toString = function () {
                return "[PreloadJS AbstractLoader]";
              }),
              (createjs.AbstractLoader = e);
          })(),
          (function () {
            "use strict";
            var e = function (e, t, n) {
                this.init(e, t, n);
              },
              t = (e.prototype = new createjs.AbstractLoader()),
              n = e;
            (n.loadTimeout = 8e3),
              (n.LOAD_TIMEOUT = 0),
              (n.BINARY = "binary"),
              (n.CSS = "css"),
              (n.IMAGE = "image"),
              (n.JAVASCRIPT = "javascript"),
              (n.JSON = "json"),
              (n.JSONP = "jsonp"),
              (n.MANIFEST = "manifest"),
              (n.SOUND = "sound"),
              (n.SVG = "svg"),
              (n.TEXT = "text"),
              (n.XML = "xml"),
              (n.POST = "POST"),
              (n.GET = "GET"),
              (t._basePath = null),
              (t._crossOrigin = ""),
              (t.useXHR = !0),
              (t.stopOnError = !1),
              (t.maintainScriptOrder = !0),
              (t.next = null),
              (t._typeCallbacks = null),
              (t._extensionCallbacks = null),
              (t._loadStartWasDispatched = !1),
              (t._maxConnections = 1),
              (t._currentlyLoadingScript = null),
              (t._currentLoads = null),
              (t._loadQueue = null),
              (t._loadQueueBackup = null),
              (t._loadItemsById = null),
              (t._loadItemsBySrc = null),
              (t._loadedResults = null),
              (t._loadedRawResults = null),
              (t._numItems = 0),
              (t._numItemsLoaded = 0),
              (t._scriptOrder = null),
              (t._loadedScripts = null),
              (t.init = function (e, t, n) {
                (this._numItems = this._numItemsLoaded = 0),
                  (this._paused = !1),
                  (this._loadStartWasDispatched = !1),
                  (this._currentLoads = []),
                  (this._loadQueue = []),
                  (this._loadQueueBackup = []),
                  (this._scriptOrder = []),
                  (this._loadedScripts = []),
                  (this._loadItemsById = {}),
                  (this._loadItemsBySrc = {}),
                  (this._loadedResults = {}),
                  (this._loadedRawResults = {}),
                  (this._typeCallbacks = {}),
                  (this._extensionCallbacks = {}),
                  (this._basePath = t),
                  this.setUseXHR(e),
                  (this._crossOrigin =
                    !0 === n ? "Anonymous" : !1 === n || null == n ? "" : n);
              }),
              (t.setUseXHR = function (e) {
                return (
                  (this.useXHR = 0 != e && null != window.XMLHttpRequest),
                  this.useXHR
                );
              }),
              (t.removeAll = function () {
                this.remove();
              }),
              (t.remove = function (e) {
                var t = null;
                if (!e || e instanceof Array) {
                  if (e) t = e;
                  else if (arguments.length > 0) return;
                } else t = [e];
                var n = !1;
                if (t) {
                  for (; t.length; ) {
                    var i = t.pop(),
                      r = this.getResult(i);
                    for (a = this._loadQueue.length - 1; a >= 0; a--)
                      if (
                        (o = this._loadQueue[a].getItem()).id == i ||
                        o.src == i
                      ) {
                        this._loadQueue.splice(a, 1)[0].cancel();
                        break;
                      }
                    for (a = this._loadQueueBackup.length - 1; a >= 0; a--)
                      if (
                        (o = this._loadQueueBackup[a].getItem()).id == i ||
                        o.src == i
                      ) {
                        this._loadQueueBackup.splice(a, 1)[0].cancel();
                        break;
                      }
                    if (r)
                      delete this._loadItemsById[r.id],
                        delete this._loadItemsBySrc[r.src],
                        this._disposeItem(r);
                    else
                      for (var a = this._currentLoads.length - 1; a >= 0; a--) {
                        var o = this._currentLoads[a].getItem();
                        if (o.id == i || o.src == i) {
                          this._currentLoads.splice(a, 1)[0].cancel(), (n = !0);
                          break;
                        }
                      }
                  }
                  n && this._loadNext();
                } else {
                  for (var s in (this.close(), this._loadItemsById))
                    this._disposeItem(this._loadItemsById[s]);
                  this.init(this.useXHR);
                }
              }),
              (t.reset = function () {
                for (var e in (this.close(), this._loadItemsById))
                  this._disposeItem(this._loadItemsById[e]);
                for (
                  var t = [], n = 0, i = this._loadQueueBackup.length;
                  i > n;
                  n++
                )
                  t.push(this._loadQueueBackup[n].getItem());
                this.loadManifest(t, !1);
              }),
              (n.isBinary = function (e) {
                switch (e) {
                  case createjs.LoadQueue.IMAGE:
                  case createjs.LoadQueue.BINARY:
                    return !0;
                  default:
                    return !1;
                }
              }),
              (n.isText = function (e) {
                switch (e) {
                  case createjs.LoadQueue.TEXT:
                  case createjs.LoadQueue.JSON:
                  case createjs.LoadQueue.MANIFEST:
                  case createjs.LoadQueue.XML:
                  case createjs.LoadQueue.HTML:
                  case createjs.LoadQueue.CSS:
                  case createjs.LoadQueue.SVG:
                  case createjs.LoadQueue.JAVASCRIPT:
                    return !0;
                  default:
                    return !1;
                }
              }),
              (t.installPlugin = function (e) {
                if (null != e && null != e.getPreloadHandlers) {
                  var t = e.getPreloadHandlers();
                  if (((t.scope = e), null != t.types))
                    for (var n = 0, i = t.types.length; i > n; n++)
                      this._typeCallbacks[t.types[n]] = t;
                  if (null != t.extensions)
                    for (n = 0, i = t.extensions.length; i > n; n++)
                      this._extensionCallbacks[t.extensions[n]] = t;
                }
              }),
              (t.setMaxConnections = function (e) {
                (this._maxConnections = e),
                  !this._paused &&
                    this._loadQueue.length > 0 &&
                    this._loadNext();
              }),
              (t.loadFile = function (e, t, n) {
                if (null == e) {
                  var i = new createjs.Event("error");
                  return (i.text = "PRELOAD_NO_FILE"), void this._sendError(i);
                }
                this._addItem(e, null, n),
                  !1 !== t ? this.setPaused(!1) : this.setPaused(!0);
              }),
              (t.loadManifest = function (e, t, i) {
                var r = null,
                  a = null;
                if (e instanceof Array) {
                  if (0 == e.length)
                    return (
                      ((o = new createjs.Event("error")).text =
                        "PRELOAD_MANIFEST_EMPTY"),
                      void this._sendError(o)
                    );
                  r = e;
                } else if ("string" == typeof e)
                  r = [{ src: e, type: n.MANIFEST }];
                else {
                  if ("object" != typeof e)
                    return (
                      ((o = new createjs.Event("error")).text =
                        "PRELOAD_MANIFEST_NULL"),
                      void this._sendError(o)
                    );
                  if (void 0 !== e.src) {
                    if (null == e.type) e.type = n.MANIFEST;
                    else if (e.type != n.MANIFEST) {
                      var o;
                      ((o = new createjs.Event("error")).text =
                        "PRELOAD_MANIFEST_ERROR"),
                        this._sendError(o);
                    }
                    r = [e];
                  } else
                    void 0 !== e.manifest && ((r = e.manifest), (a = e.path));
                }
                for (var s = 0, c = r.length; c > s; s++)
                  this._addItem(r[s], a, i);
                !1 !== t ? this.setPaused(!1) : this.setPaused(!0);
              }),
              (t.load = function () {
                this.setPaused(!1);
              }),
              (t.getItem = function (e) {
                return this._loadItemsById[e] || this._loadItemsBySrc[e];
              }),
              (t.getResult = function (e, t) {
                var n = this._loadItemsById[e] || this._loadItemsBySrc[e];
                if (null == n) return null;
                var i = n.id;
                return t && this._loadedRawResults[i]
                  ? this._loadedRawResults[i]
                  : this._loadedResults[i];
              }),
              (t.setPaused = function (e) {
                (this._paused = e), this._paused || this._loadNext();
              }),
              (t.close = function () {
                for (; this._currentLoads.length; )
                  this._currentLoads.pop().cancel();
                (this._scriptOrder.length = 0),
                  (this._loadedScripts.length = 0),
                  (this.loadStartWasDispatched = !1);
              }),
              (t._addItem = function (e, t, n) {
                var i = this._createLoadItem(e, t, n);
                if (null != i) {
                  var r = this._createLoader(i);
                  null != r &&
                    (this._loadQueue.push(r),
                    this._loadQueueBackup.push(r),
                    this._numItems++,
                    this._updateProgress(),
                    this.maintainScriptOrder &&
                      i.type == createjs.LoadQueue.JAVASCRIPT &&
                      r instanceof createjs.XHRLoader &&
                      (this._scriptOrder.push(i),
                      this._loadedScripts.push(null)));
                }
              }),
              (t._createLoadItem = function (e, t, n) {
                var i = null;
                switch (typeof e) {
                  case "string":
                    i = { src: e };
                    break;
                  case "object":
                    i =
                      window.HTMLAudioElement &&
                      e instanceof window.HTMLAudioElement
                        ? {
                            tag: e,
                            src: i.tag.src,
                            type: createjs.LoadQueue.SOUND,
                          }
                        : e;
                    break;
                  default:
                    return null;
                }
                var r = this._parseURI(i.src);
                null != r && (i.ext = r[6]),
                  null == i.type && (i.type = this._getTypeByExtension(i.ext));
                var a = "",
                  o = n || this._basePath,
                  s = i.src;
                if (r && null == r[1] && null == r[3])
                  if (t) {
                    a = t;
                    var c = this._parsePath(t);
                    (s = t + s),
                      null != o &&
                        c &&
                        null == c[1] &&
                        null == c[2] &&
                        (a = o + a);
                  } else null != o && (a = o);
                if (
                  ((i.src = a + i.src),
                  (i.path = a),
                  (i.type == createjs.LoadQueue.JSON ||
                    i.type == createjs.LoadQueue.MANIFEST) &&
                    (i._loadAsJSONP = null != i.callback),
                  i.type == createjs.LoadQueue.JSONP && null == i.callback)
                )
                  throw new Error(
                    "callback is required for loading JSONP requests."
                  );
                (void 0 === i.tag || null === i.tag) &&
                  (i.tag = this._createTag(i)),
                  (void 0 === i.id || null === i.id || "" === i.id) &&
                    (i.id = s);
                var l =
                  this._typeCallbacks[i.type] ||
                  this._extensionCallbacks[i.ext];
                if (l) {
                  var h = l.callback.call(
                    l.scope,
                    i.src,
                    i.type,
                    i.id,
                    i.data,
                    a,
                    this
                  );
                  if (!1 === h) return null;
                  !0 === h ||
                    (null != h.src && (i.src = h.src),
                    null != h.id && (i.id = h.id),
                    null != h.tag && (i.tag = h.tag),
                    null != h.completeHandler &&
                      (i.completeHandler = h.completeHandler),
                    h.type && (i.type = h.type),
                    null != (r = this._parseURI(i.src)) &&
                      null != r[6] &&
                      (i.ext = r[6].toLowerCase()));
                }
                return (
                  (this._loadItemsById[i.id] = i),
                  (this._loadItemsBySrc[i.src] = i),
                  i
                );
              }),
              (t._createLoader = function (e) {
                var t = this.useXHR;
                switch (e.type) {
                  case createjs.LoadQueue.JSON:
                  case createjs.LoadQueue.MANIFEST:
                    t = !e._loadAsJSONP;
                    break;
                  case createjs.LoadQueue.XML:
                  case createjs.LoadQueue.TEXT:
                    t = !0;
                    break;
                  case createjs.LoadQueue.SOUND:
                  case createjs.LoadQueue.JSONP:
                    t = !1;
                    break;
                  case null:
                    return null;
                }
                return t
                  ? new createjs.XHRLoader(e, this._crossOrigin)
                  : new createjs.TagLoader(e);
              }),
              (t._loadNext = function () {
                if (!this._paused) {
                  this._loadStartWasDispatched ||
                    (this._sendLoadStart(),
                    (this._loadStartWasDispatched = !0)),
                    this._numItems == this._numItemsLoaded
                      ? ((this.loaded = !0),
                        this._sendComplete(),
                        this.next && this.next.load && this.next.load())
                      : (this.loaded = !1);
                  for (
                    var e = 0;
                    e < this._loadQueue.length &&
                    !(this._currentLoads.length >= this._maxConnections);
                    e++
                  ) {
                    var t = this._loadQueue[e];
                    if (
                      this.maintainScriptOrder &&
                      t instanceof createjs.TagLoader &&
                      t.getItem().type == createjs.LoadQueue.JAVASCRIPT
                    ) {
                      if (this._currentlyLoadingScript) continue;
                      this._currentlyLoadingScript = !0;
                    }
                    this._loadQueue.splice(e, 1), e--, this._loadItem(t);
                  }
                }
              }),
              (t._loadItem = function (e) {
                e.on("progress", this._handleProgress, this),
                  e.on("complete", this._handleFileComplete, this),
                  e.on("error", this._handleFileError, this),
                  this._currentLoads.push(e),
                  this._sendFileStart(e.getItem()),
                  e.load();
              }),
              (t._handleFileError = function (e) {
                var t = e.target;
                this._numItemsLoaded++, this._updateProgress();
                var n = new createjs.Event("error");
                (n.text = "FILE_LOAD_ERROR"),
                  (n.item = t.getItem()),
                  this._sendError(n),
                  this.stopOnError ||
                    (this._removeLoadItem(t), this._loadNext());
              }),
              (t._handleFileComplete = function (e) {
                var t = e.target,
                  n = t.getItem();
                if (
                  ((this._loadedResults[n.id] = t.getResult()),
                  t instanceof createjs.XHRLoader &&
                    (this._loadedRawResults[n.id] = t.getResult(!0)),
                  this._removeLoadItem(t),
                  this.maintainScriptOrder &&
                    n.type == createjs.LoadQueue.JAVASCRIPT)
                ) {
                  if (!(t instanceof createjs.TagLoader))
                    return (
                      (this._loadedScripts[
                        createjs.indexOf(this._scriptOrder, n)
                      ] = n),
                      void this._checkScriptLoadOrder(t)
                    );
                  this._currentlyLoadingScript = !1;
                }
                if (
                  (delete n._loadAsJSONP, n.type == createjs.LoadQueue.MANIFEST)
                ) {
                  var i = t.getResult();
                  null != i &&
                    void 0 !== i.manifest &&
                    this.loadManifest(i, !0);
                }
                this._processFinishedLoad(n, t);
              }),
              (t._processFinishedLoad = function (e, t) {
                this._numItemsLoaded++,
                  this._updateProgress(),
                  this._sendFileComplete(e, t),
                  this._loadNext();
              }),
              (t._checkScriptLoadOrder = function () {
                for (var e = this._loadedScripts.length, t = 0; e > t; t++) {
                  var n = this._loadedScripts[t];
                  if (null === n) break;
                  if (!0 !== n) {
                    var i = this._loadedResults[n.id];
                    (
                      document.body || document.getElementsByTagName("body")[0]
                    ).appendChild(i),
                      this._processFinishedLoad(n),
                      (this._loadedScripts[t] = !0);
                  }
                }
              }),
              (t._removeLoadItem = function (e) {
                for (var t = this._currentLoads.length, n = 0; t > n; n++)
                  if (this._currentLoads[n] == e) {
                    this._currentLoads.splice(n, 1);
                    break;
                  }
              }),
              (t._handleProgress = function (e) {
                var t = e.target;
                this._sendFileProgress(t.getItem(), t.progress),
                  this._updateProgress();
              }),
              (t._updateProgress = function () {
                var e = this._numItemsLoaded / this._numItems,
                  t = this._numItems - this._numItemsLoaded;
                if (t > 0) {
                  for (
                    var n = 0, i = 0, r = this._currentLoads.length;
                    r > i;
                    i++
                  )
                    n += this._currentLoads[i].progress;
                  e += (n / t) * (t / this._numItems);
                }
                this._sendProgress(e);
              }),
              (t._disposeItem = function (e) {
                delete this._loadedResults[e.id],
                  delete this._loadedRawResults[e.id],
                  delete this._loadItemsById[e.id],
                  delete this._loadItemsBySrc[e.src];
              }),
              (t._createTag = function (e) {
                var t = null;
                switch (e.type) {
                  case createjs.LoadQueue.IMAGE:
                    return (
                      (t = document.createElement("img")),
                      "" == this._crossOrigin ||
                        this._isLocal(e) ||
                        (t.crossOrigin = this._crossOrigin),
                      t
                    );
                  case createjs.LoadQueue.SOUND:
                    return (
                      ((t = document.createElement("audio")).autoplay = !1), t
                    );
                  case createjs.LoadQueue.JSON:
                  case createjs.LoadQueue.JSONP:
                  case createjs.LoadQueue.JAVASCRIPT:
                  case createjs.LoadQueue.MANIFEST:
                    return (
                      ((t = document.createElement("script")).type =
                        "text/javascript"),
                      t
                    );
                  case createjs.LoadQueue.CSS:
                    return (
                      ((t = this.useXHR
                        ? document.createElement("style")
                        : document.createElement("link")).rel = "stylesheet"),
                      (t.type = "text/css"),
                      t
                    );
                  case createjs.LoadQueue.SVG:
                    return (
                      this.useXHR
                        ? (t = document.createElement("svg"))
                        : ((t = document.createElement("object")).type =
                            "image/svg+xml"),
                      t
                    );
                }
                return null;
              }),
              (t._getTypeByExtension = function (e) {
                if (null == e) return createjs.LoadQueue.TEXT;
                switch (e.toLowerCase()) {
                  case "jpeg":
                  case "jpg":
                  case "gif":
                  case "png":
                  case "webp":
                  case "bmp":
                    return createjs.LoadQueue.IMAGE;
                  case "ogg":
                  case "mp3":
                  case "wav":
                    return createjs.LoadQueue.SOUND;
                  case "json":
                    return createjs.LoadQueue.JSON;
                  case "xml":
                    return createjs.LoadQueue.XML;
                  case "css":
                    return createjs.LoadQueue.CSS;
                  case "js":
                    return createjs.LoadQueue.JAVASCRIPT;
                  case "svg":
                    return createjs.LoadQueue.SVG;
                  default:
                    return createjs.LoadQueue.TEXT;
                }
              }),
              (t._sendFileProgress = function (e, t) {
                if (this._isCanceled()) this._cleanUp();
                else if (this.hasEventListener("fileprogress")) {
                  var n = new createjs.Event("fileprogress");
                  (n.progress = t),
                    (n.loaded = t),
                    (n.total = 1),
                    (n.item = e),
                    this.dispatchEvent(n);
                }
              }),
              (t._sendFileComplete = function (e, t) {
                if (!this._isCanceled()) {
                  var n = new createjs.Event("fileload");
                  (n.loader = t),
                    (n.item = e),
                    (n.result = this._loadedResults[e.id]),
                    (n.rawResult = this._loadedRawResults[e.id]),
                    e.completeHandler && e.completeHandler(n),
                    this.hasEventListener("fileload") && this.dispatchEvent(n);
                }
              }),
              (t._sendFileStart = function (e) {
                var t = new createjs.Event("filestart");
                (t.item = e),
                  this.hasEventListener("filestart") && this.dispatchEvent(t);
              }),
              (t.toString = function () {
                return "[PreloadJS LoadQueue]";
              }),
              (createjs.LoadQueue = e);
            var i = function () {};
            (i.init = function () {
              var e = navigator.userAgent;
              (i.isFirefox = e.indexOf("Firefox") > -1),
                (i.isOpera = null != window.opera),
                (i.isChrome = e.indexOf("Chrome") > -1),
                (i.isIOS =
                  e.indexOf("iPod") > -1 ||
                  e.indexOf("iPhone") > -1 ||
                  e.indexOf("iPad") > -1);
            }),
              i.init(),
              (createjs.LoadQueue.BrowserDetect = i);
          })(),
          (function () {
            "use strict";
            var e = function (e) {
                this.init(e);
              },
              t = (e.prototype = new createjs.AbstractLoader());
            (t._loadTimeout = null),
              (t._tagCompleteProxy = null),
              (t._isAudio = !1),
              (t._tag = null),
              (t._jsonResult = null),
              (t.init = function (e) {
                (this._item = e),
                  (this._tag = e.tag),
                  (this._isAudio =
                    window.HTMLAudioElement &&
                    e.tag instanceof window.HTMLAudioElement),
                  (this._tagCompleteProxy = createjs.proxy(
                    this._handleLoad,
                    this
                  ));
              }),
              (t.getResult = function () {
                return this._item.type == createjs.LoadQueue.JSONP ||
                  this._item.type == createjs.LoadQueue.MANIFEST
                  ? this._jsonResult
                  : this._tag;
              }),
              (t.cancel = function () {
                (this.canceled = !0), this._clean();
              }),
              (t.load = function () {
                var e = this._item,
                  t = this._tag;
                clearTimeout(this._loadTimeout);
                var n = createjs.LoadQueue.LOAD_TIMEOUT;
                0 == n && (n = createjs.LoadQueue.loadTimeout),
                  (this._loadTimeout = setTimeout(
                    createjs.proxy(this._handleTimeout, this),
                    n
                  )),
                  this._isAudio && ((t.src = null), (t.preload = "auto")),
                  (t.onerror = createjs.proxy(this._handleError, this)),
                  this._isAudio
                    ? ((t.onstalled = createjs.proxy(
                        this._handleStalled,
                        this
                      )),
                      t.addEventListener(
                        "canplaythrough",
                        this._tagCompleteProxy,
                        !1
                      ))
                    : ((t.onload = createjs.proxy(this._handleLoad, this)),
                      (t.onreadystatechange = createjs.proxy(
                        this._handleReadyStateChange,
                        this
                      )));
                var i = this.buildPath(e.src, e.values);
                switch (e.type) {
                  case createjs.LoadQueue.CSS:
                    t.href = i;
                    break;
                  case createjs.LoadQueue.SVG:
                    t.data = i;
                    break;
                  default:
                    t.src = i;
                }
                if (
                  e.type == createjs.LoadQueue.JSONP ||
                  e.type == createjs.LoadQueue.JSON ||
                  e.type == createjs.LoadQueue.MANIFEST
                ) {
                  if (null == e.callback)
                    throw new Error(
                      "callback is required for loading JSONP requests."
                    );
                  if (null != window[e.callback])
                    throw new Error(
                      'JSONP callback "' +
                        e.callback +
                        '" already exists on window. You need to specify a different callback. Or re-name the current one.'
                    );
                  window[e.callback] = createjs.proxy(
                    this._handleJSONPLoad,
                    this
                  );
                }
                (e.type == createjs.LoadQueue.SVG ||
                  e.type == createjs.LoadQueue.JSONP ||
                  e.type == createjs.LoadQueue.JSON ||
                  e.type == createjs.LoadQueue.MANIFEST ||
                  e.type == createjs.LoadQueue.JAVASCRIPT ||
                  e.type == createjs.LoadQueue.CSS) &&
                  ((this._startTagVisibility = t.style.visibility),
                  (t.style.visibility = "hidden"),
                  (
                    document.body || document.getElementsByTagName("body")[0]
                  ).appendChild(t)),
                  null != t.load && t.load();
              }),
              (t._handleJSONPLoad = function (e) {
                this._jsonResult = e;
              }),
              (t._handleTimeout = function () {
                this._clean();
                var e = new createjs.Event("error");
                (e.text = "PRELOAD_TIMEOUT"), this._sendError(e);
              }),
              (t._handleStalled = function () {}),
              (t._handleError = function () {
                this._clean();
                var e = new createjs.Event("error");
                this._sendError(e);
              }),
              (t._handleReadyStateChange = function () {
                clearTimeout(this._loadTimeout);
                var e = this.getItem().tag;
                ("loaded" == e.readyState || "complete" == e.readyState) &&
                  this._handleLoad();
              }),
              (t._handleLoad = function () {
                if (!this._isCanceled()) {
                  var e = this.getItem(),
                    t = e.tag;
                  if (!(this.loaded || (this._isAudio && 4 !== t.readyState))) {
                    switch (((this.loaded = !0), e.type)) {
                      case createjs.LoadQueue.SVG:
                      case createjs.LoadQueue.JSON:
                      case createjs.LoadQueue.JSONP:
                      case createjs.LoadQueue.MANIFEST:
                      case createjs.LoadQueue.CSS:
                        (t.style.visibility = this._startTagVisibility),
                          (
                            document.body ||
                            document.getElementsByTagName("body")[0]
                          ).removeChild(t);
                    }
                    this._clean(), this._sendComplete();
                  }
                }
              }),
              (t._clean = function () {
                clearTimeout(this._loadTimeout);
                var e,
                  t = (e = this.getItem()).tag;
                null != t &&
                  ((t.onload = null),
                  t.removeEventListener &&
                    t.removeEventListener(
                      "canplaythrough",
                      this._tagCompleteProxy,
                      !1
                    ),
                  (t.onstalled = null),
                  (t.onprogress = null),
                  (t.onerror = null),
                  null != t.parentNode &&
                    e.type == createjs.LoadQueue.SVG &&
                    e.type == createjs.LoadQueue.JSON &&
                    e.type == createjs.LoadQueue.MANIFEST &&
                    e.type == createjs.LoadQueue.CSS &&
                    e.type == createjs.LoadQueue.JSONP &&
                    t.parentNode.removeChild(t)),
                  ((e = this.getItem()).type == createjs.LoadQueue.JSONP ||
                    e.type == createjs.LoadQueue.MANIFEST) &&
                    (window[e.callback] = null);
              }),
              (t.toString = function () {
                return "[PreloadJS TagLoader]";
              }),
              (createjs.TagLoader = e);
          })(),
          (function () {
            "use strict";
            var e = function (e, t) {
                this.init(e, t);
              },
              t = (e.prototype = new createjs.AbstractLoader());
            (t._request = null),
              (t._loadTimeout = null),
              (t._xhrLevel = 1),
              (t._response = null),
              (t._rawResponse = null),
              (t._crossOrigin = ""),
              (t.init = function (e, t) {
                (this._item = e), (this._crossOrigin = t), this._createXHR(e);
              }),
              (t.getResult = function (e) {
                return e && this._rawResponse
                  ? this._rawResponse
                  : this._response;
              }),
              (t.cancel = function () {
                (this.canceled = !0), this._clean(), this._request.abort();
              }),
              (t.load = function () {
                if (null != this._request) {
                  if (
                    ((this._request.onloadstart = createjs.proxy(
                      this._handleLoadStart,
                      this
                    )),
                    (this._request.onprogress = createjs.proxy(
                      this._handleProgress,
                      this
                    )),
                    (this._request.onabort = createjs.proxy(
                      this._handleAbort,
                      this
                    )),
                    (this._request.onerror = createjs.proxy(
                      this._handleError,
                      this
                    )),
                    (this._request.ontimeout = createjs.proxy(
                      this._handleTimeout,
                      this
                    )),
                    1 == this._xhrLevel)
                  ) {
                    var e = createjs.LoadQueue.LOAD_TIMEOUT;
                    if (0 == e) e = createjs.LoadQueue.loadTimeout;
                    else
                      try {
                        console.warn(
                          "LoadQueue.LOAD_TIMEOUT has been deprecated in favor of LoadQueue.loadTimeout"
                        );
                      } catch (e) {}
                    this._loadTimeout = setTimeout(
                      createjs.proxy(this._handleTimeout, this),
                      e
                    );
                  }
                  (this._request.onload = createjs.proxy(
                    this._handleLoad,
                    this
                  )),
                    (this._request.onreadystatechange = createjs.proxy(
                      this._handleReadyStateChange,
                      this
                    ));
                  try {
                    this._item.values &&
                    this._item.method != createjs.LoadQueue.GET
                      ? this._item.method == createjs.LoadQueue.POST &&
                        this._request.send(
                          this._formatQueryString(this._item.values)
                        )
                      : this._request.send();
                  } catch (e) {
                    var t = new createjs.Event("error");
                    (t.error = e), this._sendError(t);
                  }
                } else this._handleError();
              }),
              (t.getAllResponseHeaders = function () {
                return this._request.getAllResponseHeaders instanceof Function
                  ? this._request.getAllResponseHeaders()
                  : null;
              }),
              (t.getResponseHeader = function (e) {
                return this._request.getResponseHeader instanceof Function
                  ? this._request.getResponseHeader(e)
                  : null;
              }),
              (t._handleProgress = function (e) {
                if (e && !(e.loaded > 0 && 0 == e.total)) {
                  var t = new createjs.Event("progress");
                  (t.loaded = e.loaded),
                    (t.total = e.total),
                    this._sendProgress(t);
                }
              }),
              (t._handleLoadStart = function () {
                clearTimeout(this._loadTimeout), this._sendLoadStart();
              }),
              (t._handleAbort = function () {
                this._clean();
                var e = new createjs.Event("error");
                (e.text = "XHR_ABORTED"), this._sendError(e);
              }),
              (t._handleError = function () {
                this._clean();
                var e = new createjs.Event("error");
                this._sendError(e);
              }),
              (t._handleReadyStateChange = function () {
                4 == this._request.readyState && this._handleLoad();
              }),
              (t._handleLoad = function () {
                if (!this.loaded) {
                  if (((this.loaded = !0), !this._checkError()))
                    return void this._handleError();
                  (this._response = this._getResponse()),
                    this._clean(),
                    this._generateTag() && this._sendComplete();
                }
              }),
              (t._handleTimeout = function (e) {
                this._clean(),
                  (new createjs.Event("error").text = "PRELOAD_TIMEOUT"),
                  this._sendError(e);
              }),
              (t._checkError = function () {
                switch (parseInt(this._request.status)) {
                  case 404:
                  case 0:
                    return !1;
                }
                return !0;
              }),
              (t._getResponse = function () {
                if (null != this._response) return this._response;
                if (null != this._request.response)
                  return this._request.response;
                try {
                  if (null != this._request.responseText)
                    return this._request.responseText;
                } catch (e) {}
                try {
                  if (null != this._request.responseXML)
                    return this._request.responseXML;
                } catch (e) {}
                return null;
              }),
              (t._createXHR = function (e) {
                var t,
                  n = this._isCrossDomain(e),
                  i = null;
                if (n && window.XDomainRequest) i = new XDomainRequest();
                else if (window.XMLHttpRequest) i = new XMLHttpRequest();
                else
                  try {
                    i = new ActiveXObject("Msxml2.XMLHTTP.6.0");
                  } catch (e) {
                    try {
                      i = new ActiveXObject("Msxml2.XMLHTTP.3.0");
                    } catch (e) {
                      try {
                        i = new ActiveXObject("Msxml2.XMLHTTP");
                      } catch (e) {
                        return !1;
                      }
                    }
                  }
                return (
                  createjs.LoadQueue.isText(e.type) &&
                    i.overrideMimeType &&
                    i.overrideMimeType("text/plain; charset=utf-8"),
                  (this._xhrLevel = "string" == typeof i.responseType ? 2 : 1),
                  (t =
                    e.method == createjs.LoadQueue.GET
                      ? this.buildPath(e.src, e.values)
                      : e.src),
                  i.open(e.method || createjs.LoadQueue.GET, t, !0),
                  n &&
                    i instanceof XMLHttpRequest &&
                    1 == this._xhrLevel &&
                    i.setRequestHeader("Origin", location.origin),
                  e.values &&
                    e.method == createjs.LoadQueue.POST &&
                    i.setRequestHeader(
                      "Content-Type",
                      "application/x-www-form-urlencoded"
                    ),
                  createjs.LoadQueue.isBinary(e.type) &&
                    (i.responseType = "arraybuffer"),
                  (this._request = i),
                  !0
                );
              }),
              (t._clean = function () {
                clearTimeout(this._loadTimeout);
                var e = this._request;
                (e.onloadstart = null),
                  (e.onprogress = null),
                  (e.onabort = null),
                  (e.onerror = null),
                  (e.onload = null),
                  (e.ontimeout = null),
                  (e.onloadend = null),
                  (e.onreadystatechange = null);
              }),
              (t._generateTag = function () {
                var e = this._item.type,
                  t = this._item.tag;
                switch (e) {
                  case createjs.LoadQueue.IMAGE:
                    return (
                      (t.onload = createjs.proxy(this._handleTagReady, this)),
                      "" != this._crossOrigin && (t.crossOrigin = "Anonymous"),
                      (t.src = this.buildPath(
                        this._item.src,
                        this._item.values
                      )),
                      (this._rawResponse = this._response),
                      (this._response = t),
                      !1
                    );
                  case createjs.LoadQueue.JAVASCRIPT:
                    return (
                      ((t = document.createElement("script")).text =
                        this._response),
                      (this._rawResponse = this._response),
                      (this._response = t),
                      !0
                    );
                  case createjs.LoadQueue.CSS:
                    if (
                      (document.getElementsByTagName("head")[0].appendChild(t),
                      t.styleSheet)
                    )
                      t.styleSheet.cssText = this._response;
                    else {
                      var n = document.createTextNode(this._response);
                      t.appendChild(n);
                    }
                    return (
                      (this._rawResponse = this._response),
                      (this._response = t),
                      !0
                    );
                  case createjs.LoadQueue.XML:
                    var i = this._parseXML(this._response, "text/xml");
                    return (
                      (this._rawResponse = this._response),
                      (this._response = i),
                      !0
                    );
                  case createjs.LoadQueue.SVG:
                    return (
                      (i = this._parseXML(this._response, "image/svg+xml")),
                      (this._rawResponse = this._response),
                      null != i.documentElement
                        ? (t.appendChild(i.documentElement),
                          (this._response = t))
                        : (this._response = i),
                      !0
                    );
                  case createjs.LoadQueue.JSON:
                  case createjs.LoadQueue.MANIFEST:
                    var r = {};
                    try {
                      r = JSON.parse(this._response);
                    } catch (e) {
                      r = e;
                    }
                    return (
                      (this._rawResponse = this._response),
                      (this._response = r),
                      !0
                    );
                }
                return !0;
              }),
              (t._parseXML = function (e, t) {
                var n = null;
                try {
                  window.DOMParser
                    ? (n = new DOMParser().parseFromString(e, t))
                    : (((n = new ActiveXObject("Microsoft.XMLDOM")).async = !1),
                      n.loadXML(e));
                } catch (e) {}
                return n;
              }),
              (t._handleTagReady = function () {
                this._sendComplete();
              }),
              (t.toString = function () {
                return "[PreloadJS XHRLoader]";
              }),
              (createjs.XHRLoader = e);
          })(),
          "object" != typeof JSON && (JSON = {}),
          (function () {
            "use strict";
            function f(e) {
              return 10 > e ? "0" + e : e;
            }
            function quote(e) {
              return (
                (escapable.lastIndex = 0),
                escapable.test(e)
                  ? '"' +
                    e.replace(escapable, function (e) {
                      var t = meta[e];
                      return "string" == typeof t
                        ? t
                        : "\\u" +
                            ("0000" + e.charCodeAt(0).toString(16)).slice(-4);
                    }) +
                    '"'
                  : '"' + e + '"'
              );
            }
            function str(e, t) {
              var n,
                i,
                r,
                a,
                o,
                s = gap,
                c = t[e];
              switch (
                (c &&
                  "object" == typeof c &&
                  "function" == typeof c.toJSON &&
                  (c = c.toJSON(e)),
                "function" == typeof rep && (c = rep.call(t, e, c)),
                typeof c)
              ) {
                case "string":
                  return quote(c);
                case "number":
                  return isFinite(c) ? String(c) : "null";
                case "boolean":
                case "null":
                  return String(c);
                case "object":
                  if (!c) return "null";
                  if (
                    ((gap += indent),
                    (o = []),
                    "[object Array]" === Object.prototype.toString.apply(c))
                  ) {
                    for (a = c.length, n = 0; a > n; n += 1)
                      o[n] = str(n, c) || "null";
                    return (
                      (r =
                        0 === o.length
                          ? "[]"
                          : gap
                          ? "[\n" + gap + o.join(",\n" + gap) + "\n" + s + "]"
                          : "[" + o.join(",") + "]"),
                      (gap = s),
                      r
                    );
                  }
                  if (rep && "object" == typeof rep)
                    for (a = rep.length, n = 0; a > n; n += 1)
                      "string" == typeof rep[n] &&
                        (r = str((i = rep[n]), c)) &&
                        o.push(quote(i) + (gap ? ": " : ":") + r);
                  else
                    for (i in c)
                      Object.prototype.hasOwnProperty.call(c, i) &&
                        (r = str(i, c)) &&
                        o.push(quote(i) + (gap ? ": " : ":") + r);
                  return (
                    (r =
                      0 === o.length
                        ? "{}"
                        : gap
                        ? "{\n" + gap + o.join(",\n" + gap) + "\n" + s + "}"
                        : "{" + o.join(",") + "}"),
                    (gap = s),
                    r
                  );
              }
            }
            "function" != typeof Date.prototype.toJSON &&
              ((Date.prototype.toJSON = function () {
                return isFinite(this.valueOf())
                  ? this.getUTCFullYear() +
                      "-" +
                      f(this.getUTCMonth() + 1) +
                      "-" +
                      f(this.getUTCDate()) +
                      "T" +
                      f(this.getUTCHours()) +
                      ":" +
                      f(this.getUTCMinutes()) +
                      ":" +
                      f(this.getUTCSeconds()) +
                      "Z"
                  : null;
              }),
              (String.prototype.toJSON =
                Number.prototype.toJSON =
                Boolean.prototype.toJSON =
                  function () {
                    return this.valueOf();
                  }));
            var cx =
                /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
              escapable =
                /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
              gap,
              indent,
              meta = {
                "\b": "\\b",
                "\t": "\\t",
                "\n": "\\n",
                "\f": "\\f",
                "\r": "\\r",
                '"': '\\"',
                "\\": "\\\\",
              },
              rep;
            "function" != typeof JSON.stringify &&
              (JSON.stringify = function (e, t, n) {
                var i;
                if (((gap = ""), (indent = ""), "number" == typeof n))
                  for (i = 0; n > i; i += 1) indent += " ";
                else "string" == typeof n && (indent = n);
                if (
                  ((rep = t),
                  t &&
                    "function" != typeof t &&
                    ("object" != typeof t || "number" != typeof t.length))
                )
                  throw new Error("JSON.stringify");
                return str("", { "": e });
              }),
              "function" != typeof JSON.parse &&
                (JSON.parse = function (text, reviver) {
                  function walk(e, t) {
                    var n,
                      i,
                      r = e[t];
                    if (r && "object" == typeof r)
                      for (n in r)
                        Object.prototype.hasOwnProperty.call(r, n) &&
                          (void 0 !== (i = walk(r, n))
                            ? (r[n] = i)
                            : delete r[n]);
                    return reviver.call(e, t, r);
                  }
                  var j;
                  if (
                    ((text = String(text)),
                    (cx.lastIndex = 0),
                    cx.test(text) &&
                      (text = text.replace(cx, function (e) {
                        return (
                          "\\u" +
                          ("0000" + e.charCodeAt(0).toString(16)).slice(-4)
                        );
                      })),
                    /^[\],:{}\s]*$/.test(
                      text
                        .replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@")
                        .replace(
                          /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
                          "]"
                        )
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, "")
                    ))
                  )
                    return (
                      (j = eval("(" + text + ")")),
                      "function" == typeof reviver ? walk({ "": j }, "") : j
                    );
                  throw new SyntaxError("JSON.parse");
                });
          })(),
          (module.exports = window.createjs);
      },
      41: function (e) {
        e.exports = (function () {
          "use strict";
          var e = document,
            t = e.createTextNode.bind(e);
          function n(e, t, n) {
            e.style.setProperty(t, n);
          }
          function i(e, t) {
            return e.appendChild(t);
          }
          function r(t, n, r, a) {
            var o = e.createElement("span");
            return (
              n && (o.className = n),
              r && (!a && o.setAttribute("data-" + n, r), (o.textContent = r)),
              (t && i(t, o)) || o
            );
          }
          function a(e, t) {
            return e.getAttribute("data-" + t);
          }
          function o(t, n) {
            return t && 0 != t.length
              ? t.nodeName
                ? [t]
                : [].slice.call(
                    t[0].nodeName ? t : (n || e).querySelectorAll(t)
                  )
              : [];
          }
          function s(e) {
            for (var t = []; e--; ) t[e] = [];
            return t;
          }
          function c(e, t) {
            e && e.some(t);
          }
          function l(e) {
            return function (t) {
              return e[t];
            };
          }
          var h = {};
          function u(e, t, n) {
            var i = n.indexOf(e);
            if (-1 == i)
              n.unshift(e),
                c(h[e].depends, function (t) {
                  u(t, e, n);
                });
            else {
              var r = n.indexOf(t);
              n.splice(i, 1), n.splice(r, 0, e);
            }
            return n;
          }
          function p(e, t, n, i) {
            return { by: e, depends: t, key: n, split: i };
          }
          function d(e) {
            return u(e, 0, []).map(l(h));
          }
          function f(e) {
            h[e.by] = e;
          }
          function m(e, n, a, s, l) {
            e.normalize();
            var h = [],
              u = document.createDocumentFragment();
            s && h.push(e.previousSibling);
            var p = [];
            return (
              o(e.childNodes).some(function (e) {
                if (!e.tagName || e.hasChildNodes()) {
                  if (e.childNodes && e.childNodes.length)
                    return p.push(e), void h.push.apply(h, m(e, n, a, s, l));
                  var i = e.wholeText || "",
                    o = i.trim();
                  o.length &&
                    (" " === i[0] && p.push(t(" ")),
                    c(o.split(a), function (e, t) {
                      t && l && p.push(r(u, "whitespace", " ", l));
                      var i = r(u, n, e);
                      h.push(i), p.push(i);
                    }),
                    " " === i[i.length - 1] && p.push(t(" ")));
                } else p.push(e);
              }),
              c(p, function (e) {
                i(u, e);
              }),
              (e.innerHTML = ""),
              i(e, u),
              h
            );
          }
          var g = "words",
            v = p(g, 0, "word", function (e) {
              return m(e, "word", /\s+/, 0, 1);
            }),
            y = "chars",
            _ = p(y, [g], "char", function (e, t, n) {
              var i = [];
              return (
                c(n.words, function (e, n) {
                  i.push.apply(i, m(e, "char", "", t.whitespace && n));
                }),
                i
              );
            });
          function w(e) {
            var t = (e = e || {}).key;
            return o(e.target || "[data-splitting]").map(function (i) {
              var r = i[""];
              if (!e.force && r) return r;
              r = i[""] = { el: i };
              var o = d(e.by || a(i, "splitting") || y),
                s = (function (e, t) {
                  for (var n in t) e[n] = t[n];
                  return e;
                })({}, e);
              return (
                c(o, function (e) {
                  if (e.split) {
                    var a = e.by,
                      o = (t ? "-" + t : "") + e.key,
                      l = e.split(i, s, r);
                    o &&
                      (function (e, t, i) {
                        var r = "--" + t,
                          a = r + "-index";
                        c(i, function (e, t) {
                          Array.isArray(e)
                            ? c(e, function (e) {
                                n(e, a, t);
                              })
                            : n(e, a, t);
                        }),
                          n(e, r + "-total", i.length);
                      })(i, o, l),
                      (r[a] = l),
                      i.classList.add(a);
                  }
                }),
                i.classList.add("splitting"),
                r
              );
            });
          }
          function x(e, t, n) {
            var i = o(t.matching || e.children, e),
              r = {};
            return (
              c(i, function (e) {
                var t = Math.round(e[n]);
                (r[t] || (r[t] = [])).push(e);
              }),
              Object.keys(r).map(Number).sort(b).map(l(r))
            );
          }
          function b(e, t) {
            return e - t;
          }
          (w.html = function (e) {
            var t = ((e = e || {}).target = r());
            return (t.innerHTML = e.content), w(e), t.outerHTML;
          }),
            (w.add = f);
          var M = p("lines", [g], "line", function (e, t, n) {
              return x(e, { matching: n.words }, "offsetTop");
            }),
            S = p("items", 0, "item", function (e, t) {
              return o(t.matching || e.children, e);
            }),
            T = p("rows", 0, "row", function (e, t) {
              return x(e, t, "offsetTop");
            }),
            E = p("cols", 0, "col", function (e, t) {
              return x(e, t, "offsetLeft");
            }),
            A = p("grid", ["rows", "cols"]),
            L = "layout",
            P = p(L, 0, 0, function (e, t) {
              var s = (t.rows = +(t.rows || a(e, "rows") || 1)),
                c = (t.columns = +(t.columns || a(e, "columns") || 1));
              if (
                ((t.image = t.image || a(e, "image") || e.currentSrc || e.src),
                t.image)
              ) {
                var l = o("img", e)[0];
                t.image = l && (l.currentSrc || l.src);
              }
              t.image && n(e, "background-image", "url(" + t.image + ")");
              for (var h = s * c, u = [], p = r(0, "cell-grid"); h--; ) {
                var d = r(p, "cell");
                r(d, "cell-inner"), u.push(d);
              }
              return i(e, p), u;
            }),
            R = p("cellRows", [L], "row", function (e, t, n) {
              var i = t.rows,
                r = s(i);
              return (
                c(n.layout, function (e, t, n) {
                  r[Math.floor(t / (n.length / i))].push(e);
                }),
                r
              );
            }),
            k = p("cellColumns", [L], "col", function (e, t, n) {
              var i = t.columns,
                r = s(i);
              return (
                c(n.layout, function (e, t) {
                  r[t % i].push(e);
                }),
                r
              );
            }),
            C = p(
              "cells",
              ["cellRows", "cellColumns"],
              "cell",
              function (e, t, n) {
                return n.layout;
              }
            );
          return (
            f(v), f(_), f(M), f(S), f(T), f(E), f(A), f(P), f(R), f(k), f(C), w
          );
        })();
      },
    },
    __webpack_module_cache__ = {};
  function __webpack_require__(e) {
    if (__webpack_module_cache__[e]) return __webpack_module_cache__[e].exports;
    var t = (__webpack_module_cache__[e] = { exports: {} });
    return (
      __webpack_modules__[e].call(t.exports, t, t.exports, __webpack_require__),
      t.exports
    );
  }
  (__webpack_require__.n = (e) => {
    var t = e && e.__esModule ? () => e.default : () => e;
    return __webpack_require__.d(t, { a: t }), t;
  }),
    (__webpack_require__.d = (e, t) => {
      for (var n in t)
        __webpack_require__.o(t, n) &&
          !__webpack_require__.o(e, n) &&
          Object.defineProperty(e, n, { enumerable: !0, get: t[n] });
    }),
    (__webpack_require__.g = (function () {
      if ("object" == typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (e) {
        if ("object" == typeof window) return window;
      }
    })()),
    (__webpack_require__.o = (e, t) =>
      Object.prototype.hasOwnProperty.call(e, t)),
    (() => {
      "use strict";
      const e = 100,
        t = 1e3,
        n = 1001,
        i = 1002,
        r = 1003,
        a = 1004,
        o = 1005,
        s = 1006,
        c = 1008,
        l = 1012,
        h = 1014,
        u = 1015,
        p = 1016,
        d = 1020,
        f = 1022,
        m = 1023,
        g = 1026,
        v = 1027,
        y = 2300,
        _ = 2301,
        w = 2302,
        x = 2400,
        b = 2401,
        M = 2402,
        S = 3e3,
        T = 3001,
        E = 7680,
        A = 35044,
        L = 35048,
        P = "300 es";
      function R() {}
      Object.assign(R.prototype, {
        addEventListener: function (e, t) {
          void 0 === this._listeners && (this._listeners = {});
          const n = this._listeners;
          void 0 === n[e] && (n[e] = []),
            -1 === n[e].indexOf(t) && n[e].push(t);
        },
        hasEventListener: function (e, t) {
          if (void 0 === this._listeners) return !1;
          const n = this._listeners;
          return void 0 !== n[e] && -1 !== n[e].indexOf(t);
        },
        removeEventListener: function (e, t) {
          if (void 0 === this._listeners) return;
          const n = this._listeners[e];
          if (void 0 !== n) {
            const e = n.indexOf(t);
            -1 !== e && n.splice(e, 1);
          }
        },
        dispatchEvent: function (e) {
          if (void 0 === this._listeners) return;
          const t = this._listeners[e.type];
          if (void 0 !== t) {
            e.target = this;
            const n = t.slice(0);
            for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
          }
        },
      });
      const k = [];
      for (let e = 0; e < 256; e++) k[e] = (e < 16 ? "0" : "") + e.toString(16);
      let C = 1234567;
      const O = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function () {
          const e = (4294967295 * Math.random()) | 0,
            t = (4294967295 * Math.random()) | 0,
            n = (4294967295 * Math.random()) | 0,
            i = (4294967295 * Math.random()) | 0;
          return (
            k[255 & e] +
            k[(e >> 8) & 255] +
            k[(e >> 16) & 255] +
            k[(e >> 24) & 255] +
            "-" +
            k[255 & t] +
            k[(t >> 8) & 255] +
            "-" +
            k[((t >> 16) & 15) | 64] +
            k[(t >> 24) & 255] +
            "-" +
            k[(63 & n) | 128] +
            k[(n >> 8) & 255] +
            "-" +
            k[(n >> 16) & 255] +
            k[(n >> 24) & 255] +
            k[255 & i] +
            k[(i >> 8) & 255] +
            k[(i >> 16) & 255] +
            k[(i >> 24) & 255]
          ).toUpperCase();
        },
        clamp: function (e, t, n) {
          return Math.max(t, Math.min(n, e));
        },
        euclideanModulo: function (e, t) {
          return ((e % t) + t) % t;
        },
        mapLinear: function (e, t, n, i, r) {
          return i + ((e - t) * (r - i)) / (n - t);
        },
        lerp: function (e, t, n) {
          return (1 - n) * e + n * t;
        },
        damp: function (e, t, n, i) {
          return O.lerp(e, t, 1 - Math.exp(-n * i));
        },
        pingpong: function (e, t = 1) {
          return t - Math.abs(O.euclideanModulo(e, 2 * t) - t);
        },
        smoothstep: function (e, t, n) {
          return e <= t
            ? 0
            : e >= n
            ? 1
            : (e = (e - t) / (n - t)) * e * (3 - 2 * e);
        },
        smootherstep: function (e, t, n) {
          return e <= t
            ? 0
            : e >= n
            ? 1
            : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10);
        },
        randInt: function (e, t) {
          return e + Math.floor(Math.random() * (t - e + 1));
        },
        randFloat: function (e, t) {
          return e + Math.random() * (t - e);
        },
        randFloatSpread: function (e) {
          return e * (0.5 - Math.random());
        },
        seededRandom: function (e) {
          return (
            void 0 !== e && (C = e % 2147483647),
            (C = (16807 * C) % 2147483647),
            (C - 1) / 2147483646
          );
        },
        degToRad: function (e) {
          return e * O.DEG2RAD;
        },
        radToDeg: function (e) {
          return e * O.RAD2DEG;
        },
        isPowerOfTwo: function (e) {
          return 0 == (e & (e - 1)) && 0 !== e;
        },
        ceilPowerOfTwo: function (e) {
          return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
        },
        floorPowerOfTwo: function (e) {
          return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
        },
        setQuaternionFromProperEuler: function (e, t, n, i, r) {
          const a = Math.cos,
            o = Math.sin,
            s = a(n / 2),
            c = o(n / 2),
            l = a((t + i) / 2),
            h = o((t + i) / 2),
            u = a((t - i) / 2),
            p = o((t - i) / 2),
            d = a((i - t) / 2),
            f = o((i - t) / 2);
          switch (r) {
            case "XYX":
              e.set(s * h, c * u, c * p, s * l);
              break;
            case "YZY":
              e.set(c * p, s * h, c * u, s * l);
              break;
            case "ZXZ":
              e.set(c * u, c * p, s * h, s * l);
              break;
            case "XZX":
              e.set(s * h, c * f, c * d, s * l);
              break;
            case "YXY":
              e.set(c * d, s * h, c * f, s * l);
              break;
            case "ZYZ":
              e.set(c * f, c * d, s * h, s * l);
              break;
            default:
              console.warn(
                "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                  r
              );
          }
        },
      };
      class N {
        constructor(e = 0, t = 0) {
          Object.defineProperty(this, "isVector2", { value: !0 }),
            (this.x = e),
            (this.y = t);
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), this;
        }
        add(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = e.elements;
          return (
            (this.x = i[0] * t + i[3] * n + i[6]),
            (this.y = i[1] * t + i[4] * n + i[7]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y;
          return t * t + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            this
          );
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            this
          );
        }
        rotateAround(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = this.x - e.x,
            a = this.y - e.y;
          return (
            (this.x = r * n - a * i + e.x), (this.y = r * i + a * n + e.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
      }
      class I {
        constructor() {
          Object.defineProperty(this, "isMatrix3", { value: !0 }),
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, a, o, s, c) {
          const l = this.elements;
          return (
            (l[0] = e),
            (l[1] = i),
            (l[2] = o),
            (l[3] = t),
            (l[4] = r),
            (l[5] = s),
            (l[6] = n),
            (l[7] = a),
            (l[8] = c),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            a = n[0],
            o = n[3],
            s = n[6],
            c = n[1],
            l = n[4],
            h = n[7],
            u = n[2],
            p = n[5],
            d = n[8],
            f = i[0],
            m = i[3],
            g = i[6],
            v = i[1],
            y = i[4],
            _ = i[7],
            w = i[2],
            x = i[5],
            b = i[8];
          return (
            (r[0] = a * f + o * v + s * w),
            (r[3] = a * m + o * y + s * x),
            (r[6] = a * g + o * _ + s * b),
            (r[1] = c * f + l * v + h * w),
            (r[4] = c * m + l * y + h * x),
            (r[7] = c * g + l * _ + h * b),
            (r[2] = u * f + p * v + d * w),
            (r[5] = u * m + p * y + d * x),
            (r[8] = u * g + p * _ + d * b),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            a = e[4],
            o = e[5],
            s = e[6],
            c = e[7],
            l = e[8];
          return (
            t * a * l -
            t * o * c -
            n * r * l +
            n * o * s +
            i * r * c -
            i * a * s
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            a = e[4],
            o = e[5],
            s = e[6],
            c = e[7],
            l = e[8],
            h = l * a - o * c,
            u = o * s - l * r,
            p = c * r - a * s,
            d = t * h + n * u + i * p;
          if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const f = 1 / d;
          return (
            (e[0] = h * f),
            (e[1] = (i * c - l * n) * f),
            (e[2] = (o * n - i * a) * f),
            (e[3] = u * f),
            (e[4] = (l * t - i * s) * f),
            (e[5] = (i * r - o * t) * f),
            (e[6] = p * f),
            (e[7] = (n * s - c * t) * f),
            (e[8] = (a * t - n * r) * f),
            this
          );
        }
        transpose() {
          let e;
          const t = this.elements;
          return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
          );
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).copy(this).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
          );
        }
        setUvTransform(e, t, n, i, r, a, o) {
          const s = Math.cos(r),
            c = Math.sin(r);
          return (
            this.set(
              n * s,
              n * c,
              -n * (s * a + c * o) + a + e,
              -i * c,
              i * s,
              -i * (-c * a + s * o) + o + t,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(e, t) {
          const n = this.elements;
          return (
            (n[0] *= e),
            (n[3] *= e),
            (n[6] *= e),
            (n[1] *= t),
            (n[4] *= t),
            (n[7] *= t),
            this
          );
        }
        rotate(e) {
          const t = Math.cos(e),
            n = Math.sin(e),
            i = this.elements,
            r = i[0],
            a = i[3],
            o = i[6],
            s = i[1],
            c = i[4],
            l = i[7];
          return (
            (i[0] = t * r + n * s),
            (i[3] = t * a + n * c),
            (i[6] = t * o + n * l),
            (i[1] = -n * r + t * s),
            (i[4] = -n * a + t * c),
            (i[7] = -n * o + t * l),
            this
          );
        }
        translate(e, t) {
          const n = this.elements;
          return (
            (n[0] += e * n[2]),
            (n[3] += e * n[5]),
            (n[6] += e * n[8]),
            (n[1] += t * n[2]),
            (n[4] += t * n[5]),
            (n[7] += t * n[8]),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let e = 0; e < 9; e++) if (t[e] !== n[e]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            e
          );
        }
      }
      let D;
      const j = {
        getDataURL: function (e) {
          if (/^data:/i.test(e.src)) return e.src;
          if ("undefined" == typeof HTMLCanvasElement) return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            void 0 === D &&
              (D = document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              )),
              (D.width = e.width),
              (D.height = e.height);
            const n = D.getContext("2d");
            e instanceof ImageData
              ? n.putImageData(e, 0, 0)
              : n.drawImage(e, 0, 0, e.width, e.height),
              (t = D);
          }
          return t.width > 2048 || t.height > 2048
            ? t.toDataURL("image/jpeg", 0.6)
            : t.toDataURL("image/png");
        },
      };
      let F = 0;
      function H(
        e = H.DEFAULT_IMAGE,
        t = H.DEFAULT_MAPPING,
        n = 1001,
        i = 1001,
        r = 1006,
        a = 1008,
        o = 1023,
        s = 1009,
        c = 1,
        l = 3e3
      ) {
        Object.defineProperty(this, "id", { value: F++ }),
          (this.uuid = O.generateUUID()),
          (this.name = ""),
          (this.image = e),
          (this.mipmaps = []),
          (this.mapping = t),
          (this.wrapS = n),
          (this.wrapT = i),
          (this.magFilter = r),
          (this.minFilter = a),
          (this.anisotropy = c),
          (this.format = o),
          (this.internalFormat = null),
          (this.type = s),
          (this.offset = new N(0, 0)),
          (this.repeat = new N(1, 1)),
          (this.center = new N(0, 0)),
          (this.rotation = 0),
          (this.matrixAutoUpdate = !0),
          (this.matrix = new I()),
          (this.generateMipmaps = !0),
          (this.premultiplyAlpha = !1),
          (this.flipY = !0),
          (this.unpackAlignment = 4),
          (this.encoding = l),
          (this.version = 0),
          (this.onUpdate = null);
      }
      function B(e) {
        return ("undefined" != typeof HTMLImageElement &&
          e instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            e instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
          ? j.getDataURL(e)
          : e.data
          ? {
              data: Array.prototype.slice.call(e.data),
              width: e.width,
              height: e.height,
              type: e.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      (H.DEFAULT_IMAGE = void 0),
        (H.DEFAULT_MAPPING = 300),
        (H.prototype = Object.assign(Object.create(R.prototype), {
          constructor: H,
          isTexture: !0,
          updateMatrix: function () {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return (
              (this.name = e.name),
              (this.image = e.image),
              (this.mipmaps = e.mipmaps.slice(0)),
              (this.mapping = e.mapping),
              (this.wrapS = e.wrapS),
              (this.wrapT = e.wrapT),
              (this.magFilter = e.magFilter),
              (this.minFilter = e.minFilter),
              (this.anisotropy = e.anisotropy),
              (this.format = e.format),
              (this.internalFormat = e.internalFormat),
              (this.type = e.type),
              this.offset.copy(e.offset),
              this.repeat.copy(e.repeat),
              this.center.copy(e.center),
              (this.rotation = e.rotation),
              (this.matrixAutoUpdate = e.matrixAutoUpdate),
              this.matrix.copy(e.matrix),
              (this.generateMipmaps = e.generateMipmaps),
              (this.premultiplyAlpha = e.premultiplyAlpha),
              (this.flipY = e.flipY),
              (this.unpackAlignment = e.unpackAlignment),
              (this.encoding = e.encoding),
              this
            );
          },
          toJSON: function (e) {
            const t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid])
              return e.textures[this.uuid];
            const n = {
              metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON",
              },
              uuid: this.uuid,
              name: this.name,
              mapping: this.mapping,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              type: this.type,
              encoding: this.encoding,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment,
            };
            if (void 0 !== this.image) {
              const i = this.image;
              if (
                (void 0 === i.uuid && (i.uuid = O.generateUUID()),
                !t && void 0 === e.images[i.uuid])
              ) {
                let t;
                if (Array.isArray(i)) {
                  t = [];
                  for (let e = 0, n = i.length; e < n; e++)
                    i[e].isDataTexture
                      ? t.push(B(i[e].image))
                      : t.push(B(i[e]));
                } else t = B(i);
                e.images[i.uuid] = { uuid: i.uuid, url: t };
              }
              n.image = i.uuid;
            }
            return t || (e.textures[this.uuid] = n), n;
          },
          dispose: function () {
            this.dispatchEvent({ type: "dispose" });
          },
          transformUv: function (e) {
            if (300 !== this.mapping) return e;
            if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
              switch (this.wrapS) {
                case t:
                  e.x = e.x - Math.floor(e.x);
                  break;
                case n:
                  e.x = e.x < 0 ? 0 : 1;
                  break;
                case i:
                  1 === Math.abs(Math.floor(e.x) % 2)
                    ? (e.x = Math.ceil(e.x) - e.x)
                    : (e.x = e.x - Math.floor(e.x));
              }
            if (e.y < 0 || e.y > 1)
              switch (this.wrapT) {
                case t:
                  e.y = e.y - Math.floor(e.y);
                  break;
                case n:
                  e.y = e.y < 0 ? 0 : 1;
                  break;
                case i:
                  1 === Math.abs(Math.floor(e.y) % 2)
                    ? (e.y = Math.ceil(e.y) - e.y)
                    : (e.y = e.y - Math.floor(e.y));
              }
            return this.flipY && (e.y = 1 - e.y), e;
          },
        })),
        Object.defineProperty(H.prototype, "needsUpdate", {
          set: function (e) {
            !0 === e && this.version++;
          },
        });
      class z {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          Object.defineProperty(this, "isVector4", { value: !0 }),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            (this.w = i);
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, n, i) {
          return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setW(e) {
          return (this.w = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = void 0 !== e.w ? e.w : 1),
            this
          );
        }
        add(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x),
              (this.y += e.y),
              (this.z += e.z),
              (this.w += e.w),
              this);
        }
        addScalar(e) {
          return (
            (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
          );
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
          );
        }
        sub(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x),
              (this.y -= e.y),
              (this.z -= e.z),
              (this.w -= e.w),
              this);
        }
        subScalar(e) {
          return (
            (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
          );
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
          );
        }
        multiply(e) {
          return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
          );
        }
        multiplyScalar(e) {
          return (
            (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
          );
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            a = e.elements;
          return (
            (this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r),
            (this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r),
            (this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r),
            (this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r),
            this
          );
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return (
            t < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, n, i, r;
          const a = 0.01,
            o = 0.1,
            s = e.elements,
            c = s[0],
            l = s[4],
            h = s[8],
            u = s[1],
            p = s[5],
            d = s[9],
            f = s[2],
            m = s[6],
            g = s[10];
          if (
            Math.abs(l - u) < a &&
            Math.abs(h - f) < a &&
            Math.abs(d - m) < a
          ) {
            if (
              Math.abs(l + u) < o &&
              Math.abs(h + f) < o &&
              Math.abs(d + m) < o &&
              Math.abs(c + p + g - 3) < o
            )
              return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const e = (c + 1) / 2,
              s = (p + 1) / 2,
              v = (g + 1) / 2,
              y = (l + u) / 4,
              _ = (h + f) / 4,
              w = (d + m) / 4;
            return (
              e > s && e > v
                ? e < a
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(e)), (i = y / n), (r = _ / n))
                : s > v
                ? s < a
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(s)), (n = y / i), (r = w / i))
                : v < a
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(v)), (n = _ / r), (i = w / r)),
              this.set(n, i, r, t),
              this
            );
          }
          let v = Math.sqrt(
            (m - d) * (m - d) + (h - f) * (h - f) + (u - l) * (u - l)
          );
          return (
            Math.abs(v) < 0.001 && (v = 1),
            (this.x = (m - d) / v),
            (this.y = (h - f) / v),
            (this.z = (u - l) / v),
            (this.w = Math.acos((c + p + g - 1) / 2)),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            (this.w = e.w + (t.w - e.w) * n),
            this
          );
        }
        equals(e) {
          return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
          );
        }
        fromBufferAttribute(e, t, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
      }
      class U extends R {
        constructor(e, t, n) {
          super(),
            Object.defineProperty(this, "isWebGLRenderTarget", { value: !0 }),
            (this.width = e),
            (this.height = t),
            (this.scissor = new z(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new z(0, 0, e, t)),
            (n = n || {}),
            (this.texture = new H(
              void 0,
              n.mapping,
              n.wrapS,
              n.wrapT,
              n.magFilter,
              n.minFilter,
              n.format,
              n.type,
              n.anisotropy,
              n.encoding
            )),
            (this.texture.image = {}),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.generateMipmaps =
              void 0 !== n.generateMipmaps && n.generateMipmaps),
            (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : s),
            (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
            (this.stencilBuffer =
              void 0 !== n.stencilBuffer && n.stencilBuffer),
            (this.depthTexture =
              void 0 !== n.depthTexture ? n.depthTexture : null);
        }
        setSize(e, t) {
          (this.width === e && this.height === t) ||
            ((this.width = e),
            (this.height = t),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.width = e.width),
            (this.height = e.height),
            this.viewport.copy(e.viewport),
            (this.texture = e.texture.clone()),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.depthTexture = e.depthTexture),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      class G {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          Object.defineProperty(this, "isQuaternion", { value: !0 }),
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i);
        }
        static slerp(e, t, n, i) {
          return n.copy(e).slerp(t, i);
        }
        static slerpFlat(e, t, n, i, r, a, o) {
          let s = n[i + 0],
            c = n[i + 1],
            l = n[i + 2],
            h = n[i + 3];
          const u = r[a + 0],
            p = r[a + 1],
            d = r[a + 2],
            f = r[a + 3];
          if (h !== f || s !== u || c !== p || l !== d) {
            let e = 1 - o;
            const t = s * u + c * p + l * d + h * f,
              n = t >= 0 ? 1 : -1,
              i = 1 - t * t;
            if (i > Number.EPSILON) {
              const r = Math.sqrt(i),
                a = Math.atan2(r, t * n);
              (e = Math.sin(e * a) / r), (o = Math.sin(o * a) / r);
            }
            const r = o * n;
            if (
              ((s = s * e + u * r),
              (c = c * e + p * r),
              (l = l * e + d * r),
              (h = h * e + f * r),
              e === 1 - o)
            ) {
              const e = 1 / Math.sqrt(s * s + c * c + l * l + h * h);
              (s *= e), (c *= e), (l *= e), (h *= e);
            }
          }
          (e[t] = s), (e[t + 1] = c), (e[t + 2] = l), (e[t + 3] = h);
        }
        static multiplyQuaternionsFlat(e, t, n, i, r, a) {
          const o = n[i],
            s = n[i + 1],
            c = n[i + 2],
            l = n[i + 3],
            h = r[a],
            u = r[a + 1],
            p = r[a + 2],
            d = r[a + 3];
          return (
            (e[t] = o * d + l * h + s * p - c * u),
            (e[t + 1] = s * d + l * u + c * h - o * p),
            (e[t + 2] = c * d + l * p + o * u - s * h),
            (e[t + 3] = l * d - o * h - s * u - c * p),
            e
          );
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          (this._w = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(e, t) {
          if (!e || !e.isEuler)
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          const n = e._x,
            i = e._y,
            r = e._z,
            a = e._order,
            o = Math.cos,
            s = Math.sin,
            c = o(n / 2),
            l = o(i / 2),
            h = o(r / 2),
            u = s(n / 2),
            p = s(i / 2),
            d = s(r / 2);
          switch (a) {
            case "XYZ":
              (this._x = u * l * h + c * p * d),
                (this._y = c * p * h - u * l * d),
                (this._z = c * l * d + u * p * h),
                (this._w = c * l * h - u * p * d);
              break;
            case "YXZ":
              (this._x = u * l * h + c * p * d),
                (this._y = c * p * h - u * l * d),
                (this._z = c * l * d - u * p * h),
                (this._w = c * l * h + u * p * d);
              break;
            case "ZXY":
              (this._x = u * l * h - c * p * d),
                (this._y = c * p * h + u * l * d),
                (this._z = c * l * d + u * p * h),
                (this._w = c * l * h - u * p * d);
              break;
            case "ZYX":
              (this._x = u * l * h - c * p * d),
                (this._y = c * p * h + u * l * d),
                (this._z = c * l * d - u * p * h),
                (this._w = c * l * h + u * p * d);
              break;
            case "YZX":
              (this._x = u * l * h + c * p * d),
                (this._y = c * p * h + u * l * d),
                (this._z = c * l * d - u * p * h),
                (this._w = c * l * h - u * p * d);
              break;
            case "XZY":
              (this._x = u * l * h - c * p * d),
                (this._y = c * p * h - u * l * d),
                (this._z = c * l * d + u * p * h),
                (this._w = c * l * h + u * p * d);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  a
              );
          }
          return !1 !== t && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const n = t / 2,
            i = Math.sin(n);
          return (
            (this._x = e.x * i),
            (this._y = e.y * i),
            (this._z = e.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            n = t[0],
            i = t[4],
            r = t[8],
            a = t[1],
            o = t[5],
            s = t[9],
            c = t[2],
            l = t[6],
            h = t[10],
            u = n + o + h;
          if (u > 0) {
            const e = 0.5 / Math.sqrt(u + 1);
            (this._w = 0.25 / e),
              (this._x = (l - s) * e),
              (this._y = (r - c) * e),
              (this._z = (a - i) * e);
          } else if (n > o && n > h) {
            const e = 2 * Math.sqrt(1 + n - o - h);
            (this._w = (l - s) / e),
              (this._x = 0.25 * e),
              (this._y = (i + a) / e),
              (this._z = (r + c) / e);
          } else if (o > h) {
            const e = 2 * Math.sqrt(1 + o - n - h);
            (this._w = (r - c) / e),
              (this._x = (i + a) / e),
              (this._y = 0.25 * e),
              (this._z = (s + l) / e);
          } else {
            const e = 2 * Math.sqrt(1 + h - n - o);
            (this._w = (a - i) / e),
              (this._x = (r + c) / e),
              (this._y = (s + l) / e),
              (this._z = 0.25 * e);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let n = e.dot(t) + 1;
          return (
            n < 1e-6
              ? ((n = 0),
                Math.abs(e.x) > Math.abs(e.z)
                  ? ((this._x = -e.y),
                    (this._y = e.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -e.z),
                    (this._z = e.y),
                    (this._w = n)))
              : ((this._x = e.y * t.z - e.z * t.y),
                (this._y = e.z * t.x - e.x * t.z),
                (this._z = e.x * t.y - e.y * t.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(O.clamp(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const n = this.angleTo(e);
          if (0 === n) return this;
          const i = Math.min(1, t / n);
          return this.slerp(e, i), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(e) {
          return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let e = this.length();
          return (
            0 === e
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((e = 1 / e),
                (this._x = this._x * e),
                (this._y = this._y * e),
                (this._z = this._z * e),
                (this._w = this._w * e)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(e, t))
            : this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const n = e._x,
            i = e._y,
            r = e._z,
            a = e._w,
            o = t._x,
            s = t._y,
            c = t._z,
            l = t._w;
          return (
            (this._x = n * l + a * o + i * c - r * s),
            (this._y = i * l + a * s + r * o - n * c),
            (this._z = r * l + a * c + n * s - i * o),
            (this._w = a * l - n * o - i * s - r * c),
            this._onChangeCallback(),
            this
          );
        }
        slerp(e, t) {
          if (0 === t) return this;
          if (1 === t) return this.copy(e);
          const n = this._x,
            i = this._y,
            r = this._z,
            a = this._w;
          let o = a * e._w + n * e._x + i * e._y + r * e._z;
          if (
            (o < 0
              ? ((this._w = -e._w),
                (this._x = -e._x),
                (this._y = -e._y),
                (this._z = -e._z),
                (o = -o))
              : this.copy(e),
            o >= 1)
          )
            return (
              (this._w = a), (this._x = n), (this._y = i), (this._z = r), this
            );
          const s = 1 - o * o;
          if (s <= Number.EPSILON) {
            const e = 1 - t;
            return (
              (this._w = e * a + t * this._w),
              (this._x = e * n + t * this._x),
              (this._y = e * i + t * this._y),
              (this._z = e * r + t * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const c = Math.sqrt(s),
            l = Math.atan2(c, o),
            h = Math.sin((1 - t) * l) / c,
            u = Math.sin(t * l) / c;
          return (
            (this._w = a * h + this._w * u),
            (this._x = n * h + this._x * u),
            (this._y = i * h + this._y * u),
            (this._z = r * h + this._z * u),
            this._onChangeCallback(),
            this
          );
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
      }
      class W {
        constructor(e = 0, t = 0, n = 0) {
          Object.defineProperty(this, "isVector3", { value: !0 }),
            (this.x = e),
            (this.y = t),
            (this.z = n);
        }
        set(e, t, n) {
          return (
            void 0 === n && (n = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            this
          );
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        }
        add(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
          );
        }
        sub(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
          );
        }
        multiply(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(e, t))
            : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        multiplyVectors(e, t) {
          return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
          );
        }
        applyEuler(e) {
          return (
            (e && e.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              ),
            this.applyQuaternion(q.setFromEuler(e))
          );
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(q.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[3] * n + r[6] * i),
            (this.y = r[1] * t + r[4] * n + r[7] * i),
            (this.z = r[2] * t + r[5] * n + r[8] * i),
            this
          );
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements,
            a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
          return (
            (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a),
            (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a),
            (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a),
            this
          );
        }
        applyQuaternion(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.x,
            a = e.y,
            o = e.z,
            s = e.w,
            c = s * t + a * i - o * n,
            l = s * n + o * t - r * i,
            h = s * i + r * n - a * t,
            u = -r * t - a * n - o * i;
          return (
            (this.x = c * s + u * -r + l * -o - h * -a),
            (this.y = l * s + u * -a + h * -r - c * -o),
            (this.z = h * s + u * -o + c * -a - l * -r),
            this
          );
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
          );
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
          );
        }
        transformDirection(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[4] * n + r[8] * i),
            (this.y = r[1] * t + r[5] * n + r[9] * i),
            (this.z = r[2] * t + r[6] * n + r[10] * i),
            this.normalize()
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            this
          );
        }
        cross(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(e, t))
            : this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            a = t.x,
            o = t.y,
            s = t.z;
          return (
            (this.x = i * s - r * o),
            (this.y = r * a - n * s),
            (this.z = n * o - i * a),
            this
          );
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (0 === t) return this.set(0, 0, 0);
          const n = e.dot(this) / t;
          return this.copy(e).multiplyScalar(n);
        }
        projectOnPlane(e) {
          return V.copy(this).projectOnVector(e), this.sub(V);
        }
        reflect(e) {
          return this.sub(V.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t) return Math.PI / 2;
          const n = this.dot(e) / t;
          return Math.acos(O.clamp(n, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y,
            i = this.z - e.z;
          return t * t + n * n + i * i;
        }
        manhattanDistanceTo(e) {
          return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
          );
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, n) {
          const i = Math.sin(t) * e;
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(t) * e),
            (this.z = i * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, n) {
          return (
            (this.x = e * Math.sin(t)),
            (this.y = n),
            (this.z = e * Math.cos(t)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = n), (this.z = i), this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, 4 * t);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, 3 * t);
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
      }
      const V = new W(),
        q = new G();
      class X {
        constructor(e, t) {
          Object.defineProperty(this, "isBox3", { value: !0 }),
            (this.min = void 0 !== e ? e : new W(1 / 0, 1 / 0, 1 / 0)),
            (this.max = void 0 !== t ? t : new W(-1 / 0, -1 / 0, -1 / 0));
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            a = -1 / 0,
            o = -1 / 0;
          for (let s = 0, c = e.length; s < c; s += 3) {
            const c = e[s],
              l = e[s + 1],
              h = e[s + 2];
            c < t && (t = c),
              l < n && (n = l),
              h < i && (i = h),
              c > r && (r = c),
              l > a && (a = l),
              h > o && (o = h);
          }
          return this.min.set(t, n, i), this.max.set(r, a, o), this;
        }
        setFromBufferAttribute(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            a = -1 / 0,
            o = -1 / 0;
          for (let s = 0, c = e.count; s < c; s++) {
            const c = e.getX(s),
              l = e.getY(s),
              h = e.getZ(s);
            c < t && (t = c),
              l < n && (n = l),
              h < i && (i = h),
              c > r && (r = c),
              l > a && (a = l),
              h > o && (o = h);
          }
          return this.min.set(t, n, i), this.max.set(r, a, o), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = Z.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e) {
          return this.makeEmpty(), this.expandByObject(e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(e) {
          return (
            void 0 === e &&
              (console.warn("THREE.Box3: .getCenter() target is now required"),
              (e = new W())),
            this.isEmpty()
              ? e.set(0, 0, 0)
              : e.addVectors(this.min, this.max).multiplyScalar(0.5)
          );
        }
        getSize(e) {
          return (
            void 0 === e &&
              (console.warn("THREE.Box3: .getSize() target is now required"),
              (e = new W())),
            this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
          );
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e) {
          e.updateWorldMatrix(!1, !1);
          const t = e.geometry;
          void 0 !== t &&
            (null === t.boundingBox && t.computeBoundingBox(),
            Q.copy(t.boundingBox),
            Q.applyMatrix4(e.matrixWorld),
            this.union(Q));
          const n = e.children;
          for (let e = 0, t = n.length; e < t; e++) this.expandByObject(n[e]);
          return this;
        }
        containsPoint(e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
          );
        }
        getParameter(e, t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Box3: .getParameter() target is now required"
              ),
              (t = new W())),
            t.set(
              (e.x - this.min.x) / (this.max.x - this.min.x),
              (e.y - this.min.y) / (this.max.y - this.min.y),
              (e.z - this.min.z) / (this.max.z - this.min.z)
            )
          );
        }
        intersectsBox(e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
          );
        }
        intersectsSphere(e) {
          return (
            this.clampPoint(e.center, Z),
            Z.distanceToSquared(e.center) <= e.radius * e.radius
          );
        }
        intersectsPlane(e) {
          let t, n;
          return (
            e.normal.x > 0
              ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
              : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y),
                (n += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z),
                (n += e.normal.z * this.min.z)),
            t <= -e.constant && n >= -e.constant
          );
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(re),
            ae.subVectors(this.max, re),
            K.subVectors(e.a, re),
            $.subVectors(e.b, re),
            ee.subVectors(e.c, re),
            te.subVectors($, K),
            ne.subVectors(ee, $),
            ie.subVectors(K, ee);
          let t = [
            0,
            -te.z,
            te.y,
            0,
            -ne.z,
            ne.y,
            0,
            -ie.z,
            ie.y,
            te.z,
            0,
            -te.x,
            ne.z,
            0,
            -ne.x,
            ie.z,
            0,
            -ie.x,
            -te.y,
            te.x,
            0,
            -ne.y,
            ne.x,
            0,
            -ie.y,
            ie.x,
            0,
          ];
          return (
            !!Y(t, K, $, ee, ae) &&
            ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            !!Y(t, K, $, ee, ae) &&
              (oe.crossVectors(te, ne),
              (t = [oe.x, oe.y, oe.z]),
              Y(t, K, $, ee, ae)))
          );
        }
        clampPoint(e, t) {
          return (
            void 0 === t &&
              (console.warn("THREE.Box3: .clampPoint() target is now required"),
              (t = new W())),
            t.copy(e).clamp(this.min, this.max)
          );
        }
        distanceToPoint(e) {
          return Z.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        getBoundingSphere(e) {
          return (
            void 0 === e &&
              console.error(
                "THREE.Box3: .getBoundingSphere() target is now required"
              ),
            this.getCenter(e.center),
            (e.radius = 0.5 * this.getSize(Z).length()),
            e
          );
        }
        intersect(e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return (
            this.isEmpty() ||
              (J[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              J[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              J[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              J[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              J[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              J[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              J[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              J[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(J)),
            this
          );
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      function Y(e, t, n, i, r) {
        for (let a = 0, o = e.length - 3; a <= o; a += 3) {
          se.fromArray(e, a);
          const o =
              r.x * Math.abs(se.x) +
              r.y * Math.abs(se.y) +
              r.z * Math.abs(se.z),
            s = t.dot(se),
            c = n.dot(se),
            l = i.dot(se);
          if (Math.max(-Math.max(s, c, l), Math.min(s, c, l)) > o) return !1;
        }
        return !0;
      }
      const J = [
          new W(),
          new W(),
          new W(),
          new W(),
          new W(),
          new W(),
          new W(),
          new W(),
        ],
        Z = new W(),
        Q = new X(),
        K = new W(),
        $ = new W(),
        ee = new W(),
        te = new W(),
        ne = new W(),
        ie = new W(),
        re = new W(),
        ae = new W(),
        oe = new W(),
        se = new W(),
        ce = new X();
      class le {
        constructor(e, t) {
          (this.center = void 0 !== e ? e : new W()),
            (this.radius = void 0 !== t ? t : -1);
        }
        set(e, t) {
          return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
          const n = this.center;
          void 0 !== t ? n.copy(t) : ce.setFromPoints(e).getCenter(n);
          let i = 0;
          for (let t = 0, r = e.length; t < r; t++)
            i = Math.max(i, n.distanceToSquared(e[t]));
          return (this.radius = Math.sqrt(i)), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const n = this.center.distanceToSquared(e);
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Sphere: .clampPoint() target is now required"
              ),
              (t = new W())),
            t.copy(e),
            n > this.radius * this.radius &&
              (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
            t
          );
        }
        getBoundingBox(e) {
          return (
            void 0 === e &&
              (console.warn(
                "THREE.Sphere: .getBoundingBox() target is now required"
              ),
              (e = new X())),
            this.isEmpty()
              ? (e.makeEmpty(), e)
              : (e.set(this.center, this.center),
                e.expandByScalar(this.radius),
                e)
          );
        }
        applyMatrix4(e) {
          return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
          );
        }
        translate(e) {
          return this.center.add(e), this;
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
      }
      const he = new W(),
        ue = new W(),
        pe = new W(),
        de = new W(),
        fe = new W(),
        me = new W(),
        ge = new W();
      class ve {
        constructor(e, t) {
          (this.origin = void 0 !== e ? e : new W()),
            (this.direction = void 0 !== t ? t : new W(0, 0, -1));
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
          );
        }
        at(e, t) {
          return (
            void 0 === t &&
              (console.warn("THREE.Ray: .at() target is now required"),
              (t = new W())),
            t.copy(this.direction).multiplyScalar(e).add(this.origin)
          );
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, he)), this;
        }
        closestPointToPoint(e, t) {
          void 0 === t &&
            (console.warn(
              "THREE.Ray: .closestPointToPoint() target is now required"
            ),
            (t = new W())),
            t.subVectors(e, this.origin);
          const n = t.dot(this.direction);
          return n < 0
            ? t.copy(this.origin)
            : t.copy(this.direction).multiplyScalar(n).add(this.origin);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = he.subVectors(e, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(e)
            : (he.copy(this.direction).multiplyScalar(t).add(this.origin),
              he.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, i) {
          ue.copy(e).add(t).multiplyScalar(0.5),
            pe.copy(t).sub(e).normalize(),
            de.copy(this.origin).sub(ue);
          const r = 0.5 * e.distanceTo(t),
            a = -this.direction.dot(pe),
            o = de.dot(this.direction),
            s = -de.dot(pe),
            c = de.lengthSq(),
            l = Math.abs(1 - a * a);
          let h, u, p, d;
          if (l > 0)
            if (((h = a * s - o), (u = a * o - s), (d = r * l), h >= 0))
              if (u >= -d)
                if (u <= d) {
                  const e = 1 / l;
                  (h *= e),
                    (u *= e),
                    (p = h * (h + a * u + 2 * o) + u * (a * h + u + 2 * s) + c);
                } else
                  (u = r),
                    (h = Math.max(0, -(a * u + o))),
                    (p = -h * h + u * (u + 2 * s) + c);
              else
                (u = -r),
                  (h = Math.max(0, -(a * u + o))),
                  (p = -h * h + u * (u + 2 * s) + c);
            else
              u <= -d
                ? ((h = Math.max(0, -(-a * r + o))),
                  (u = h > 0 ? -r : Math.min(Math.max(-r, -s), r)),
                  (p = -h * h + u * (u + 2 * s) + c))
                : u <= d
                ? ((h = 0),
                  (u = Math.min(Math.max(-r, -s), r)),
                  (p = u * (u + 2 * s) + c))
                : ((h = Math.max(0, -(a * r + o))),
                  (u = h > 0 ? r : Math.min(Math.max(-r, -s), r)),
                  (p = -h * h + u * (u + 2 * s) + c));
          else
            (u = a > 0 ? -r : r),
              (h = Math.max(0, -(a * u + o))),
              (p = -h * h + u * (u + 2 * s) + c);
          return (
            n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
            i && i.copy(pe).multiplyScalar(u).add(ue),
            p
          );
        }
        intersectSphere(e, t) {
          he.subVectors(e.center, this.origin);
          const n = he.dot(this.direction),
            i = he.dot(he) - n * n,
            r = e.radius * e.radius;
          if (i > r) return null;
          const a = Math.sqrt(r - i),
            o = n - a,
            s = n + a;
          return o < 0 && s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
          const n = -(this.origin.dot(e.normal) + e.constant) / t;
          return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
          const n = this.distanceToPlane(e);
          return null === n ? null : this.at(n, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return 0 === t || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let n, i, r, a, o, s;
          const c = 1 / this.direction.x,
            l = 1 / this.direction.y,
            h = 1 / this.direction.z,
            u = this.origin;
          return (
            c >= 0
              ? ((n = (e.min.x - u.x) * c), (i = (e.max.x - u.x) * c))
              : ((n = (e.max.x - u.x) * c), (i = (e.min.x - u.x) * c)),
            l >= 0
              ? ((r = (e.min.y - u.y) * l), (a = (e.max.y - u.y) * l))
              : ((r = (e.max.y - u.y) * l), (a = (e.min.y - u.y) * l)),
            n > a || r > i
              ? null
              : ((r > n || n != n) && (n = r),
                (a < i || i != i) && (i = a),
                h >= 0
                  ? ((o = (e.min.z - u.z) * h), (s = (e.max.z - u.z) * h))
                  : ((o = (e.max.z - u.z) * h), (s = (e.min.z - u.z) * h)),
                n > s || o > i
                  ? null
                  : ((o > n || n != n) && (n = o),
                    (s < i || i != i) && (i = s),
                    i < 0 ? null : this.at(n >= 0 ? n : i, t)))
          );
        }
        intersectsBox(e) {
          return null !== this.intersectBox(e, he);
        }
        intersectTriangle(e, t, n, i, r) {
          fe.subVectors(t, e), me.subVectors(n, e), ge.crossVectors(fe, me);
          let a,
            o = this.direction.dot(ge);
          if (o > 0) {
            if (i) return null;
            a = 1;
          } else {
            if (!(o < 0)) return null;
            (a = -1), (o = -o);
          }
          de.subVectors(this.origin, e);
          const s = a * this.direction.dot(me.crossVectors(de, me));
          if (s < 0) return null;
          const c = a * this.direction.dot(fe.cross(de));
          if (c < 0) return null;
          if (s + c > o) return null;
          const l = -a * de.dot(ge);
          return l < 0 ? null : this.at(l / o, r);
        }
        applyMatrix4(e) {
          return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
          );
        }
        equals(e) {
          return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
          );
        }
      }
      class ye {
        constructor() {
          Object.defineProperty(this, "isMatrix4", { value: !0 }),
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, a, o, s, c, l, h, u, p, d, f, m) {
          const g = this.elements;
          return (
            (g[0] = e),
            (g[4] = t),
            (g[8] = n),
            (g[12] = i),
            (g[1] = r),
            (g[5] = a),
            (g[9] = o),
            (g[13] = s),
            (g[2] = c),
            (g[6] = l),
            (g[10] = h),
            (g[14] = u),
            (g[3] = p),
            (g[7] = d),
            (g[11] = f),
            (g[15] = m),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new ye().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            (t[9] = n[9]),
            (t[10] = n[10]),
            (t[11] = n[11]),
            (t[12] = n[12]),
            (t[13] = n[13]),
            (t[14] = n[14]),
            (t[15] = n[15]),
            this
          );
        }
        copyPosition(e) {
          const t = this.elements,
            n = e.elements;
          return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return (
            this.set(
              t[0],
              t[3],
              t[6],
              0,
              t[1],
              t[4],
              t[7],
              0,
              t[2],
              t[5],
              t[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(e, t, n) {
          return (
            this.set(
              e.x,
              t.x,
              n.x,
              0,
              e.y,
              t.y,
              n.y,
              0,
              e.z,
              t.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(e) {
          const t = this.elements,
            n = e.elements,
            i = 1 / _e.setFromMatrixColumn(e, 0).length(),
            r = 1 / _e.setFromMatrixColumn(e, 1).length(),
            a = 1 / _e.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = n[0] * i),
            (t[1] = n[1] * i),
            (t[2] = n[2] * i),
            (t[3] = 0),
            (t[4] = n[4] * r),
            (t[5] = n[5] * r),
            (t[6] = n[6] * r),
            (t[7] = 0),
            (t[8] = n[8] * a),
            (t[9] = n[9] * a),
            (t[10] = n[10] * a),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromEuler(e) {
          (e && e.isEuler) ||
            console.error(
              "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z,
            a = Math.cos(n),
            o = Math.sin(n),
            s = Math.cos(i),
            c = Math.sin(i),
            l = Math.cos(r),
            h = Math.sin(r);
          if ("XYZ" === e.order) {
            const e = a * l,
              n = a * h,
              i = o * l,
              r = o * h;
            (t[0] = s * l),
              (t[4] = -s * h),
              (t[8] = c),
              (t[1] = n + i * c),
              (t[5] = e - r * c),
              (t[9] = -o * s),
              (t[2] = r - e * c),
              (t[6] = i + n * c),
              (t[10] = a * s);
          } else if ("YXZ" === e.order) {
            const e = s * l,
              n = s * h,
              i = c * l,
              r = c * h;
            (t[0] = e + r * o),
              (t[4] = i * o - n),
              (t[8] = a * c),
              (t[1] = a * h),
              (t[5] = a * l),
              (t[9] = -o),
              (t[2] = n * o - i),
              (t[6] = r + e * o),
              (t[10] = a * s);
          } else if ("ZXY" === e.order) {
            const e = s * l,
              n = s * h,
              i = c * l,
              r = c * h;
            (t[0] = e - r * o),
              (t[4] = -a * h),
              (t[8] = i + n * o),
              (t[1] = n + i * o),
              (t[5] = a * l),
              (t[9] = r - e * o),
              (t[2] = -a * c),
              (t[6] = o),
              (t[10] = a * s);
          } else if ("ZYX" === e.order) {
            const e = a * l,
              n = a * h,
              i = o * l,
              r = o * h;
            (t[0] = s * l),
              (t[4] = i * c - n),
              (t[8] = e * c + r),
              (t[1] = s * h),
              (t[5] = r * c + e),
              (t[9] = n * c - i),
              (t[2] = -c),
              (t[6] = o * s),
              (t[10] = a * s);
          } else if ("YZX" === e.order) {
            const e = a * s,
              n = a * c,
              i = o * s,
              r = o * c;
            (t[0] = s * l),
              (t[4] = r - e * h),
              (t[8] = i * h + n),
              (t[1] = h),
              (t[5] = a * l),
              (t[9] = -o * l),
              (t[2] = -c * l),
              (t[6] = n * h + i),
              (t[10] = e - r * h);
          } else if ("XZY" === e.order) {
            const e = a * s,
              n = a * c,
              i = o * s,
              r = o * c;
            (t[0] = s * l),
              (t[4] = -h),
              (t[8] = c * l),
              (t[1] = e * h + r),
              (t[5] = a * l),
              (t[9] = n * h - i),
              (t[2] = i * h - n),
              (t[6] = o * l),
              (t[10] = r * h + e);
          }
          return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(e) {
          return this.compose(xe, e, be);
        }
        lookAt(e, t, n) {
          const i = this.elements;
          return (
            Te.subVectors(e, t),
            0 === Te.lengthSq() && (Te.z = 1),
            Te.normalize(),
            Me.crossVectors(n, Te),
            0 === Me.lengthSq() &&
              (1 === Math.abs(n.z) ? (Te.x += 1e-4) : (Te.z += 1e-4),
              Te.normalize(),
              Me.crossVectors(n, Te)),
            Me.normalize(),
            Se.crossVectors(Te, Me),
            (i[0] = Me.x),
            (i[4] = Se.x),
            (i[8] = Te.x),
            (i[1] = Me.y),
            (i[5] = Se.y),
            (i[9] = Te.y),
            (i[2] = Me.z),
            (i[6] = Se.z),
            (i[10] = Te.z),
            this
          );
        }
        multiply(e, t) {
          return void 0 !== t
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(e, t))
            : this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            a = n[0],
            o = n[4],
            s = n[8],
            c = n[12],
            l = n[1],
            h = n[5],
            u = n[9],
            p = n[13],
            d = n[2],
            f = n[6],
            m = n[10],
            g = n[14],
            v = n[3],
            y = n[7],
            _ = n[11],
            w = n[15],
            x = i[0],
            b = i[4],
            M = i[8],
            S = i[12],
            T = i[1],
            E = i[5],
            A = i[9],
            L = i[13],
            P = i[2],
            R = i[6],
            k = i[10],
            C = i[14],
            O = i[3],
            N = i[7],
            I = i[11],
            D = i[15];
          return (
            (r[0] = a * x + o * T + s * P + c * O),
            (r[4] = a * b + o * E + s * R + c * N),
            (r[8] = a * M + o * A + s * k + c * I),
            (r[12] = a * S + o * L + s * C + c * D),
            (r[1] = l * x + h * T + u * P + p * O),
            (r[5] = l * b + h * E + u * R + p * N),
            (r[9] = l * M + h * A + u * k + p * I),
            (r[13] = l * S + h * L + u * C + p * D),
            (r[2] = d * x + f * T + m * P + g * O),
            (r[6] = d * b + f * E + m * R + g * N),
            (r[10] = d * M + f * A + m * k + g * I),
            (r[14] = d * S + f * L + m * C + g * D),
            (r[3] = v * x + y * T + _ * P + w * O),
            (r[7] = v * b + y * E + _ * R + w * N),
            (r[11] = v * M + y * A + _ * k + w * I),
            (r[15] = v * S + y * L + _ * C + w * D),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[4],
            i = e[8],
            r = e[12],
            a = e[1],
            o = e[5],
            s = e[9],
            c = e[13],
            l = e[2],
            h = e[6],
            u = e[10],
            p = e[14];
          return (
            e[3] *
              (+r * s * h -
                i * c * h -
                r * o * u +
                n * c * u +
                i * o * p -
                n * s * p) +
            e[7] *
              (+t * s * p -
                t * c * u +
                r * a * u -
                i * a * p +
                i * c * l -
                r * s * l) +
            e[11] *
              (+t * c * h -
                t * o * p -
                r * a * h +
                n * a * p +
                r * o * l -
                n * c * l) +
            e[15] *
              (-i * o * l -
                t * s * h +
                t * o * u +
                i * a * h -
                n * a * u +
                n * s * l)
          );
        }
        transpose() {
          const e = this.elements;
          let t;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(e, t, n) {
          const i = this.elements;
          return (
            e.isVector3
              ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
              : ((i[12] = e), (i[13] = t), (i[14] = n)),
            this
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            a = e[4],
            o = e[5],
            s = e[6],
            c = e[7],
            l = e[8],
            h = e[9],
            u = e[10],
            p = e[11],
            d = e[12],
            f = e[13],
            m = e[14],
            g = e[15],
            v =
              h * m * c -
              f * u * c +
              f * s * p -
              o * m * p -
              h * s * g +
              o * u * g,
            y =
              d * u * c -
              l * m * c -
              d * s * p +
              a * m * p +
              l * s * g -
              a * u * g,
            _ =
              l * f * c -
              d * h * c +
              d * o * p -
              a * f * p -
              l * o * g +
              a * h * g,
            w =
              d * h * s -
              l * f * s -
              d * o * u +
              a * f * u +
              l * o * m -
              a * h * m,
            x = t * v + n * y + i * _ + r * w;
          if (0 === x)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const b = 1 / x;
          return (
            (e[0] = v * b),
            (e[1] =
              (f * u * r -
                h * m * r -
                f * i * p +
                n * m * p +
                h * i * g -
                n * u * g) *
              b),
            (e[2] =
              (o * m * r -
                f * s * r +
                f * i * c -
                n * m * c -
                o * i * g +
                n * s * g) *
              b),
            (e[3] =
              (h * s * r -
                o * u * r -
                h * i * c +
                n * u * c +
                o * i * p -
                n * s * p) *
              b),
            (e[4] = y * b),
            (e[5] =
              (l * m * r -
                d * u * r +
                d * i * p -
                t * m * p -
                l * i * g +
                t * u * g) *
              b),
            (e[6] =
              (d * s * r -
                a * m * r -
                d * i * c +
                t * m * c +
                a * i * g -
                t * s * g) *
              b),
            (e[7] =
              (a * u * r -
                l * s * r +
                l * i * c -
                t * u * c -
                a * i * p +
                t * s * p) *
              b),
            (e[8] = _ * b),
            (e[9] =
              (d * h * r -
                l * f * r -
                d * n * p +
                t * f * p +
                l * n * g -
                t * h * g) *
              b),
            (e[10] =
              (a * f * r -
                d * o * r +
                d * n * c -
                t * f * c -
                a * n * g +
                t * o * g) *
              b),
            (e[11] =
              (l * o * r -
                a * h * r -
                l * n * c +
                t * h * c +
                a * n * p -
                t * o * p) *
              b),
            (e[12] = w * b),
            (e[13] =
              (l * f * i -
                d * h * i +
                d * n * u -
                t * f * u -
                l * n * m +
                t * h * m) *
              b),
            (e[14] =
              (d * o * i -
                a * f * i -
                d * n * s +
                t * f * s +
                a * n * m -
                t * o * m) *
              b),
            (e[15] =
              (a * h * i -
                l * o * i +
                l * n * s -
                t * h * s -
                a * n * u +
                t * o * u) *
              b),
            this
          );
        }
        scale(e) {
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z;
          return (
            (t[0] *= n),
            (t[4] *= i),
            (t[8] *= r),
            (t[1] *= n),
            (t[5] *= i),
            (t[9] *= r),
            (t[2] *= n),
            (t[6] *= i),
            (t[10] *= r),
            (t[3] *= n),
            (t[7] *= i),
            (t[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, n, i));
        }
        makeTranslation(e, t, n) {
          return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = 1 - n,
            a = e.x,
            o = e.y,
            s = e.z,
            c = r * a,
            l = r * o;
          return (
            this.set(
              c * a + n,
              c * o - i * s,
              c * s + i * o,
              0,
              c * o + i * s,
              l * o + n,
              l * s - i * a,
              0,
              c * s - i * o,
              l * s + i * a,
              r * s * s + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(e, t, n) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, n) {
          return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, n) {
          const i = this.elements,
            r = t._x,
            a = t._y,
            o = t._z,
            s = t._w,
            c = r + r,
            l = a + a,
            h = o + o,
            u = r * c,
            p = r * l,
            d = r * h,
            f = a * l,
            m = a * h,
            g = o * h,
            v = s * c,
            y = s * l,
            _ = s * h,
            w = n.x,
            x = n.y,
            b = n.z;
          return (
            (i[0] = (1 - (f + g)) * w),
            (i[1] = (p + _) * w),
            (i[2] = (d - y) * w),
            (i[3] = 0),
            (i[4] = (p - _) * x),
            (i[5] = (1 - (u + g)) * x),
            (i[6] = (m + v) * x),
            (i[7] = 0),
            (i[8] = (d + y) * b),
            (i[9] = (m - v) * b),
            (i[10] = (1 - (u + f)) * b),
            (i[11] = 0),
            (i[12] = e.x),
            (i[13] = e.y),
            (i[14] = e.z),
            (i[15] = 1),
            this
          );
        }
        decompose(e, t, n) {
          const i = this.elements;
          let r = _e.set(i[0], i[1], i[2]).length();
          const a = _e.set(i[4], i[5], i[6]).length(),
            o = _e.set(i[8], i[9], i[10]).length();
          this.determinant() < 0 && (r = -r),
            (e.x = i[12]),
            (e.y = i[13]),
            (e.z = i[14]),
            we.copy(this);
          const s = 1 / r,
            c = 1 / a,
            l = 1 / o;
          return (
            (we.elements[0] *= s),
            (we.elements[1] *= s),
            (we.elements[2] *= s),
            (we.elements[4] *= c),
            (we.elements[5] *= c),
            (we.elements[6] *= c),
            (we.elements[8] *= l),
            (we.elements[9] *= l),
            (we.elements[10] *= l),
            t.setFromRotationMatrix(we),
            (n.x = r),
            (n.y = a),
            (n.z = o),
            this
          );
        }
        makePerspective(e, t, n, i, r, a) {
          void 0 === a &&
            console.warn(
              "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
            );
          const o = this.elements,
            s = (2 * r) / (t - e),
            c = (2 * r) / (n - i),
            l = (t + e) / (t - e),
            h = (n + i) / (n - i),
            u = -(a + r) / (a - r),
            p = (-2 * a * r) / (a - r);
          return (
            (o[0] = s),
            (o[4] = 0),
            (o[8] = l),
            (o[12] = 0),
            (o[1] = 0),
            (o[5] = c),
            (o[9] = h),
            (o[13] = 0),
            (o[2] = 0),
            (o[6] = 0),
            (o[10] = u),
            (o[14] = p),
            (o[3] = 0),
            (o[7] = 0),
            (o[11] = -1),
            (o[15] = 0),
            this
          );
        }
        makeOrthographic(e, t, n, i, r, a) {
          const o = this.elements,
            s = 1 / (t - e),
            c = 1 / (n - i),
            l = 1 / (a - r),
            h = (t + e) * s,
            u = (n + i) * c,
            p = (a + r) * l;
          return (
            (o[0] = 2 * s),
            (o[4] = 0),
            (o[8] = 0),
            (o[12] = -h),
            (o[1] = 0),
            (o[5] = 2 * c),
            (o[9] = 0),
            (o[13] = -u),
            (o[2] = 0),
            (o[6] = 0),
            (o[10] = -2 * l),
            (o[14] = -p),
            (o[3] = 0),
            (o[7] = 0),
            (o[11] = 0),
            (o[15] = 1),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let e = 0; e < 16; e++) if (t[e] !== n[e]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            (e[t + 9] = n[9]),
            (e[t + 10] = n[10]),
            (e[t + 11] = n[11]),
            (e[t + 12] = n[12]),
            (e[t + 13] = n[13]),
            (e[t + 14] = n[14]),
            (e[t + 15] = n[15]),
            e
          );
        }
      }
      const _e = new W(),
        we = new ye(),
        xe = new W(0, 0, 0),
        be = new W(1, 1, 1),
        Me = new W(),
        Se = new W(),
        Te = new W();
      class Ee {
        constructor(e = 0, t = 0, n = 0, i = Ee.DefaultOrder) {
          Object.defineProperty(this, "isEuler", { value: !0 }),
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i);
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          (this._order = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i || this._order),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return (
            (this._x = e._x),
            (this._y = e._y),
            (this._z = e._z),
            (this._order = e._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e, t, n) {
          const i = O.clamp,
            r = e.elements,
            a = r[0],
            o = r[4],
            s = r[8],
            c = r[1],
            l = r[5],
            h = r[9],
            u = r[2],
            p = r[6],
            d = r[10];
          switch ((t = t || this._order)) {
            case "XYZ":
              (this._y = Math.asin(i(s, -1, 1))),
                Math.abs(s) < 0.9999999
                  ? ((this._x = Math.atan2(-h, d)),
                    (this._z = Math.atan2(-o, a)))
                  : ((this._x = Math.atan2(p, l)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-i(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(s, d)), (this._z = Math.atan2(c, l)))
                  : ((this._y = Math.atan2(-u, a)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(i(p, -1, 1))),
                Math.abs(p) < 0.9999999
                  ? ((this._y = Math.atan2(-u, d)),
                    (this._z = Math.atan2(-o, l)))
                  : ((this._y = 0), (this._z = Math.atan2(c, a)));
              break;
            case "ZYX":
              (this._y = Math.asin(-i(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._x = Math.atan2(p, d)), (this._z = Math.atan2(c, a)))
                  : ((this._x = 0), (this._z = Math.atan2(-o, l)));
              break;
            case "YZX":
              (this._z = Math.asin(i(c, -1, 1))),
                Math.abs(c) < 0.9999999
                  ? ((this._x = Math.atan2(-h, l)),
                    (this._y = Math.atan2(-u, a)))
                  : ((this._x = 0), (this._y = Math.atan2(s, d)));
              break;
            case "XZY":
              (this._z = Math.asin(-i(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(p, l)), (this._y = Math.atan2(s, a)))
                  : ((this._x = Math.atan2(-h, d)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  t
              );
          }
          return (this._order = t), !1 !== n && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, n) {
          return (
            Ae.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(Ae, t, n)
          );
        }
        setFromVector3(e, t) {
          return this.set(e.x, e.y, e.z, t || this._order);
        }
        reorder(e) {
          return Le.setFromEuler(this), this.setFromQuaternion(Le, e);
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._order === this._order
          );
        }
        fromArray(e) {
          return (
            (this._x = e[0]),
            (this._y = e[1]),
            (this._z = e[2]),
            void 0 !== e[3] && (this._order = e[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._order),
            e
          );
        }
        toVector3(e) {
          return e
            ? e.set(this._x, this._y, this._z)
            : new W(this._x, this._y, this._z);
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
      }
      (Ee.DefaultOrder = "XYZ"),
        (Ee.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
      const Ae = new ye(),
        Le = new G();
      class Pe {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = (1 << e) | 0;
        }
        enable(e) {
          this.mask |= (1 << e) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= (1 << e) | 0;
        }
        disable(e) {
          this.mask &= ~((1 << e) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return 0 != (this.mask & e.mask);
        }
      }
      let Re = 0;
      const ke = new W(),
        Ce = new G(),
        Oe = new ye(),
        Ne = new W(),
        Ie = new W(),
        De = new W(),
        je = new G(),
        Fe = new W(1, 0, 0),
        He = new W(0, 1, 0),
        Be = new W(0, 0, 1),
        ze = { type: "added" },
        Ue = { type: "removed" };
      function Ge() {
        Object.defineProperty(this, "id", { value: Re++ }),
          (this.uuid = O.generateUUID()),
          (this.name = ""),
          (this.type = "Object3D"),
          (this.parent = null),
          (this.children = []),
          (this.up = Ge.DefaultUp.clone());
        const e = new W(),
          t = new Ee(),
          n = new G(),
          i = new W(1, 1, 1);
        t._onChange(function () {
          n.setFromEuler(t, !1);
        }),
          n._onChange(function () {
            t.setFromQuaternion(n, void 0, !1);
          }),
          Object.defineProperties(this, {
            position: { configurable: !0, enumerable: !0, value: e },
            rotation: { configurable: !0, enumerable: !0, value: t },
            quaternion: { configurable: !0, enumerable: !0, value: n },
            scale: { configurable: !0, enumerable: !0, value: i },
            modelViewMatrix: { value: new ye() },
            normalMatrix: { value: new I() },
          }),
          (this.matrix = new ye()),
          (this.matrixWorld = new ye()),
          (this.matrixAutoUpdate = Ge.DefaultMatrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = !1),
          (this.layers = new Pe()),
          (this.visible = !0),
          (this.castShadow = !1),
          (this.receiveShadow = !1),
          (this.frustumCulled = !0),
          (this.renderOrder = 0),
          (this.animations = []),
          (this.userData = {});
      }
      (Ge.DefaultUp = new W(0, 1, 0)),
        (Ge.DefaultMatrixAutoUpdate = !0),
        (Ge.prototype = Object.assign(Object.create(R.prototype), {
          constructor: Ge,
          isObject3D: !0,
          onBeforeRender: function () {},
          onAfterRender: function () {},
          applyMatrix4: function (e) {
            this.matrixAutoUpdate && this.updateMatrix(),
              this.matrix.premultiply(e),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          },
          applyQuaternion: function (e) {
            return this.quaternion.premultiply(e), this;
          },
          setRotationFromAxisAngle: function (e, t) {
            this.quaternion.setFromAxisAngle(e, t);
          },
          setRotationFromEuler: function (e) {
            this.quaternion.setFromEuler(e, !0);
          },
          setRotationFromMatrix: function (e) {
            this.quaternion.setFromRotationMatrix(e);
          },
          setRotationFromQuaternion: function (e) {
            this.quaternion.copy(e);
          },
          rotateOnAxis: function (e, t) {
            return (
              Ce.setFromAxisAngle(e, t), this.quaternion.multiply(Ce), this
            );
          },
          rotateOnWorldAxis: function (e, t) {
            return (
              Ce.setFromAxisAngle(e, t), this.quaternion.premultiply(Ce), this
            );
          },
          rotateX: function (e) {
            return this.rotateOnAxis(Fe, e);
          },
          rotateY: function (e) {
            return this.rotateOnAxis(He, e);
          },
          rotateZ: function (e) {
            return this.rotateOnAxis(Be, e);
          },
          translateOnAxis: function (e, t) {
            return (
              ke.copy(e).applyQuaternion(this.quaternion),
              this.position.add(ke.multiplyScalar(t)),
              this
            );
          },
          translateX: function (e) {
            return this.translateOnAxis(Fe, e);
          },
          translateY: function (e) {
            return this.translateOnAxis(He, e);
          },
          translateZ: function (e) {
            return this.translateOnAxis(Be, e);
          },
          localToWorld: function (e) {
            return e.applyMatrix4(this.matrixWorld);
          },
          worldToLocal: function (e) {
            return e.applyMatrix4(Oe.copy(this.matrixWorld).invert());
          },
          lookAt: function (e, t, n) {
            e.isVector3 ? Ne.copy(e) : Ne.set(e, t, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1),
              Ie.setFromMatrixPosition(this.matrixWorld),
              this.isCamera || this.isLight
                ? Oe.lookAt(Ie, Ne, this.up)
                : Oe.lookAt(Ne, Ie, this.up),
              this.quaternion.setFromRotationMatrix(Oe),
              i &&
                (Oe.extractRotation(i.matrixWorld),
                Ce.setFromRotationMatrix(Oe),
                this.quaternion.premultiply(Ce.invert()));
          },
          add: function (e) {
            if (arguments.length > 1) {
              for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
              return this;
            }
            return e === this
              ? (console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  e
                ),
                this)
              : (e && e.isObject3D
                  ? (null !== e.parent && e.parent.remove(e),
                    (e.parent = this),
                    this.children.push(e),
                    e.dispatchEvent(ze))
                  : console.error(
                      "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                      e
                    ),
                this);
          },
          remove: function (e) {
            if (arguments.length > 1) {
              for (let e = 0; e < arguments.length; e++)
                this.remove(arguments[e]);
              return this;
            }
            const t = this.children.indexOf(e);
            return (
              -1 !== t &&
                ((e.parent = null),
                this.children.splice(t, 1),
                e.dispatchEvent(Ue)),
              this
            );
          },
          clear: function () {
            for (let e = 0; e < this.children.length; e++) {
              const t = this.children[e];
              (t.parent = null), t.dispatchEvent(Ue);
            }
            return (this.children.length = 0), this;
          },
          attach: function (e) {
            return (
              this.updateWorldMatrix(!0, !1),
              Oe.copy(this.matrixWorld).invert(),
              null !== e.parent &&
                (e.parent.updateWorldMatrix(!0, !1),
                Oe.multiply(e.parent.matrixWorld)),
              e.applyMatrix4(Oe),
              e.updateWorldMatrix(!1, !1),
              this.add(e),
              this
            );
          },
          getObjectById: function (e) {
            return this.getObjectByProperty("id", e);
          },
          getObjectByName: function (e) {
            return this.getObjectByProperty("name", e);
          },
          getObjectByProperty: function (e, t) {
            if (this[e] === t) return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
              const i = this.children[n].getObjectByProperty(e, t);
              if (void 0 !== i) return i;
            }
          },
          getWorldPosition: function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Object3D: .getWorldPosition() target is now required"
                ),
                (e = new W())),
              this.updateWorldMatrix(!0, !1),
              e.setFromMatrixPosition(this.matrixWorld)
            );
          },
          getWorldQuaternion: function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Object3D: .getWorldQuaternion() target is now required"
                ),
                (e = new G())),
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(Ie, e, De),
              e
            );
          },
          getWorldScale: function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Object3D: .getWorldScale() target is now required"
                ),
                (e = new W())),
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(Ie, je, e),
              e
            );
          },
          getWorldDirection: function (e) {
            void 0 === e &&
              (console.warn(
                "THREE.Object3D: .getWorldDirection() target is now required"
              ),
              (e = new W())),
              this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize();
          },
          raycast: function () {},
          traverse: function (e) {
            e(this);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
          },
          traverseVisible: function (e) {
            if (!1 === this.visible) return;
            e(this);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
          },
          traverseAncestors: function (e) {
            const t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e));
          },
          updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          },
          updateMatrixWorld: function (e) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || e) &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix
                    ),
                (this.matrixWorldNeedsUpdate = !1),
                (e = !0));
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
          },
          updateWorldMatrix: function (e, t) {
            const n = this.parent;
            if (
              (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
              this.matrixAutoUpdate && this.updateMatrix(),
              null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              !0 === t)
            ) {
              const e = this.children;
              for (let t = 0, n = e.length; t < n; t++)
                e[t].updateWorldMatrix(!1, !0);
            }
          },
          toJSON: function (e) {
            const t = void 0 === e || "string" == typeof e,
              n = {};
            t &&
              ((e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
              }),
              (n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON",
              }));
            const i = {};
            function r(t, n) {
              return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid;
            }
            if (
              ((i.uuid = this.uuid),
              (i.type = this.type),
              "" !== this.name && (i.name = this.name),
              !0 === this.castShadow && (i.castShadow = !0),
              !0 === this.receiveShadow && (i.receiveShadow = !0),
              !1 === this.visible && (i.visible = !1),
              !1 === this.frustumCulled && (i.frustumCulled = !1),
              0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
              "{}" !== JSON.stringify(this.userData) &&
                (i.userData = this.userData),
              (i.layers = this.layers.mask),
              (i.matrix = this.matrix.toArray()),
              !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
              this.isInstancedMesh &&
                ((i.type = "InstancedMesh"),
                (i.count = this.count),
                (i.instanceMatrix = this.instanceMatrix.toJSON())),
              this.isMesh || this.isLine || this.isPoints)
            ) {
              i.geometry = r(e.geometries, this.geometry);
              const t = this.geometry.parameters;
              if (void 0 !== t && void 0 !== t.shapes) {
                const n = t.shapes;
                if (Array.isArray(n))
                  for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    r(e.shapes, i);
                  }
                else r(e.shapes, n);
              }
            }
            if (
              (this.isSkinnedMesh &&
                ((i.bindMode = this.bindMode),
                (i.bindMatrix = this.bindMatrix.toArray()),
                void 0 !== this.skeleton &&
                  (r(e.skeletons, this.skeleton),
                  (i.skeleton = this.skeleton.uuid))),
              void 0 !== this.material)
            )
              if (Array.isArray(this.material)) {
                const t = [];
                for (let n = 0, i = this.material.length; n < i; n++)
                  t.push(r(e.materials, this.material[n]));
                i.material = t;
              } else i.material = r(e.materials, this.material);
            if (this.children.length > 0) {
              i.children = [];
              for (let t = 0; t < this.children.length; t++)
                i.children.push(this.children[t].toJSON(e).object);
            }
            if (this.animations.length > 0) {
              i.animations = [];
              for (let t = 0; t < this.animations.length; t++) {
                const n = this.animations[t];
                i.animations.push(r(e.animations, n));
              }
            }
            if (t) {
              const t = a(e.geometries),
                i = a(e.materials),
                r = a(e.textures),
                o = a(e.images),
                s = a(e.shapes),
                c = a(e.skeletons),
                l = a(e.animations);
              t.length > 0 && (n.geometries = t),
                i.length > 0 && (n.materials = i),
                r.length > 0 && (n.textures = r),
                o.length > 0 && (n.images = o),
                s.length > 0 && (n.shapes = s),
                c.length > 0 && (n.skeletons = c),
                l.length > 0 && (n.animations = l);
            }
            return (n.object = i), n;
            function a(e) {
              const t = [];
              for (const n in e) {
                const i = e[n];
                delete i.metadata, t.push(i);
              }
              return t;
            }
          },
          clone: function (e) {
            return new this.constructor().copy(this, e);
          },
          copy: function (e, t = !0) {
            if (
              ((this.name = e.name),
              this.up.copy(e.up),
              this.position.copy(e.position),
              (this.rotation.order = e.rotation.order),
              this.quaternion.copy(e.quaternion),
              this.scale.copy(e.scale),
              this.matrix.copy(e.matrix),
              this.matrixWorld.copy(e.matrixWorld),
              (this.matrixAutoUpdate = e.matrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
              (this.layers.mask = e.layers.mask),
              (this.visible = e.visible),
              (this.castShadow = e.castShadow),
              (this.receiveShadow = e.receiveShadow),
              (this.frustumCulled = e.frustumCulled),
              (this.renderOrder = e.renderOrder),
              (this.userData = JSON.parse(JSON.stringify(e.userData))),
              !0 === t)
            )
              for (let t = 0; t < e.children.length; t++) {
                const n = e.children[t];
                this.add(n.clone());
              }
            return this;
          },
        }));
      const We = new W(),
        Ve = new W(),
        qe = new I();
      class Xe {
        constructor(e, t) {
          Object.defineProperty(this, "isPlane", { value: !0 }),
            (this.normal = void 0 !== e ? e : new W(1, 0, 0)),
            (this.constant = void 0 !== t ? t : 0);
        }
        set(e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, n, i) {
          return this.normal.set(e, t, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return (
            this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(e, t, n) {
          const i = We.subVectors(n, t).cross(Ve.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(i, e), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Plane: .projectPoint() target is now required"
              ),
              (t = new W())),
            t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
          );
        }
        intersectLine(e, t) {
          void 0 === t &&
            (console.warn(
              "THREE.Plane: .intersectLine() target is now required"
            ),
            (t = new W()));
          const n = e.delta(We),
            i = this.normal.dot(n);
          if (0 === i)
            return 0 === this.distanceToPoint(e.start)
              ? t.copy(e.start)
              : void 0;
          const r = -(e.start.dot(this.normal) + this.constant) / i;
          return r < 0 || r > 1
            ? void 0
            : t.copy(n).multiplyScalar(r).add(e.start);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
          return (t < 0 && n > 0) || (n < 0 && t > 0);
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return (
            void 0 === e &&
              (console.warn(
                "THREE.Plane: .coplanarPoint() target is now required"
              ),
              (e = new W())),
            e.copy(this.normal).multiplyScalar(-this.constant)
          );
        }
        applyMatrix4(e, t) {
          const n = t || qe.getNormalMatrix(e),
            i = this.coplanarPoint(We).applyMatrix4(e),
            r = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -i.dot(r)), this;
        }
        translate(e) {
          return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
      }
      const Ye = new W(),
        Je = new W(),
        Ze = new W(),
        Qe = new W(),
        Ke = new W(),
        $e = new W(),
        et = new W(),
        tt = new W(),
        nt = new W(),
        it = new W();
      class rt {
        constructor(e, t, n) {
          (this.a = void 0 !== e ? e : new W()),
            (this.b = void 0 !== t ? t : new W()),
            (this.c = void 0 !== n ? n : new W());
        }
        static getNormal(e, t, n, i) {
          void 0 === i &&
            (console.warn(
              "THREE.Triangle: .getNormal() target is now required"
            ),
            (i = new W())),
            i.subVectors(n, t),
            Ye.subVectors(e, t),
            i.cross(Ye);
          const r = i.lengthSq();
          return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, i, r) {
          Ye.subVectors(i, t), Je.subVectors(n, t), Ze.subVectors(e, t);
          const a = Ye.dot(Ye),
            o = Ye.dot(Je),
            s = Ye.dot(Ze),
            c = Je.dot(Je),
            l = Je.dot(Ze),
            h = a * c - o * o;
          if (
            (void 0 === r &&
              (console.warn(
                "THREE.Triangle: .getBarycoord() target is now required"
              ),
              (r = new W())),
            0 === h)
          )
            return r.set(-2, -1, -1);
          const u = 1 / h,
            p = (c * s - o * l) * u,
            d = (a * l - o * s) * u;
          return r.set(1 - p - d, d, p);
        }
        static containsPoint(e, t, n, i) {
          return (
            this.getBarycoord(e, t, n, i, Qe),
            Qe.x >= 0 && Qe.y >= 0 && Qe.x + Qe.y <= 1
          );
        }
        static getUV(e, t, n, i, r, a, o, s) {
          return (
            this.getBarycoord(e, t, n, i, Qe),
            s.set(0, 0),
            s.addScaledVector(r, Qe.x),
            s.addScaledVector(a, Qe.y),
            s.addScaledVector(o, Qe.z),
            s
          );
        }
        static isFrontFacing(e, t, n, i) {
          return (
            Ye.subVectors(n, t), Je.subVectors(e, t), Ye.cross(Je).dot(i) < 0
          );
        }
        set(e, t, n) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, i) {
          return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return (
            Ye.subVectors(this.c, this.b),
            Je.subVectors(this.a, this.b),
            0.5 * Ye.cross(Je).length()
          );
        }
        getMidpoint(e) {
          return (
            void 0 === e &&
              (console.warn(
                "THREE.Triangle: .getMidpoint() target is now required"
              ),
              (e = new W())),
            e
              .addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3)
          );
        }
        getNormal(e) {
          return rt.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return (
            void 0 === e &&
              (console.warn(
                "THREE.Triangle: .getPlane() target is now required"
              ),
              (e = new Xe())),
            e.setFromCoplanarPoints(this.a, this.b, this.c)
          );
        }
        getBarycoord(e, t) {
          return rt.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getUV(e, t, n, i, r) {
          return rt.getUV(e, this.a, this.b, this.c, t, n, i, r);
        }
        containsPoint(e) {
          return rt.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return rt.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          void 0 === t &&
            (console.warn(
              "THREE.Triangle: .closestPointToPoint() target is now required"
            ),
            (t = new W()));
          const n = this.a,
            i = this.b,
            r = this.c;
          let a, o;
          Ke.subVectors(i, n), $e.subVectors(r, n), tt.subVectors(e, n);
          const s = Ke.dot(tt),
            c = $e.dot(tt);
          if (s <= 0 && c <= 0) return t.copy(n);
          nt.subVectors(e, i);
          const l = Ke.dot(nt),
            h = $e.dot(nt);
          if (l >= 0 && h <= l) return t.copy(i);
          const u = s * h - l * c;
          if (u <= 0 && s >= 0 && l <= 0)
            return (a = s / (s - l)), t.copy(n).addScaledVector(Ke, a);
          it.subVectors(e, r);
          const p = Ke.dot(it),
            d = $e.dot(it);
          if (d >= 0 && p <= d) return t.copy(r);
          const f = p * c - s * d;
          if (f <= 0 && c >= 0 && d <= 0)
            return (o = c / (c - d)), t.copy(n).addScaledVector($e, o);
          const m = l * d - p * h;
          if (m <= 0 && h - l >= 0 && p - d >= 0)
            return (
              et.subVectors(r, i),
              (o = (h - l) / (h - l + (p - d))),
              t.copy(i).addScaledVector(et, o)
            );
          const g = 1 / (m + f + u);
          return (
            (a = f * g),
            (o = u * g),
            t.copy(n).addScaledVector(Ke, a).addScaledVector($e, o)
          );
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      const at = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        ot = { h: 0, s: 0, l: 0 },
        st = { h: 0, s: 0, l: 0 };
      function ct(e, t, n) {
        return (
          n < 0 && (n += 1),
          n > 1 && (n -= 1),
          n < 1 / 6
            ? e + 6 * (t - e) * n
            : n < 0.5
            ? t
            : n < 2 / 3
            ? e + 6 * (t - e) * (2 / 3 - n)
            : e
        );
      }
      function lt(e) {
        return e < 0.04045
          ? 0.0773993808 * e
          : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
      }
      function ht(e) {
        return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
      }
      class ut {
        constructor(e, t, n) {
          return (
            Object.defineProperty(this, "isColor", { value: !0 }),
            void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
          );
        }
        set(e) {
          return (
            e && e.isColor
              ? this.copy(e)
              : "number" == typeof e
              ? this.setHex(e)
              : "string" == typeof e && this.setStyle(e),
            this
          );
        }
        setScalar(e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        }
        setHex(e) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (255 & e) / 255),
            this
          );
        }
        setRGB(e, t, n) {
          return (this.r = e), (this.g = t), (this.b = n), this;
        }
        setHSL(e, t, n) {
          if (
            ((e = O.euclideanModulo(e, 1)),
            (t = O.clamp(t, 0, 1)),
            (n = O.clamp(n, 0, 1)),
            0 === t)
          )
            this.r = this.g = this.b = n;
          else {
            const i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
              r = 2 * n - i;
            (this.r = ct(r, i, e + 1 / 3)),
              (this.g = ct(r, i, e)),
              (this.b = ct(r, i, e - 1 / 3));
          }
          return this;
        }
        setStyle(e) {
          function t(t) {
            void 0 !== t &&
              parseFloat(t) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + e + " will be ignored."
              );
          }
          let n;
          if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
            let e;
            const i = n[1],
              r = n[2];
            switch (i) {
              case "rgb":
              case "rgba":
                if (
                  (e =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      r
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(e[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(e[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(e[3], 10)) / 255),
                    t(e[4]),
                    this
                  );
                if (
                  (e =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      r
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(e[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(e[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(e[3], 10)) / 100),
                    t(e[4]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (e =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      r
                    ))
                ) {
                  const n = parseFloat(e[1]) / 360,
                    i = parseInt(e[2], 10) / 100,
                    r = parseInt(e[3], 10) / 100;
                  return t(e[4]), this.setHSL(n, i, r);
                }
            }
          } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const e = n[1],
              t = e.length;
            if (3 === t)
              return (
                (this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255),
                (this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255),
                (this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255),
                this
              );
            if (6 === t)
              return (
                (this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255),
                (this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255),
                (this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255),
                this
              );
          }
          return e && e.length > 0 ? this.setColorName(e) : this;
        }
        setColorName(e) {
          const t = at[e];
          return (
            void 0 !== t
              ? this.setHex(t)
              : console.warn("THREE.Color: Unknown color " + e),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        }
        copyGammaToLinear(e, t = 2) {
          return (
            (this.r = Math.pow(e.r, t)),
            (this.g = Math.pow(e.g, t)),
            (this.b = Math.pow(e.b, t)),
            this
          );
        }
        copyLinearToGamma(e, t = 2) {
          const n = t > 0 ? 1 / t : 1;
          return (
            (this.r = Math.pow(e.r, n)),
            (this.g = Math.pow(e.g, n)),
            (this.b = Math.pow(e.b, n)),
            this
          );
        }
        convertGammaToLinear(e) {
          return this.copyGammaToLinear(this, e), this;
        }
        convertLinearToGamma(e) {
          return this.copyLinearToGamma(this, e), this;
        }
        copySRGBToLinear(e) {
          return (
            (this.r = lt(e.r)), (this.g = lt(e.g)), (this.b = lt(e.b)), this
          );
        }
        copyLinearToSRGB(e) {
          return (
            (this.r = ht(e.r)), (this.g = ht(e.g)), (this.b = ht(e.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex() {
          return (
            ((255 * this.r) << 16) ^
            ((255 * this.g) << 8) ^
            ((255 * this.b) << 0)
          );
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(e) {
          void 0 === e &&
            (console.warn("THREE.Color: .getHSL() target is now required"),
            (e = { h: 0, s: 0, l: 0 }));
          const t = this.r,
            n = this.g,
            i = this.b,
            r = Math.max(t, n, i),
            a = Math.min(t, n, i);
          let o, s;
          const c = (a + r) / 2;
          if (a === r) (o = 0), (s = 0);
          else {
            const e = r - a;
            switch (((s = c <= 0.5 ? e / (r + a) : e / (2 - r - a)), r)) {
              case t:
                o = (n - i) / e + (n < i ? 6 : 0);
                break;
              case n:
                o = (i - t) / e + 2;
                break;
              case i:
                o = (t - n) / e + 4;
            }
            o /= 6;
          }
          return (e.h = o), (e.s = s), (e.l = c), e;
        }
        getStyle() {
          return (
            "rgb(" +
            ((255 * this.r) | 0) +
            "," +
            ((255 * this.g) | 0) +
            "," +
            ((255 * this.b) | 0) +
            ")"
          );
        }
        offsetHSL(e, t, n) {
          return (
            this.getHSL(ot),
            (ot.h += e),
            (ot.s += t),
            (ot.l += n),
            this.setHSL(ot.h, ot.s, ot.l),
            this
          );
        }
        add(e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        }
        addColors(e, t) {
          return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
          );
        }
        addScalar(e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        }
        sub(e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        }
        multiply(e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        }
        multiplyScalar(e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        }
        lerp(e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        }
        lerpColors(e, t, n) {
          return (
            (this.r = e.r + (t.r - e.r) * n),
            (this.g = e.g + (t.g - e.g) * n),
            (this.b = e.b + (t.b - e.b) * n),
            this
          );
        }
        lerpHSL(e, t) {
          this.getHSL(ot), e.getHSL(st);
          const n = O.lerp(ot.h, st.h, t),
            i = O.lerp(ot.s, st.s, t),
            r = O.lerp(ot.l, st.l, t);
          return this.setHSL(n, i, r), this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return (
            (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            !0 === e.normalized &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
      }
      (ut.NAMES = at),
        (ut.prototype.r = 1),
        (ut.prototype.g = 1),
        (ut.prototype.b = 1);
      class pt {
        constructor(e, t, n, i, r, a = 0) {
          (this.a = e),
            (this.b = t),
            (this.c = n),
            (this.normal = i && i.isVector3 ? i : new W()),
            (this.vertexNormals = Array.isArray(i) ? i : []),
            (this.color = r && r.isColor ? r : new ut()),
            (this.vertexColors = Array.isArray(r) ? r : []),
            (this.materialIndex = a);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.a = e.a),
            (this.b = e.b),
            (this.c = e.c),
            this.normal.copy(e.normal),
            this.color.copy(e.color),
            (this.materialIndex = e.materialIndex);
          for (let t = 0, n = e.vertexNormals.length; t < n; t++)
            this.vertexNormals[t] = e.vertexNormals[t].clone();
          for (let t = 0, n = e.vertexColors.length; t < n; t++)
            this.vertexColors[t] = e.vertexColors[t].clone();
          return this;
        }
      }
      let dt = 0;
      function ft() {
        Object.defineProperty(this, "id", { value: dt++ }),
          (this.uuid = O.generateUUID()),
          (this.name = ""),
          (this.type = "Material"),
          (this.fog = !0),
          (this.blending = 1),
          (this.side = 0),
          (this.flatShading = !1),
          (this.vertexColors = !1),
          (this.opacity = 1),
          (this.transparent = !1),
          (this.blendSrc = 204),
          (this.blendDst = 205),
          (this.blendEquation = e),
          (this.blendSrcAlpha = null),
          (this.blendDstAlpha = null),
          (this.blendEquationAlpha = null),
          (this.depthFunc = 3),
          (this.depthTest = !0),
          (this.depthWrite = !0),
          (this.stencilWriteMask = 255),
          (this.stencilFunc = 519),
          (this.stencilRef = 0),
          (this.stencilFuncMask = 255),
          (this.stencilFail = E),
          (this.stencilZFail = E),
          (this.stencilZPass = E),
          (this.stencilWrite = !1),
          (this.clippingPlanes = null),
          (this.clipIntersection = !1),
          (this.clipShadows = !1),
          (this.shadowSide = null),
          (this.colorWrite = !0),
          (this.precision = null),
          (this.polygonOffset = !1),
          (this.polygonOffsetFactor = 0),
          (this.polygonOffsetUnits = 0),
          (this.dithering = !1),
          (this.alphaTest = 0),
          (this.premultipliedAlpha = !1),
          (this.visible = !0),
          (this.toneMapped = !0),
          (this.userData = {}),
          (this.version = 0);
      }
      function mt(e) {
        ft.call(this),
          (this.type = "MeshBasicMaterial"),
          (this.color = new ut(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = 0),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          this.setValues(e);
      }
      (ft.prototype = Object.assign(Object.create(R.prototype), {
        constructor: ft,
        isMaterial: !0,
        onBeforeCompile: function () {},
        customProgramCacheKey: function () {
          return this.onBeforeCompile.toString();
        },
        setValues: function (e) {
          if (void 0 !== e)
            for (const t in e) {
              const n = e[t];
              if (void 0 === n) {
                console.warn(
                  "THREE.Material: '" + t + "' parameter is undefined."
                );
                continue;
              }
              if ("shading" === t) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = 1 === n);
                continue;
              }
              const i = this[t];
              void 0 !== i
                ? i && i.isColor
                  ? i.set(n)
                  : i && i.isVector3 && n && n.isVector3
                  ? i.copy(n)
                  : (this[t] = n)
                : console.warn(
                    "THREE." +
                      this.type +
                      ": '" +
                      t +
                      "' is not a property of this material."
                  );
            }
        },
        toJSON: function (e) {
          const t = void 0 === e || "string" == typeof e;
          t && (e = { textures: {}, images: {} });
          const n = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          function i(e) {
            const t = [];
            for (const n in e) {
              const i = e[n];
              delete i.metadata, t.push(i);
            }
            return t;
          }
          if (
            ((n.uuid = this.uuid),
            (n.type = this.type),
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              (n.lightMap = this.lightMap.toJSON(e).uuid),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(e).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(e).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(e).uuid),
              (n.reflectivity = this.reflectivity),
              (n.refractionRatio = this.refractionRatio),
              void 0 !== this.combine && (n.combine = this.combine),
              void 0 !== this.envMapIntensity &&
                (n.envMapIntensity = this.envMapIntensity)),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.size && (n.size = this.size),
            void 0 !== this.sizeAttenuation &&
              (n.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (n.blending = this.blending),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            0 !== this.side && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = this.transparent),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            (n.stencilWrite = this.stencilWrite),
            (n.stencilWriteMask = this.stencilWriteMask),
            (n.stencilFunc = this.stencilFunc),
            (n.stencilRef = this.stencilRef),
            (n.stencilFuncMask = this.stencilFuncMask),
            (n.stencilFail = this.stencilFail),
            (n.stencilZFail = this.stencilZFail),
            (n.stencilZPass = this.stencilZPass),
            this.rotation &&
              0 !== this.rotation &&
              (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth &&
              1 !== this.linewidth &&
              (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha &&
              (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap &&
              (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (n.morphTargets = !0),
            !0 === this.morphNormals && (n.morphNormals = !0),
            !0 === this.skinning && (n.skinning = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            "{}" !== JSON.stringify(this.userData) &&
              (n.userData = this.userData),
            t)
          ) {
            const t = i(e.textures),
              r = i(e.images);
            t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r);
          }
          return n;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (e) {
          (this.name = e.name),
            (this.fog = e.fog),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.flatShading = e.flatShading),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          const t = e.clippingPlanes;
          let n = null;
          if (null !== t) {
            const e = t.length;
            n = new Array(e);
            for (let i = 0; i !== e; ++i) n[i] = t[i].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      })),
        Object.defineProperty(ft.prototype, "needsUpdate", {
          set: function (e) {
            !0 === e && this.version++;
          },
        }),
        (mt.prototype = Object.create(ft.prototype)),
        (mt.prototype.constructor = mt),
        (mt.prototype.isMeshBasicMaterial = !0),
        (mt.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            this
          );
        });
      const gt = new W(),
        vt = new N();
      function yt(e, t, n) {
        if (Array.isArray(e))
          throw new TypeError(
            "THREE.BufferAttribute: array should be a Typed Array."
          );
        (this.name = ""),
          (this.array = e),
          (this.itemSize = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.normalized = !0 === n),
          (this.usage = A),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0);
      }
      function _t(e, t, n) {
        yt.call(this, new Int8Array(e), t, n);
      }
      function wt(e, t, n) {
        yt.call(this, new Uint8Array(e), t, n);
      }
      function xt(e, t, n) {
        yt.call(this, new Uint8ClampedArray(e), t, n);
      }
      function bt(e, t, n) {
        yt.call(this, new Int16Array(e), t, n);
      }
      function Mt(e, t, n) {
        yt.call(this, new Uint16Array(e), t, n);
      }
      function St(e, t, n) {
        yt.call(this, new Int32Array(e), t, n);
      }
      function Tt(e, t, n) {
        yt.call(this, new Uint32Array(e), t, n);
      }
      function Et(e, t, n) {
        yt.call(this, new Uint16Array(e), t, n);
      }
      function At(e, t, n) {
        yt.call(this, new Float32Array(e), t, n);
      }
      function Lt(e, t, n) {
        yt.call(this, new Float64Array(e), t, n);
      }
      function Pt(e) {
        if (0 === e.length) return -1 / 0;
        let t = e[0];
        for (let n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
        return t;
      }
      Object.defineProperty(yt.prototype, "needsUpdate", {
        set: function (e) {
          !0 === e && this.version++;
        },
      }),
        Object.assign(yt.prototype, {
          isBufferAttribute: !0,
          onUploadCallback: function () {},
          setUsage: function (e) {
            return (this.usage = e), this;
          },
          copy: function (e) {
            return (
              (this.name = e.name),
              (this.array = new e.array.constructor(e.array)),
              (this.itemSize = e.itemSize),
              (this.count = e.count),
              (this.normalized = e.normalized),
              (this.usage = e.usage),
              this
            );
          },
          copyAt: function (e, t, n) {
            (e *= this.itemSize), (n *= t.itemSize);
            for (let i = 0, r = this.itemSize; i < r; i++)
              this.array[e + i] = t.array[n + i];
            return this;
          },
          copyArray: function (e) {
            return this.array.set(e), this;
          },
          copyColorsArray: function (e) {
            const t = this.array;
            let n = 0;
            for (let i = 0, r = e.length; i < r; i++) {
              let r = e[i];
              void 0 === r &&
                (console.warn(
                  "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                  i
                ),
                (r = new ut())),
                (t[n++] = r.r),
                (t[n++] = r.g),
                (t[n++] = r.b);
            }
            return this;
          },
          copyVector2sArray: function (e) {
            const t = this.array;
            let n = 0;
            for (let i = 0, r = e.length; i < r; i++) {
              let r = e[i];
              void 0 === r &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                  i
                ),
                (r = new N())),
                (t[n++] = r.x),
                (t[n++] = r.y);
            }
            return this;
          },
          copyVector3sArray: function (e) {
            const t = this.array;
            let n = 0;
            for (let i = 0, r = e.length; i < r; i++) {
              let r = e[i];
              void 0 === r &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                  i
                ),
                (r = new W())),
                (t[n++] = r.x),
                (t[n++] = r.y),
                (t[n++] = r.z);
            }
            return this;
          },
          copyVector4sArray: function (e) {
            const t = this.array;
            let n = 0;
            for (let i = 0, r = e.length; i < r; i++) {
              let r = e[i];
              void 0 === r &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                  i
                ),
                (r = new z())),
                (t[n++] = r.x),
                (t[n++] = r.y),
                (t[n++] = r.z),
                (t[n++] = r.w);
            }
            return this;
          },
          applyMatrix3: function (e) {
            if (2 === this.itemSize)
              for (let t = 0, n = this.count; t < n; t++)
                vt.fromBufferAttribute(this, t),
                  vt.applyMatrix3(e),
                  this.setXY(t, vt.x, vt.y);
            else if (3 === this.itemSize)
              for (let t = 0, n = this.count; t < n; t++)
                gt.fromBufferAttribute(this, t),
                  gt.applyMatrix3(e),
                  this.setXYZ(t, gt.x, gt.y, gt.z);
            return this;
          },
          applyMatrix4: function (e) {
            for (let t = 0, n = this.count; t < n; t++)
              (gt.x = this.getX(t)),
                (gt.y = this.getY(t)),
                (gt.z = this.getZ(t)),
                gt.applyMatrix4(e),
                this.setXYZ(t, gt.x, gt.y, gt.z);
            return this;
          },
          applyNormalMatrix: function (e) {
            for (let t = 0, n = this.count; t < n; t++)
              (gt.x = this.getX(t)),
                (gt.y = this.getY(t)),
                (gt.z = this.getZ(t)),
                gt.applyNormalMatrix(e),
                this.setXYZ(t, gt.x, gt.y, gt.z);
            return this;
          },
          transformDirection: function (e) {
            for (let t = 0, n = this.count; t < n; t++)
              (gt.x = this.getX(t)),
                (gt.y = this.getY(t)),
                (gt.z = this.getZ(t)),
                gt.transformDirection(e),
                this.setXYZ(t, gt.x, gt.y, gt.z);
            return this;
          },
          set: function (e, t = 0) {
            return this.array.set(e, t), this;
          },
          getX: function (e) {
            return this.array[e * this.itemSize];
          },
          setX: function (e, t) {
            return (this.array[e * this.itemSize] = t), this;
          },
          getY: function (e) {
            return this.array[e * this.itemSize + 1];
          },
          setY: function (e, t) {
            return (this.array[e * this.itemSize + 1] = t), this;
          },
          getZ: function (e) {
            return this.array[e * this.itemSize + 2];
          },
          setZ: function (e, t) {
            return (this.array[e * this.itemSize + 2] = t), this;
          },
          getW: function (e) {
            return this.array[e * this.itemSize + 3];
          },
          setW: function (e, t) {
            return (this.array[e * this.itemSize + 3] = t), this;
          },
          setXY: function (e, t, n) {
            return (
              (e *= this.itemSize),
              (this.array[e + 0] = t),
              (this.array[e + 1] = n),
              this
            );
          },
          setXYZ: function (e, t, n, i) {
            return (
              (e *= this.itemSize),
              (this.array[e + 0] = t),
              (this.array[e + 1] = n),
              (this.array[e + 2] = i),
              this
            );
          },
          setXYZW: function (e, t, n, i, r) {
            return (
              (e *= this.itemSize),
              (this.array[e + 0] = t),
              (this.array[e + 1] = n),
              (this.array[e + 2] = i),
              (this.array[e + 3] = r),
              this
            );
          },
          onUpload: function (e) {
            return (this.onUploadCallback = e), this;
          },
          clone: function () {
            return new this.constructor(this.array, this.itemSize).copy(this);
          },
          toJSON: function () {
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.prototype.slice.call(this.array),
              normalized: this.normalized,
            };
          },
        }),
        (_t.prototype = Object.create(yt.prototype)),
        (_t.prototype.constructor = _t),
        (wt.prototype = Object.create(yt.prototype)),
        (wt.prototype.constructor = wt),
        (xt.prototype = Object.create(yt.prototype)),
        (xt.prototype.constructor = xt),
        (bt.prototype = Object.create(yt.prototype)),
        (bt.prototype.constructor = bt),
        (Mt.prototype = Object.create(yt.prototype)),
        (Mt.prototype.constructor = Mt),
        (St.prototype = Object.create(yt.prototype)),
        (St.prototype.constructor = St),
        (Tt.prototype = Object.create(yt.prototype)),
        (Tt.prototype.constructor = Tt),
        (Et.prototype = Object.create(yt.prototype)),
        (Et.prototype.constructor = Et),
        (Et.prototype.isFloat16BufferAttribute = !0),
        (At.prototype = Object.create(yt.prototype)),
        (At.prototype.constructor = At),
        (Lt.prototype = Object.create(yt.prototype)),
        (Lt.prototype.constructor = Lt);
      const Rt = {
        Int8Array,
        Uint8Array,
        Uint8ClampedArray:
          "undefined" != typeof Uint8ClampedArray
            ? Uint8ClampedArray
            : Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
      };
      function kt(e, t) {
        return new Rt[e](t);
      }
      let Ct = 0;
      const Ot = new ye(),
        Nt = new Ge(),
        It = new W(),
        Dt = new X(),
        jt = new X(),
        Ft = new W();
      function Ht() {
        Object.defineProperty(this, "id", { value: Ct++ }),
          (this.uuid = O.generateUUID()),
          (this.name = ""),
          (this.type = "BufferGeometry"),
          (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.morphTargetsRelative = !1),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.drawRange = { start: 0, count: 1 / 0 }),
          (this.userData = {});
      }
      Ht.prototype = Object.assign(Object.create(R.prototype), {
        constructor: Ht,
        isBufferGeometry: !0,
        getIndex: function () {
          return this.index;
        },
        setIndex: function (e) {
          return (
            Array.isArray(e)
              ? (this.index = new (Pt(e) > 65535 ? Tt : Mt)(e, 1))
              : (this.index = e),
            this
          );
        },
        getAttribute: function (e) {
          return this.attributes[e];
        },
        setAttribute: function (e, t) {
          return (this.attributes[e] = t), this;
        },
        deleteAttribute: function (e) {
          return delete this.attributes[e], this;
        },
        hasAttribute: function (e) {
          return void 0 !== this.attributes[e];
        },
        addGroup: function (e, t, n = 0) {
          this.groups.push({ start: e, count: t, materialIndex: n });
        },
        clearGroups: function () {
          this.groups = [];
        },
        setDrawRange: function (e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        },
        applyMatrix4: function (e) {
          const t = this.attributes.position;
          void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
          const n = this.attributes.normal;
          if (void 0 !== n) {
            const t = new I().getNormalMatrix(e);
            n.applyNormalMatrix(t), (n.needsUpdate = !0);
          }
          const i = this.attributes.tangent;
          return (
            void 0 !== i && (i.transformDirection(e), (i.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        },
        rotateX: function (e) {
          return Ot.makeRotationX(e), this.applyMatrix4(Ot), this;
        },
        rotateY: function (e) {
          return Ot.makeRotationY(e), this.applyMatrix4(Ot), this;
        },
        rotateZ: function (e) {
          return Ot.makeRotationZ(e), this.applyMatrix4(Ot), this;
        },
        translate: function (e, t, n) {
          return Ot.makeTranslation(e, t, n), this.applyMatrix4(Ot), this;
        },
        scale: function (e, t, n) {
          return Ot.makeScale(e, t, n), this.applyMatrix4(Ot), this;
        },
        lookAt: function (e) {
          return (
            Nt.lookAt(e), Nt.updateMatrix(), this.applyMatrix4(Nt.matrix), this
          );
        },
        center: function () {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(It).negate(),
            this.translate(It.x, It.y, It.z),
            this
          );
        },
        setFromPoints: function (e) {
          const t = [];
          for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n];
            t.push(i.x, i.y, i.z || 0);
          }
          return this.setAttribute("position", new At(t, 3)), this;
        },
        computeBoundingBox: function () {
          null === this.boundingBox && (this.boundingBox = new X());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingBox.set(
                new W(-1 / 0, -1 / 0, -1 / 0),
                new W(1 / 0, 1 / 0, 1 / 0)
              )
            );
          if (void 0 !== e) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                Dt.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (Ft.addVectors(this.boundingBox.min, Dt.min),
                      this.boundingBox.expandByPoint(Ft),
                      Ft.addVectors(this.boundingBox.max, Dt.max),
                      this.boundingBox.expandByPoint(Ft))
                    : (this.boundingBox.expandByPoint(Dt.min),
                      this.boundingBox.expandByPoint(Dt.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        },
        computeBoundingSphere: function () {
          null === this.boundingSphere && (this.boundingSphere = new le());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingSphere.set(new W(), 1 / 0)
            );
          if (e) {
            const n = this.boundingSphere.center;
            if ((Dt.setFromBufferAttribute(e), t))
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                jt.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (Ft.addVectors(Dt.min, jt.min),
                      Dt.expandByPoint(Ft),
                      Ft.addVectors(Dt.max, jt.max),
                      Dt.expandByPoint(Ft))
                    : (Dt.expandByPoint(jt.min), Dt.expandByPoint(jt.max));
              }
            Dt.getCenter(n);
            let i = 0;
            for (let t = 0, r = e.count; t < r; t++)
              Ft.fromBufferAttribute(e, t),
                (i = Math.max(i, n.distanceToSquared(Ft)));
            if (t)
              for (let r = 0, a = t.length; r < a; r++) {
                const a = t[r],
                  o = this.morphTargetsRelative;
                for (let t = 0, r = a.count; t < r; t++)
                  Ft.fromBufferAttribute(a, t),
                    o && (It.fromBufferAttribute(e, t), Ft.add(It)),
                    (i = Math.max(i, n.distanceToSquared(Ft)));
              }
            (this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        },
        computeFaceNormals: function () {},
        computeTangents: function () {
          const e = this.index,
            t = this.attributes;
          if (
            null === e ||
            void 0 === t.position ||
            void 0 === t.normal ||
            void 0 === t.uv
          )
            return void console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
          const n = e.array,
            i = t.position.array,
            r = t.normal.array,
            a = t.uv.array,
            o = i.length / 3;
          void 0 === t.tangent &&
            this.setAttribute("tangent", new yt(new Float32Array(4 * o), 4));
          const s = t.tangent.array,
            c = [],
            l = [];
          for (let e = 0; e < o; e++) (c[e] = new W()), (l[e] = new W());
          const h = new W(),
            u = new W(),
            p = new W(),
            d = new N(),
            f = new N(),
            m = new N(),
            g = new W(),
            v = new W();
          function y(e, t, n) {
            h.fromArray(i, 3 * e),
              u.fromArray(i, 3 * t),
              p.fromArray(i, 3 * n),
              d.fromArray(a, 2 * e),
              f.fromArray(a, 2 * t),
              m.fromArray(a, 2 * n),
              u.sub(h),
              p.sub(h),
              f.sub(d),
              m.sub(d);
            const r = 1 / (f.x * m.y - m.x * f.y);
            isFinite(r) &&
              (g
                .copy(u)
                .multiplyScalar(m.y)
                .addScaledVector(p, -f.y)
                .multiplyScalar(r),
              v
                .copy(p)
                .multiplyScalar(f.x)
                .addScaledVector(u, -m.x)
                .multiplyScalar(r),
              c[e].add(g),
              c[t].add(g),
              c[n].add(g),
              l[e].add(v),
              l[t].add(v),
              l[n].add(v));
          }
          let _ = this.groups;
          0 === _.length && (_ = [{ start: 0, count: n.length }]);
          for (let e = 0, t = _.length; e < t; ++e) {
            const t = _[e],
              i = t.start;
            for (let e = i, r = i + t.count; e < r; e += 3)
              y(n[e + 0], n[e + 1], n[e + 2]);
          }
          const w = new W(),
            x = new W(),
            b = new W(),
            M = new W();
          function S(e) {
            b.fromArray(r, 3 * e), M.copy(b);
            const t = c[e];
            w.copy(t),
              w.sub(b.multiplyScalar(b.dot(t))).normalize(),
              x.crossVectors(M, t);
            const n = x.dot(l[e]) < 0 ? -1 : 1;
            (s[4 * e] = w.x),
              (s[4 * e + 1] = w.y),
              (s[4 * e + 2] = w.z),
              (s[4 * e + 3] = n);
          }
          for (let e = 0, t = _.length; e < t; ++e) {
            const t = _[e],
              i = t.start;
            for (let e = i, r = i + t.count; e < r; e += 3)
              S(n[e + 0]), S(n[e + 1]), S(n[e + 2]);
          }
        },
        computeVertexNormals: function () {
          const e = this.index,
            t = this.getAttribute("position");
          if (void 0 !== t) {
            let n = this.getAttribute("normal");
            if (void 0 === n)
              (n = new yt(new Float32Array(3 * t.count), 3)),
                this.setAttribute("normal", n);
            else for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
            const i = new W(),
              r = new W(),
              a = new W(),
              o = new W(),
              s = new W(),
              c = new W(),
              l = new W(),
              h = new W();
            if (e)
              for (let u = 0, p = e.count; u < p; u += 3) {
                const p = e.getX(u + 0),
                  d = e.getX(u + 1),
                  f = e.getX(u + 2);
                i.fromBufferAttribute(t, p),
                  r.fromBufferAttribute(t, d),
                  a.fromBufferAttribute(t, f),
                  l.subVectors(a, r),
                  h.subVectors(i, r),
                  l.cross(h),
                  o.fromBufferAttribute(n, p),
                  s.fromBufferAttribute(n, d),
                  c.fromBufferAttribute(n, f),
                  o.add(l),
                  s.add(l),
                  c.add(l),
                  n.setXYZ(p, o.x, o.y, o.z),
                  n.setXYZ(d, s.x, s.y, s.z),
                  n.setXYZ(f, c.x, c.y, c.z);
              }
            else
              for (let e = 0, o = t.count; e < o; e += 3)
                i.fromBufferAttribute(t, e + 0),
                  r.fromBufferAttribute(t, e + 1),
                  a.fromBufferAttribute(t, e + 2),
                  l.subVectors(a, r),
                  h.subVectors(i, r),
                  l.cross(h),
                  n.setXYZ(e + 0, l.x, l.y, l.z),
                  n.setXYZ(e + 1, l.x, l.y, l.z),
                  n.setXYZ(e + 2, l.x, l.y, l.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        },
        merge: function (e, t) {
          if (!e || !e.isBufferGeometry)
            return void console.error(
              "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
              e
            );
          void 0 === t &&
            ((t = 0),
            console.warn(
              "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
            ));
          const n = this.attributes;
          for (const i in n) {
            if (void 0 === e.attributes[i]) continue;
            const r = n[i].array,
              a = e.attributes[i],
              o = a.array,
              s = a.itemSize * t,
              c = Math.min(o.length, r.length - s);
            for (let e = 0, t = s; e < c; e++, t++) r[t] = o[e];
          }
          return this;
        },
        normalizeNormals: function () {
          const e = this.attributes.normal;
          for (let t = 0, n = e.count; t < n; t++)
            Ft.fromBufferAttribute(e, t),
              Ft.normalize(),
              e.setXYZ(t, Ft.x, Ft.y, Ft.z);
        },
        toNonIndexed: function () {
          function e(e, t) {
            const n = e.array,
              i = e.itemSize,
              r = e.normalized,
              a = new n.constructor(t.length * i);
            let o = 0,
              s = 0;
            for (let e = 0, r = t.length; e < r; e++) {
              o = t[e] * i;
              for (let e = 0; e < i; e++) a[s++] = n[o++];
            }
            return new yt(a, i, r);
          }
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const t = new Ht(),
            n = this.index.array,
            i = this.attributes;
          for (const r in i) {
            const a = e(i[r], n);
            t.setAttribute(r, a);
          }
          const r = this.morphAttributes;
          for (const i in r) {
            const a = [],
              o = r[i];
            for (let t = 0, i = o.length; t < i; t++) {
              const i = e(o[t], n);
              a.push(i);
            }
            t.morphAttributes[i] = a;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const a = this.groups;
          for (let e = 0, n = a.length; e < n; e++) {
            const n = a[e];
            t.addGroup(n.start, n.count, n.materialIndex);
          }
          return t;
        },
        toJSON: function () {
          const e = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (e.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            const t = this.parameters;
            for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
            return e;
          }
          e.data = { attributes: {} };
          const t = this.index;
          null !== t &&
            (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array),
            });
          const n = this.attributes;
          for (const t in n) {
            const i = n[t],
              r = i.toJSON(e.data);
            "" !== i.name && (r.name = i.name), (e.data.attributes[t] = r);
          }
          const i = {};
          let r = !1;
          for (const t in this.morphAttributes) {
            const n = this.morphAttributes[t],
              a = [];
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t],
                r = i.toJSON(e.data);
              "" !== i.name && (r.name = i.name), a.push(r);
            }
            a.length > 0 && ((i[t] = a), (r = !0));
          }
          r &&
            ((e.data.morphAttributes = i),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
          const a = this.groups;
          a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
          const o = this.boundingSphere;
          return (
            null !== o &&
              (e.data.boundingSphere = {
                center: o.center.toArray(),
                radius: o.radius,
              }),
            e
          );
        },
        clone: function () {
          return new Ht().copy(this);
        },
        copy: function (e) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const t = {};
          this.name = e.name;
          const n = e.index;
          null !== n && this.setIndex(n.clone(t));
          const i = e.attributes;
          for (const e in i) {
            const n = i[e];
            this.setAttribute(e, n.clone(t));
          }
          const r = e.morphAttributes;
          for (const e in r) {
            const n = [],
              i = r[e];
            for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
            this.morphAttributes[e] = n;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const a = e.groups;
          for (let e = 0, t = a.length; e < t; e++) {
            const t = a[e];
            this.addGroup(t.start, t.count, t.materialIndex);
          }
          const o = e.boundingBox;
          null !== o && (this.boundingBox = o.clone());
          const s = e.boundingSphere;
          return (
            null !== s && (this.boundingSphere = s.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      });
      const Bt = new ye(),
        zt = new ve(),
        Ut = new le(),
        Gt = new W(),
        Wt = new W(),
        Vt = new W(),
        qt = new W(),
        Xt = new W(),
        Yt = new W(),
        Jt = new W(),
        Zt = new W(),
        Qt = new W(),
        Kt = new N(),
        $t = new N(),
        en = new N(),
        tn = new W(),
        nn = new W();
      function rn(e = new Ht(), t = new mt()) {
        Ge.call(this),
          (this.type = "Mesh"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      function an(e, t, n, i, r, a, o, s, c, l, h, u) {
        Gt.fromBufferAttribute(r, l),
          Wt.fromBufferAttribute(r, h),
          Vt.fromBufferAttribute(r, u);
        const p = e.morphTargetInfluences;
        if (t.morphTargets && a && p) {
          Jt.set(0, 0, 0), Zt.set(0, 0, 0), Qt.set(0, 0, 0);
          for (let e = 0, t = a.length; e < t; e++) {
            const t = p[e],
              n = a[e];
            0 !== t &&
              (qt.fromBufferAttribute(n, l),
              Xt.fromBufferAttribute(n, h),
              Yt.fromBufferAttribute(n, u),
              o
                ? (Jt.addScaledVector(qt, t),
                  Zt.addScaledVector(Xt, t),
                  Qt.addScaledVector(Yt, t))
                : (Jt.addScaledVector(qt.sub(Gt), t),
                  Zt.addScaledVector(Xt.sub(Wt), t),
                  Qt.addScaledVector(Yt.sub(Vt), t)));
          }
          Gt.add(Jt), Wt.add(Zt), Vt.add(Qt);
        }
        e.isSkinnedMesh &&
          (e.boneTransform(l, Gt),
          e.boneTransform(h, Wt),
          e.boneTransform(u, Vt));
        const d = (function (e, t, n, i, r, a, o, s) {
          let c;
          if (
            ((c =
              1 === t.side
                ? i.intersectTriangle(o, a, r, !0, s)
                : i.intersectTriangle(r, a, o, 2 !== t.side, s)),
            null === c)
          )
            return null;
          nn.copy(s), nn.applyMatrix4(e.matrixWorld);
          const l = n.ray.origin.distanceTo(nn);
          return l < n.near || l > n.far
            ? null
            : { distance: l, point: nn.clone(), object: e };
        })(e, t, n, i, Gt, Wt, Vt, tn);
        if (d) {
          s &&
            (Kt.fromBufferAttribute(s, l),
            $t.fromBufferAttribute(s, h),
            en.fromBufferAttribute(s, u),
            (d.uv = rt.getUV(tn, Gt, Wt, Vt, Kt, $t, en, new N()))),
            c &&
              (Kt.fromBufferAttribute(c, l),
              $t.fromBufferAttribute(c, h),
              en.fromBufferAttribute(c, u),
              (d.uv2 = rt.getUV(tn, Gt, Wt, Vt, Kt, $t, en, new N())));
          const e = new pt(l, h, u);
          rt.getNormal(Gt, Wt, Vt, e.normal), (d.face = e);
        }
        return d;
      }
      rn.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: rn,
        isMesh: !0,
        copy: function (e) {
          return (
            Ge.prototype.copy.call(this, e),
            void 0 !== e.morphTargetInfluences &&
              (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                e.morphTargetDictionary
              )),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        },
        updateMorphTargets: function () {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const e = t[n[0]];
              if (void 0 !== e) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t].name || String(t);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = t);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            void 0 !== t &&
              t.length > 0 &&
              console.error(
                "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        },
        raycast: function (e, t) {
          const n = this.geometry,
            i = this.material,
            r = this.matrixWorld;
          if (void 0 === i) return;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            Ut.copy(n.boundingSphere),
            Ut.applyMatrix4(r),
            !1 === e.ray.intersectsSphere(Ut))
          )
            return;
          if (
            (Bt.copy(r).invert(),
            zt.copy(e.ray).applyMatrix4(Bt),
            null !== n.boundingBox && !1 === zt.intersectsBox(n.boundingBox))
          )
            return;
          let a;
          if (n.isBufferGeometry) {
            const r = n.index,
              o = n.attributes.position,
              s = n.morphAttributes.position,
              c = n.morphTargetsRelative,
              l = n.attributes.uv,
              h = n.attributes.uv2,
              u = n.groups,
              p = n.drawRange;
            if (null !== r)
              if (Array.isArray(i))
                for (let n = 0, d = u.length; n < d; n++) {
                  const d = u[n],
                    f = i[d.materialIndex];
                  for (
                    let n = Math.max(d.start, p.start),
                      i = Math.min(d.start + d.count, p.start + p.count);
                    n < i;
                    n += 3
                  ) {
                    const i = r.getX(n),
                      u = r.getX(n + 1),
                      p = r.getX(n + 2);
                    (a = an(this, f, e, zt, o, s, c, l, h, i, u, p)),
                      a &&
                        ((a.faceIndex = Math.floor(n / 3)),
                        (a.face.materialIndex = d.materialIndex),
                        t.push(a));
                  }
                }
              else
                for (
                  let n = Math.max(0, p.start),
                    u = Math.min(r.count, p.start + p.count);
                  n < u;
                  n += 3
                ) {
                  const u = r.getX(n),
                    p = r.getX(n + 1),
                    d = r.getX(n + 2);
                  (a = an(this, i, e, zt, o, s, c, l, h, u, p, d)),
                    a && ((a.faceIndex = Math.floor(n / 3)), t.push(a));
                }
            else if (void 0 !== o)
              if (Array.isArray(i))
                for (let n = 0, r = u.length; n < r; n++) {
                  const r = u[n],
                    d = i[r.materialIndex];
                  for (
                    let n = Math.max(r.start, p.start),
                      i = Math.min(r.start + r.count, p.start + p.count);
                    n < i;
                    n += 3
                  )
                    (a = an(this, d, e, zt, o, s, c, l, h, n, n + 1, n + 2)),
                      a &&
                        ((a.faceIndex = Math.floor(n / 3)),
                        (a.face.materialIndex = r.materialIndex),
                        t.push(a));
                }
              else
                for (
                  let n = Math.max(0, p.start),
                    r = Math.min(o.count, p.start + p.count);
                  n < r;
                  n += 3
                )
                  (a = an(this, i, e, zt, o, s, c, l, h, n, n + 1, n + 2)),
                    a && ((a.faceIndex = Math.floor(n / 3)), t.push(a));
          } else
            n.isGeometry &&
              console.error(
                "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        },
      });
      class on extends Ht {
        constructor(e = 1, t = 1, n = 1, i = 1, r = 1, a = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: a,
            });
          const o = this;
          (i = Math.floor(i)), (r = Math.floor(r)), (a = Math.floor(a));
          const s = [],
            c = [],
            l = [],
            h = [];
          let u = 0,
            p = 0;
          function d(e, t, n, i, r, a, d, f, m, g, v) {
            const y = a / m,
              _ = d / g,
              w = a / 2,
              x = d / 2,
              b = f / 2,
              M = m + 1,
              S = g + 1;
            let T = 0,
              E = 0;
            const A = new W();
            for (let a = 0; a < S; a++) {
              const o = a * _ - x;
              for (let s = 0; s < M; s++) {
                const u = s * y - w;
                (A[e] = u * i),
                  (A[t] = o * r),
                  (A[n] = b),
                  c.push(A.x, A.y, A.z),
                  (A[e] = 0),
                  (A[t] = 0),
                  (A[n] = f > 0 ? 1 : -1),
                  l.push(A.x, A.y, A.z),
                  h.push(s / m),
                  h.push(1 - a / g),
                  (T += 1);
              }
            }
            for (let e = 0; e < g; e++)
              for (let t = 0; t < m; t++) {
                const n = u + t + M * e,
                  i = u + t + M * (e + 1),
                  r = u + (t + 1) + M * (e + 1),
                  a = u + (t + 1) + M * e;
                s.push(n, i, a), s.push(i, r, a), (E += 6);
              }
            o.addGroup(p, E, v), (p += E), (u += T);
          }
          d("z", "y", "x", -1, -1, n, t, e, a, r, 0),
            d("z", "y", "x", 1, -1, n, t, -e, a, r, 1),
            d("x", "z", "y", 1, 1, e, n, t, i, a, 2),
            d("x", "z", "y", 1, -1, e, n, -t, i, a, 3),
            d("x", "y", "z", 1, -1, e, t, n, i, r, 4),
            d("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
            this.setIndex(s),
            this.setAttribute("position", new At(c, 3)),
            this.setAttribute("normal", new At(l, 3)),
            this.setAttribute("uv", new At(h, 2));
        }
      }
      function sn(e) {
        const t = {};
        for (const n in e) {
          t[n] = {};
          for (const i in e[n]) {
            const r = e[n][i];
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture)
              ? (t[n][i] = r.clone())
              : Array.isArray(r)
              ? (t[n][i] = r.slice())
              : (t[n][i] = r);
          }
        }
        return t;
      }
      function cn(e) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
          const i = sn(e[n]);
          for (const e in i) t[e] = i[e];
        }
        return t;
      }
      const ln = { clone: sn, merge: cn };
      function hn(e) {
        ft.call(this),
          (this.type = "ShaderMaterial"),
          (this.defines = {}),
          (this.uniforms = {}),
          (this.vertexShader =
            "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
          (this.fragmentShader =
            "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
          (this.linewidth = 1),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          (this.clipping = !1),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          (this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1,
          }),
          (this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0],
          }),
          (this.index0AttributeName = void 0),
          (this.uniformsNeedUpdate = !1),
          (this.glslVersion = null),
          void 0 !== e &&
            (void 0 !== e.attributes &&
              console.error(
                "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
              ),
            this.setValues(e));
      }
      function un() {
        Ge.call(this),
          (this.type = "Camera"),
          (this.matrixWorldInverse = new ye()),
          (this.projectionMatrix = new ye()),
          (this.projectionMatrixInverse = new ye());
      }
      function pn(e = 50, t = 1, n = 0.1, i = 2e3) {
        un.call(this),
          (this.type = "PerspectiveCamera"),
          (this.fov = e),
          (this.zoom = 1),
          (this.near = n),
          (this.far = i),
          (this.focus = 10),
          (this.aspect = t),
          (this.view = null),
          (this.filmGauge = 35),
          (this.filmOffset = 0),
          this.updateProjectionMatrix();
      }
      (hn.prototype = Object.create(ft.prototype)),
        (hn.prototype.constructor = hn),
        (hn.prototype.isShaderMaterial = !0),
        (hn.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = sn(e.uniforms)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
          );
        }),
        (hn.prototype.toJSON = function (e) {
          const t = ft.prototype.toJSON.call(this, e);
          (t.glslVersion = this.glslVersion), (t.uniforms = {});
          for (const n in this.uniforms) {
            const i = this.uniforms[n].value;
            i && i.isTexture
              ? (t.uniforms[n] = { type: "t", value: i.toJSON(e).uuid })
              : i && i.isColor
              ? (t.uniforms[n] = { type: "c", value: i.getHex() })
              : i && i.isVector2
              ? (t.uniforms[n] = { type: "v2", value: i.toArray() })
              : i && i.isVector3
              ? (t.uniforms[n] = { type: "v3", value: i.toArray() })
              : i && i.isVector4
              ? (t.uniforms[n] = { type: "v4", value: i.toArray() })
              : i && i.isMatrix3
              ? (t.uniforms[n] = { type: "m3", value: i.toArray() })
              : i && i.isMatrix4
              ? (t.uniforms[n] = { type: "m4", value: i.toArray() })
              : (t.uniforms[n] = { value: i });
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader);
          const n = {};
          for (const e in this.extensions)
            !0 === this.extensions[e] && (n[e] = !0);
          return Object.keys(n).length > 0 && (t.extensions = n), t;
        }),
        (un.prototype = Object.assign(Object.create(Ge.prototype), {
          constructor: un,
          isCamera: !0,
          copy: function (e, t) {
            return (
              Ge.prototype.copy.call(this, e, t),
              this.matrixWorldInverse.copy(e.matrixWorldInverse),
              this.projectionMatrix.copy(e.projectionMatrix),
              this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
              this
            );
          },
          getWorldDirection: function (e) {
            void 0 === e &&
              (console.warn(
                "THREE.Camera: .getWorldDirection() target is now required"
              ),
              (e = new W())),
              this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize();
          },
          updateMatrixWorld: function (e) {
            Ge.prototype.updateMatrixWorld.call(this, e),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          },
          updateWorldMatrix: function (e, t) {
            Ge.prototype.updateWorldMatrix.call(this, e, t),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
        })),
        (pn.prototype = Object.assign(Object.create(un.prototype), {
          constructor: pn,
          isPerspectiveCamera: !0,
          copy: function (e, t) {
            return (
              un.prototype.copy.call(this, e, t),
              (this.fov = e.fov),
              (this.zoom = e.zoom),
              (this.near = e.near),
              (this.far = e.far),
              (this.focus = e.focus),
              (this.aspect = e.aspect),
              (this.view = null === e.view ? null : Object.assign({}, e.view)),
              (this.filmGauge = e.filmGauge),
              (this.filmOffset = e.filmOffset),
              this
            );
          },
          setFocalLength: function (e) {
            const t = (0.5 * this.getFilmHeight()) / e;
            (this.fov = 2 * O.RAD2DEG * Math.atan(t)),
              this.updateProjectionMatrix();
          },
          getFocalLength: function () {
            const e = Math.tan(0.5 * O.DEG2RAD * this.fov);
            return (0.5 * this.getFilmHeight()) / e;
          },
          getEffectiveFOV: function () {
            return (
              2 *
              O.RAD2DEG *
              Math.atan(Math.tan(0.5 * O.DEG2RAD * this.fov) / this.zoom)
            );
          },
          getFilmWidth: function () {
            return this.filmGauge * Math.min(this.aspect, 1);
          },
          getFilmHeight: function () {
            return this.filmGauge / Math.max(this.aspect, 1);
          },
          setViewOffset: function (e, t, n, i, r, a) {
            (this.aspect = e / t),
              null === this.view &&
                (this.view = {
                  enabled: !0,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1,
                }),
              (this.view.enabled = !0),
              (this.view.fullWidth = e),
              (this.view.fullHeight = t),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = a),
              this.updateProjectionMatrix();
          },
          clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          },
          updateProjectionMatrix: function () {
            const e = this.near;
            let t = (e * Math.tan(0.5 * O.DEG2RAD * this.fov)) / this.zoom,
              n = 2 * t,
              i = this.aspect * n,
              r = -0.5 * i;
            const a = this.view;
            if (null !== this.view && this.view.enabled) {
              const e = a.fullWidth,
                o = a.fullHeight;
              (r += (a.offsetX * i) / e),
                (t -= (a.offsetY * n) / o),
                (i *= a.width / e),
                (n *= a.height / o);
            }
            const o = this.filmOffset;
            0 !== o && (r += (e * o) / this.getFilmWidth()),
              this.projectionMatrix.makePerspective(
                r,
                r + i,
                t,
                t - n,
                e,
                this.far
              ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          },
          toJSON: function (e) {
            const t = Ge.prototype.toJSON.call(this, e);
            return (
              (t.object.fov = this.fov),
              (t.object.zoom = this.zoom),
              (t.object.near = this.near),
              (t.object.far = this.far),
              (t.object.focus = this.focus),
              (t.object.aspect = this.aspect),
              null !== this.view &&
                (t.object.view = Object.assign({}, this.view)),
              (t.object.filmGauge = this.filmGauge),
              (t.object.filmOffset = this.filmOffset),
              t
            );
          },
        }));
      const dn = 90;
      function fn(e, t, n) {
        if (
          (Ge.call(this),
          (this.type = "CubeCamera"),
          !0 !== n.isWebGLCubeRenderTarget)
        )
          return void console.error(
            "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
          );
        this.renderTarget = n;
        const i = new pn(dn, 1, e, t);
        (i.layers = this.layers),
          i.up.set(0, -1, 0),
          i.lookAt(new W(1, 0, 0)),
          this.add(i);
        const r = new pn(dn, 1, e, t);
        (r.layers = this.layers),
          r.up.set(0, -1, 0),
          r.lookAt(new W(-1, 0, 0)),
          this.add(r);
        const a = new pn(dn, 1, e, t);
        (a.layers = this.layers),
          a.up.set(0, 0, 1),
          a.lookAt(new W(0, 1, 0)),
          this.add(a);
        const o = new pn(dn, 1, e, t);
        (o.layers = this.layers),
          o.up.set(0, 0, -1),
          o.lookAt(new W(0, -1, 0)),
          this.add(o);
        const s = new pn(dn, 1, e, t);
        (s.layers = this.layers),
          s.up.set(0, -1, 0),
          s.lookAt(new W(0, 0, 1)),
          this.add(s);
        const c = new pn(dn, 1, e, t);
        (c.layers = this.layers),
          c.up.set(0, -1, 0),
          c.lookAt(new W(0, 0, -1)),
          this.add(c),
          (this.update = function (e, t) {
            null === this.parent && this.updateMatrixWorld();
            const l = e.xr.enabled,
              h = e.getRenderTarget();
            e.xr.enabled = !1;
            const u = n.texture.generateMipmaps;
            (n.texture.generateMipmaps = !1),
              e.setRenderTarget(n, 0),
              e.render(t, i),
              e.setRenderTarget(n, 1),
              e.render(t, r),
              e.setRenderTarget(n, 2),
              e.render(t, a),
              e.setRenderTarget(n, 3),
              e.render(t, o),
              e.setRenderTarget(n, 4),
              e.render(t, s),
              (n.texture.generateMipmaps = u),
              e.setRenderTarget(n, 5),
              e.render(t, c),
              e.setRenderTarget(h),
              (e.xr.enabled = l);
          });
      }
      function mn(e, t, n, i, r, a, o, s, c, l) {
        (e = void 0 !== e ? e : []),
          (t = void 0 !== t ? t : 301),
          (o = void 0 !== o ? o : f),
          H.call(this, e, t, n, i, r, a, o, s, c, l),
          (this.flipY = !1),
          (this._needsFlipEnvMap = !0);
      }
      (fn.prototype = Object.create(Ge.prototype)),
        (fn.prototype.constructor = fn),
        (mn.prototype = Object.create(H.prototype)),
        (mn.prototype.constructor = mn),
        (mn.prototype.isCubeTexture = !0),
        Object.defineProperty(mn.prototype, "images", {
          get: function () {
            return this.image;
          },
          set: function (e) {
            this.image = e;
          },
        });
      class gn extends U {
        constructor(e, t, n) {
          Number.isInteger(t) &&
            (console.warn(
              "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
            ),
            (t = n)),
            super(e, e, t),
            Object.defineProperty(this, "isWebGLCubeRenderTarget", {
              value: !0,
            }),
            (t = t || {}),
            (this.texture = new mn(
              void 0,
              t.mapping,
              t.wrapS,
              t.wrapT,
              t.magFilter,
              t.minFilter,
              t.format,
              t.type,
              t.anisotropy,
              t.encoding
            )),
            (this.texture._needsFlipEnvMap = !1);
        }
        fromEquirectangularTexture(e, t) {
          (this.texture.type = t.type),
            (this.texture.format = m),
            (this.texture.encoding = t.encoding),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          const n = { tEquirect: { value: null } },
            i =
              "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            r =
              "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
            a = new on(5, 5, 5),
            o = new hn({
              name: "CubemapFromEquirect",
              uniforms: sn(n),
              vertexShader: i,
              fragmentShader: r,
              side: 1,
              blending: 0,
            });
          o.uniforms.tEquirect.value = t;
          const l = new rn(a, o),
            h = t.minFilter;
          return (
            t.minFilter === c && (t.minFilter = s),
            new fn(1, 10, this).update(e, l),
            (t.minFilter = h),
            l.geometry.dispose(),
            l.material.dispose(),
            this
          );
        }
        clear(e, t, n, i) {
          const r = e.getRenderTarget();
          for (let r = 0; r < 6; r++)
            e.setRenderTarget(this, r), e.clear(t, n, i);
          e.setRenderTarget(r);
        }
      }
      function vn(e, t, n, i, a, o, s, c, l, h, u, p) {
        H.call(this, null, o, s, c, l, h, i, a, u, p),
          (this.image = { data: e || null, width: t || 1, height: n || 1 }),
          (this.magFilter = void 0 !== l ? l : r),
          (this.minFilter = void 0 !== h ? h : r),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1),
          (this.needsUpdate = !0);
      }
      (vn.prototype = Object.create(H.prototype)),
        (vn.prototype.constructor = vn),
        (vn.prototype.isDataTexture = !0);
      const yn = new le(),
        _n = new W();
      class wn {
        constructor(e, t, n, i, r, a) {
          this.planes = [
            void 0 !== e ? e : new Xe(),
            void 0 !== t ? t : new Xe(),
            void 0 !== n ? n : new Xe(),
            void 0 !== i ? i : new Xe(),
            void 0 !== r ? r : new Xe(),
            void 0 !== a ? a : new Xe(),
          ];
        }
        set(e, t, n, i, r, a) {
          const o = this.planes;
          return (
            o[0].copy(e),
            o[1].copy(t),
            o[2].copy(n),
            o[3].copy(i),
            o[4].copy(r),
            o[5].copy(a),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
          return this;
        }
        setFromProjectionMatrix(e) {
          const t = this.planes,
            n = e.elements,
            i = n[0],
            r = n[1],
            a = n[2],
            o = n[3],
            s = n[4],
            c = n[5],
            l = n[6],
            h = n[7],
            u = n[8],
            p = n[9],
            d = n[10],
            f = n[11],
            m = n[12],
            g = n[13],
            v = n[14],
            y = n[15];
          return (
            t[0].setComponents(o - i, h - s, f - u, y - m).normalize(),
            t[1].setComponents(o + i, h + s, f + u, y + m).normalize(),
            t[2].setComponents(o + r, h + c, f + p, y + g).normalize(),
            t[3].setComponents(o - r, h - c, f - p, y - g).normalize(),
            t[4].setComponents(o - a, h - l, f - d, y - v).normalize(),
            t[5].setComponents(o + a, h + l, f + d, y + v).normalize(),
            this
          );
        }
        intersectsObject(e) {
          const t = e.geometry;
          return (
            null === t.boundingSphere && t.computeBoundingSphere(),
            yn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(yn)
          );
        }
        intersectsSprite(e) {
          return (
            yn.center.set(0, 0, 0),
            (yn.radius = 0.7071067811865476),
            yn.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(yn)
          );
        }
        intersectsSphere(e) {
          const t = this.planes,
            n = e.center,
            i = -e.radius;
          for (let e = 0; e < 6; e++)
            if (t[e].distanceToPoint(n) < i) return !1;
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (
              ((_n.x = i.normal.x > 0 ? e.max.x : e.min.x),
              (_n.y = i.normal.y > 0 ? e.max.y : e.min.y),
              (_n.z = i.normal.z > 0 ? e.max.z : e.min.z),
              i.distanceToPoint(_n) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0) return !1;
          return !0;
        }
      }
      function xn() {
        let e = null,
          t = !1,
          n = null,
          i = null;
        function r(t, a) {
          n(t, a), (i = e.requestAnimationFrame(r));
        }
        return {
          start: function () {
            !0 !== t &&
              null !== n &&
              ((i = e.requestAnimationFrame(r)), (t = !0));
          },
          stop: function () {
            e.cancelAnimationFrame(i), (t = !1);
          },
          setAnimationLoop: function (e) {
            n = e;
          },
          setContext: function (t) {
            e = t;
          },
        };
      }
      function bn(e, t) {
        const n = t.isWebGL2,
          i = new WeakMap();
        return {
          get: function (e) {
            return e.isInterleavedBufferAttribute && (e = e.data), i.get(e);
          },
          remove: function (t) {
            t.isInterleavedBufferAttribute && (t = t.data);
            const n = i.get(t);
            n && (e.deleteBuffer(n.buffer), i.delete(t));
          },
          update: function (t, r) {
            if (t.isGLBufferAttribute) {
              const e = i.get(t);
              return void (
                (!e || e.version < t.version) &&
                i.set(t, {
                  buffer: t.buffer,
                  type: t.type,
                  bytesPerElement: t.elementSize,
                  version: t.version,
                })
              );
            }
            t.isInterleavedBufferAttribute && (t = t.data);
            const a = i.get(t);
            void 0 === a
              ? i.set(
                  t,
                  (function (t, i) {
                    const r = t.array,
                      a = t.usage,
                      o = e.createBuffer();
                    e.bindBuffer(i, o),
                      e.bufferData(i, r, a),
                      t.onUploadCallback();
                    let s = 5126;
                    return (
                      r instanceof Float32Array
                        ? (s = 5126)
                        : r instanceof Float64Array
                        ? console.warn(
                            "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                          )
                        : r instanceof Uint16Array
                        ? t.isFloat16BufferAttribute
                          ? n
                            ? (s = 5131)
                            : console.warn(
                                "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                              )
                          : (s = 5123)
                        : r instanceof Int16Array
                        ? (s = 5122)
                        : r instanceof Uint32Array
                        ? (s = 5125)
                        : r instanceof Int32Array
                        ? (s = 5124)
                        : r instanceof Int8Array
                        ? (s = 5120)
                        : r instanceof Uint8Array && (s = 5121),
                      {
                        buffer: o,
                        type: s,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: t.version,
                      }
                    );
                  })(t, r)
                )
              : a.version < t.version &&
                ((function (t, i, r) {
                  const a = i.array,
                    o = i.updateRange;
                  e.bindBuffer(r, t),
                    -1 === o.count
                      ? e.bufferSubData(r, 0, a)
                      : (n
                          ? e.bufferSubData(
                              r,
                              o.offset * a.BYTES_PER_ELEMENT,
                              a,
                              o.offset,
                              o.count
                            )
                          : e.bufferSubData(
                              r,
                              o.offset * a.BYTES_PER_ELEMENT,
                              a.subarray(o.offset, o.offset + o.count)
                            ),
                        (o.count = -1));
                })(a.buffer, t, r),
                (a.version = t.version));
          },
        };
      }
      class Mn extends Ht {
        constructor(e = 1, t = 1, n = 1, i = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              widthSegments: n,
              heightSegments: i,
            });
          const r = e / 2,
            a = t / 2,
            o = Math.floor(n),
            s = Math.floor(i),
            c = o + 1,
            l = s + 1,
            h = e / o,
            u = t / s,
            p = [],
            d = [],
            f = [],
            m = [];
          for (let e = 0; e < l; e++) {
            const t = e * u - a;
            for (let n = 0; n < c; n++) {
              const i = n * h - r;
              d.push(i, -t, 0),
                f.push(0, 0, 1),
                m.push(n / o),
                m.push(1 - e / s);
            }
          }
          for (let e = 0; e < s; e++)
            for (let t = 0; t < o; t++) {
              const n = t + c * e,
                i = t + c * (e + 1),
                r = t + 1 + c * (e + 1),
                a = t + 1 + c * e;
              p.push(n, i, a), p.push(i, r, a);
            }
          this.setIndex(p),
            this.setAttribute("position", new At(d, 3)),
            this.setAttribute("normal", new At(f, 3)),
            this.setAttribute("uv", new At(m, 2));
        }
      }
      const Sn = {
          alphamap_fragment:
            "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
          alphamap_pars_fragment:
            "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          alphatest_fragment:
            "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
          aomap_fragment:
            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
          aomap_pars_fragment:
            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          begin_vertex: "vec3 transformed = vec3( position );",
          beginnormal_vertex:
            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          bsdfs:
            "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
          bumpmap_pars_fragment:
            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          clipping_planes_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
          clipping_planes_pars_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          clipping_planes_pars_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          clipping_planes_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          color_fragment:
            "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
          color_pars_fragment:
            "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
          color_pars_vertex:
            "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_vertex:
            "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
          common:
            "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
          cube_uv_reflection_fragment:
            "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
          defaultnormal_vertex:
            "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          displacementmap_pars_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          displacementmap_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
          emissivemap_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          emissivemap_pars_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          encodings_fragment:
            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          encodings_pars_fragment:
            "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
          envmap_fragment:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          envmap_common_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
          envmap_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          envmap_pars_vertex:
            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          envmap_physical_pars_fragment:
            "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
          envmap_vertex:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
          fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
          fog_fragment:
            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          fog_pars_fragment:
            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          gradientmap_pars_fragment:
            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
          lightmap_fragment:
            "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
          lightmap_pars_fragment:
            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          lights_lambert_vertex:
            "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
          lights_pars_begin:
            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
          lights_toon_fragment:
            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          lights_toon_pars_fragment:
            "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
          lights_phong_fragment:
            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          lights_phong_pars_fragment:
            "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
          lights_physical_fragment:
            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
          lights_physical_pars_fragment:
            "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          lights_fragment_begin:
            "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          lights_fragment_maps:
            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
          lights_fragment_end:
            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
          logdepthbuf_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          logdepthbuf_pars_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_pars_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
          logdepthbuf_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
          map_fragment:
            "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
          map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          map_particle_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          map_particle_pars_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          metalnessmap_fragment:
            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          metalnessmap_pars_fragment:
            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          morphnormal_vertex:
            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
          morphtarget_pars_vertex:
            "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
          morphtarget_vertex:
            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
          normal_fragment_begin:
            "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
          normal_fragment_maps:
            "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
          normalmap_pars_fragment:
            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
          clearcoat_normal_fragment_begin:
            "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
          clearcoat_normal_fragment_maps:
            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
          clearcoat_pars_fragment:
            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
          packing:
            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
          premultiplied_alpha_fragment:
            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          project_vertex:
            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          dithering_fragment:
            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          dithering_pars_fragment:
            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          roughnessmap_fragment:
            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          roughnessmap_pars_fragment:
            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          shadowmap_pars_fragment:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
          shadowmap_pars_vertex:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          shadowmap_vertex:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
          shadowmask_pars_fragment:
            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          skinbase_vertex:
            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          skinning_pars_vertex:
            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
          skinning_vertex:
            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          skinnormal_vertex:
            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          specularmap_fragment:
            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          specularmap_pars_fragment:
            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          tonemapping_fragment:
            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          tonemapping_pars_fragment:
            "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          transmissionmap_fragment:
            "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
          transmissionmap_pars_fragment:
            "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
          uv_pars_fragment:
            "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
          uv_pars_vertex:
            "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
          uv_vertex:
            "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
          uv2_pars_fragment:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
          uv2_pars_vertex:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
          uv2_vertex:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
          worldpos_vertex:
            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          background_frag:
            "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          background_vert:
            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          cube_frag:
            "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          cube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          depth_frag:
            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
          depth_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          distanceRGBA_frag:
            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          distanceRGBA_vert:
            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          equirect_frag:
            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          equirect_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          linedashed_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          linedashed_vert:
            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          meshbasic_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshbasic_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          meshlambert_frag:
            "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshlambert_vert:
            "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshmatcap_frag:
            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshmatcap_vert:
            "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          meshtoon_frag:
            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshtoon_vert:
            "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphong_frag:
            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphong_vert:
            "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphysical_frag:
            "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphysical_vert:
            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          normal_frag:
            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
          normal_vert:
            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          points_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          points_vert:
            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          shadow_frag:
            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          shadow_vert:
            "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          sprite_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          sprite_vert:
            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        },
        Tn = {
          common: {
            diffuse: { value: new ut(15658734) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new I() },
            uv2Transform: { value: new I() },
            alphaMap: { value: null },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            refractionRatio: { value: 0.98 },
            maxMipLevel: { value: 0 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new N(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new ut(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new ut(15658734) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new I() },
          },
          sprite: {
            diffuse: { value: new ut(15658734) },
            opacity: { value: 1 },
            center: { value: new N(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new I() },
          },
        },
        En = {
          basic: {
            uniforms: cn([
              Tn.common,
              Tn.specularmap,
              Tn.envmap,
              Tn.aomap,
              Tn.lightmap,
              Tn.fog,
            ]),
            vertexShader: Sn.meshbasic_vert,
            fragmentShader: Sn.meshbasic_frag,
          },
          lambert: {
            uniforms: cn([
              Tn.common,
              Tn.specularmap,
              Tn.envmap,
              Tn.aomap,
              Tn.lightmap,
              Tn.emissivemap,
              Tn.fog,
              Tn.lights,
              { emissive: { value: new ut(0) } },
            ]),
            vertexShader: Sn.meshlambert_vert,
            fragmentShader: Sn.meshlambert_frag,
          },
          phong: {
            uniforms: cn([
              Tn.common,
              Tn.specularmap,
              Tn.envmap,
              Tn.aomap,
              Tn.lightmap,
              Tn.emissivemap,
              Tn.bumpmap,
              Tn.normalmap,
              Tn.displacementmap,
              Tn.fog,
              Tn.lights,
              {
                emissive: { value: new ut(0) },
                specular: { value: new ut(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: Sn.meshphong_vert,
            fragmentShader: Sn.meshphong_frag,
          },
          standard: {
            uniforms: cn([
              Tn.common,
              Tn.envmap,
              Tn.aomap,
              Tn.lightmap,
              Tn.emissivemap,
              Tn.bumpmap,
              Tn.normalmap,
              Tn.displacementmap,
              Tn.roughnessmap,
              Tn.metalnessmap,
              Tn.fog,
              Tn.lights,
              {
                emissive: { value: new ut(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: Sn.meshphysical_vert,
            fragmentShader: Sn.meshphysical_frag,
          },
          toon: {
            uniforms: cn([
              Tn.common,
              Tn.aomap,
              Tn.lightmap,
              Tn.emissivemap,
              Tn.bumpmap,
              Tn.normalmap,
              Tn.displacementmap,
              Tn.gradientmap,
              Tn.fog,
              Tn.lights,
              { emissive: { value: new ut(0) } },
            ]),
            vertexShader: Sn.meshtoon_vert,
            fragmentShader: Sn.meshtoon_frag,
          },
          matcap: {
            uniforms: cn([
              Tn.common,
              Tn.bumpmap,
              Tn.normalmap,
              Tn.displacementmap,
              Tn.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: Sn.meshmatcap_vert,
            fragmentShader: Sn.meshmatcap_frag,
          },
          points: {
            uniforms: cn([Tn.points, Tn.fog]),
            vertexShader: Sn.points_vert,
            fragmentShader: Sn.points_frag,
          },
          dashed: {
            uniforms: cn([
              Tn.common,
              Tn.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: Sn.linedashed_vert,
            fragmentShader: Sn.linedashed_frag,
          },
          depth: {
            uniforms: cn([Tn.common, Tn.displacementmap]),
            vertexShader: Sn.depth_vert,
            fragmentShader: Sn.depth_frag,
          },
          normal: {
            uniforms: cn([
              Tn.common,
              Tn.bumpmap,
              Tn.normalmap,
              Tn.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: Sn.normal_vert,
            fragmentShader: Sn.normal_frag,
          },
          sprite: {
            uniforms: cn([Tn.sprite, Tn.fog]),
            vertexShader: Sn.sprite_vert,
            fragmentShader: Sn.sprite_frag,
          },
          background: {
            uniforms: { uvTransform: { value: new I() }, t2D: { value: null } },
            vertexShader: Sn.background_vert,
            fragmentShader: Sn.background_frag,
          },
          cube: {
            uniforms: cn([Tn.envmap, { opacity: { value: 1 } }]),
            vertexShader: Sn.cube_vert,
            fragmentShader: Sn.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Sn.equirect_vert,
            fragmentShader: Sn.equirect_frag,
          },
          distanceRGBA: {
            uniforms: cn([
              Tn.common,
              Tn.displacementmap,
              {
                referencePosition: { value: new W() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: Sn.distanceRGBA_vert,
            fragmentShader: Sn.distanceRGBA_frag,
          },
          shadow: {
            uniforms: cn([
              Tn.lights,
              Tn.fog,
              { color: { value: new ut(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: Sn.shadow_vert,
            fragmentShader: Sn.shadow_frag,
          },
        };
      function An(e, t, n, i, r) {
        const a = new ut(0);
        let o,
          s,
          c = 0,
          l = null,
          h = 0,
          u = null;
        function p(e, t) {
          n.buffers.color.setClear(e.r, e.g, e.b, t, r);
        }
        return {
          getClearColor: function () {
            return a;
          },
          setClearColor: function (e, t = 1) {
            a.set(e), (c = t), p(a, c);
          },
          getClearAlpha: function () {
            return c;
          },
          setClearAlpha: function (e) {
            (c = e), p(a, c);
          },
          render: function (n, r, d, f) {
            let m = !0 === r.isScene ? r.background : null;
            m && m.isTexture && (m = t.get(m));
            const g = e.xr,
              v = g.getSession && g.getSession();
            v && "additive" === v.environmentBlendMode && (m = null),
              null === m ? p(a, c) : m && m.isColor && (p(m, 1), (f = !0)),
              (e.autoClear || f) &&
                e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
              m &&
              (m.isCubeTexture ||
                m.isWebGLCubeRenderTarget ||
                306 === m.mapping)
                ? (void 0 === s &&
                    ((s = new rn(
                      new on(1, 1, 1),
                      new hn({
                        name: "BackgroundCubeMaterial",
                        uniforms: sn(En.cube.uniforms),
                        vertexShader: En.cube.vertexShader,
                        fragmentShader: En.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )),
                    s.geometry.deleteAttribute("normal"),
                    s.geometry.deleteAttribute("uv"),
                    (s.onBeforeRender = function (e, t, n) {
                      this.matrixWorld.copyPosition(n.matrixWorld);
                    }),
                    Object.defineProperty(s.material, "envMap", {
                      get: function () {
                        return this.uniforms.envMap.value;
                      },
                    }),
                    i.update(s)),
                  m.isWebGLCubeRenderTarget && (m = m.texture),
                  (s.material.uniforms.envMap.value = m),
                  (s.material.uniforms.flipEnvMap.value =
                    m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1),
                  (l === m && h === m.version && u === e.toneMapping) ||
                    ((s.material.needsUpdate = !0),
                    (l = m),
                    (h = m.version),
                    (u = e.toneMapping)),
                  n.unshift(s, s.geometry, s.material, 0, 0, null))
                : m &&
                  m.isTexture &&
                  (void 0 === o &&
                    ((o = new rn(
                      new Mn(2, 2),
                      new hn({
                        name: "BackgroundMaterial",
                        uniforms: sn(En.background.uniforms),
                        vertexShader: En.background.vertexShader,
                        fragmentShader: En.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )),
                    o.geometry.deleteAttribute("normal"),
                    Object.defineProperty(o.material, "map", {
                      get: function () {
                        return this.uniforms.t2D.value;
                      },
                    }),
                    i.update(o)),
                  (o.material.uniforms.t2D.value = m),
                  !0 === m.matrixAutoUpdate && m.updateMatrix(),
                  o.material.uniforms.uvTransform.value.copy(m.matrix),
                  (l === m && h === m.version && u === e.toneMapping) ||
                    ((o.material.needsUpdate = !0),
                    (l = m),
                    (h = m.version),
                    (u = e.toneMapping)),
                  n.unshift(o, o.geometry, o.material, 0, 0, null));
          },
        };
      }
      function Ln(e, t, n, i) {
        const r = e.getParameter(34921),
          a = i.isWebGL2 ? null : t.get("OES_vertex_array_object"),
          o = i.isWebGL2 || null !== a,
          s = {},
          c = p(null);
        let l = c;
        function h(t) {
          return i.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t);
        }
        function u(t) {
          return i.isWebGL2
            ? e.deleteVertexArray(t)
            : a.deleteVertexArrayOES(t);
        }
        function p(e) {
          const t = [],
            n = [],
            i = [];
          for (let e = 0; e < r; e++) (t[e] = 0), (n[e] = 0), (i[e] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: t,
            enabledAttributes: n,
            attributeDivisors: i,
            object: e,
            attributes: {},
            index: null,
          };
        }
        function d() {
          const e = l.newAttributes;
          for (let t = 0, n = e.length; t < n; t++) e[t] = 0;
        }
        function f(e) {
          m(e, 0);
        }
        function m(n, r) {
          const a = l.newAttributes,
            o = l.enabledAttributes,
            s = l.attributeDivisors;
          (a[n] = 1),
            0 === o[n] && (e.enableVertexAttribArray(n), (o[n] = 1)),
            s[n] !== r &&
              ((i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[
                i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](n, r),
              (s[n] = r));
        }
        function g() {
          const t = l.newAttributes,
            n = l.enabledAttributes;
          for (let i = 0, r = n.length; i < r; i++)
            n[i] !== t[i] && (e.disableVertexAttribArray(i), (n[i] = 0));
        }
        function v(t, n, r, a, o, s) {
          !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
            ? e.vertexAttribPointer(t, n, r, a, o, s)
            : e.vertexAttribIPointer(t, n, r, o, s);
        }
        function y() {
          _(), l !== c && ((l = c), h(l.object));
        }
        function _() {
          (c.geometry = null), (c.program = null), (c.wireframe = !1);
        }
        return {
          setup: function (r, c, u, y, _) {
            let w = !1;
            if (o) {
              const t = (function (t, n, r) {
                const o = !0 === r.wireframe;
                let c = s[t.id];
                void 0 === c && ((c = {}), (s[t.id] = c));
                let l = c[n.id];
                void 0 === l && ((l = {}), (c[n.id] = l));
                let h = l[o];
                return (
                  void 0 === h &&
                    ((h = p(
                      i.isWebGL2
                        ? e.createVertexArray()
                        : a.createVertexArrayOES()
                    )),
                    (l[o] = h)),
                  h
                );
              })(y, u, c);
              l !== t && ((l = t), h(l.object)),
                (w = (function (e, t) {
                  const n = l.attributes,
                    i = e.attributes;
                  let r = 0;
                  for (const e in i) {
                    const t = n[e],
                      a = i[e];
                    if (void 0 === t) return !0;
                    if (t.attribute !== a) return !0;
                    if (t.data !== a.data) return !0;
                    r++;
                  }
                  return l.attributesNum !== r || l.index !== t;
                })(y, _)),
                w &&
                  (function (e, t) {
                    const n = {},
                      i = e.attributes;
                    let r = 0;
                    for (const e in i) {
                      const t = i[e],
                        a = {};
                      (a.attribute = t),
                        t.data && (a.data = t.data),
                        (n[e] = a),
                        r++;
                    }
                    (l.attributes = n), (l.attributesNum = r), (l.index = t);
                  })(y, _);
            } else {
              const e = !0 === c.wireframe;
              (l.geometry === y.id &&
                l.program === u.id &&
                l.wireframe === e) ||
                ((l.geometry = y.id),
                (l.program = u.id),
                (l.wireframe = e),
                (w = !0));
            }
            !0 === r.isInstancedMesh && (w = !0),
              null !== _ && n.update(_, 34963),
              w &&
                ((function (r, a, o, s) {
                  if (
                    !1 === i.isWebGL2 &&
                    (r.isInstancedMesh || s.isInstancedBufferGeometry) &&
                    null === t.get("ANGLE_instanced_arrays")
                  )
                    return;
                  d();
                  const c = s.attributes,
                    l = o.getAttributes(),
                    h = a.defaultAttributeValues;
                  for (const t in l) {
                    const i = l[t];
                    if (i >= 0) {
                      const a = c[t];
                      if (void 0 !== a) {
                        const t = a.normalized,
                          r = a.itemSize,
                          o = n.get(a);
                        if (void 0 === o) continue;
                        const c = o.buffer,
                          l = o.type,
                          h = o.bytesPerElement;
                        if (a.isInterleavedBufferAttribute) {
                          const n = a.data,
                            o = n.stride,
                            u = a.offset;
                          n && n.isInstancedInterleavedBuffer
                            ? (m(i, n.meshPerAttribute),
                              void 0 === s._maxInstanceCount &&
                                (s._maxInstanceCount =
                                  n.meshPerAttribute * n.count))
                            : f(i),
                            e.bindBuffer(34962, c),
                            v(i, r, l, t, o * h, u * h);
                        } else
                          a.isInstancedBufferAttribute
                            ? (m(i, a.meshPerAttribute),
                              void 0 === s._maxInstanceCount &&
                                (s._maxInstanceCount =
                                  a.meshPerAttribute * a.count))
                            : f(i),
                            e.bindBuffer(34962, c),
                            v(i, r, l, t, 0, 0);
                      } else if ("instanceMatrix" === t) {
                        const t = n.get(r.instanceMatrix);
                        if (void 0 === t) continue;
                        const a = t.buffer,
                          o = t.type;
                        m(i + 0, 1),
                          m(i + 1, 1),
                          m(i + 2, 1),
                          m(i + 3, 1),
                          e.bindBuffer(34962, a),
                          e.vertexAttribPointer(i + 0, 4, o, !1, 64, 0),
                          e.vertexAttribPointer(i + 1, 4, o, !1, 64, 16),
                          e.vertexAttribPointer(i + 2, 4, o, !1, 64, 32),
                          e.vertexAttribPointer(i + 3, 4, o, !1, 64, 48);
                      } else if ("instanceColor" === t) {
                        const t = n.get(r.instanceColor);
                        if (void 0 === t) continue;
                        const a = t.buffer,
                          o = t.type;
                        m(i, 1),
                          e.bindBuffer(34962, a),
                          e.vertexAttribPointer(i, 3, o, !1, 12, 0);
                      } else if (void 0 !== h) {
                        const n = h[t];
                        if (void 0 !== n)
                          switch (n.length) {
                            case 2:
                              e.vertexAttrib2fv(i, n);
                              break;
                            case 3:
                              e.vertexAttrib3fv(i, n);
                              break;
                            case 4:
                              e.vertexAttrib4fv(i, n);
                              break;
                            default:
                              e.vertexAttrib1fv(i, n);
                          }
                      }
                    }
                  }
                  g();
                })(r, c, u, y),
                null !== _ && e.bindBuffer(34963, n.get(_).buffer));
          },
          reset: y,
          resetDefaultState: _,
          dispose: function () {
            y();
            for (const e in s) {
              const t = s[e];
              for (const e in t) {
                const n = t[e];
                for (const e in n) u(n[e].object), delete n[e];
                delete t[e];
              }
              delete s[e];
            }
          },
          releaseStatesOfGeometry: function (e) {
            if (void 0 === s[e.id]) return;
            const t = s[e.id];
            for (const e in t) {
              const n = t[e];
              for (const e in n) u(n[e].object), delete n[e];
              delete t[e];
            }
            delete s[e.id];
          },
          releaseStatesOfProgram: function (e) {
            for (const t in s) {
              const n = s[t];
              if (void 0 === n[e.id]) continue;
              const i = n[e.id];
              for (const e in i) u(i[e].object), delete i[e];
              delete n[e.id];
            }
          },
          initAttributes: d,
          enableAttribute: f,
          disableUnusedAttributes: g,
        };
      }
      function Pn(e, t, n, i) {
        const r = i.isWebGL2;
        let a;
        (this.setMode = function (e) {
          a = e;
        }),
          (this.render = function (t, i) {
            e.drawArrays(a, t, i), n.update(i, a, 1);
          }),
          (this.renderInstances = function (i, o, s) {
            if (0 === s) return;
            let c, l;
            if (r) (c = e), (l = "drawArraysInstanced");
            else if (
              ((c = t.get("ANGLE_instanced_arrays")),
              (l = "drawArraysInstancedANGLE"),
              null === c)
            )
              return void console.error(
                "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            c[l](a, i, o, s), n.update(o, a, s);
          });
      }
      function Rn(e, t, n) {
        let i;
        function r(t) {
          if ("highp" === t) {
            if (
              e.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              e.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            t = "mediump";
          }
          return "mediump" === t &&
            e.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            e.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        const a =
          ("undefined" != typeof WebGL2RenderingContext &&
            e instanceof WebGL2RenderingContext) ||
          ("undefined" != typeof WebGL2ComputeRenderingContext &&
            e instanceof WebGL2ComputeRenderingContext);
        let o = void 0 !== n.precision ? n.precision : "highp";
        const s = r(o);
        s !== o &&
          (console.warn(
            "THREE.WebGLRenderer:",
            o,
            "not supported, using",
            s,
            "instead."
          ),
          (o = s));
        const c = !0 === n.logarithmicDepthBuffer,
          l = e.getParameter(34930),
          h = e.getParameter(35660),
          u = e.getParameter(3379),
          p = e.getParameter(34076),
          d = e.getParameter(34921),
          f = e.getParameter(36347),
          m = e.getParameter(36348),
          g = e.getParameter(36349),
          v = h > 0,
          y = a || !!t.get("OES_texture_float");
        return {
          isWebGL2: a,
          getMaxAnisotropy: function () {
            if (void 0 !== i) return i;
            const n = t.get("EXT_texture_filter_anisotropic");
            return (
              (i =
                null !== n
                  ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                  : 0),
              i
            );
          },
          getMaxPrecision: r,
          precision: o,
          logarithmicDepthBuffer: c,
          maxTextures: l,
          maxVertexTextures: h,
          maxTextureSize: u,
          maxCubemapSize: p,
          maxAttributes: d,
          maxVertexUniforms: f,
          maxVaryings: m,
          maxFragmentUniforms: g,
          vertexTextures: v,
          floatFragmentTextures: y,
          floatVertexTextures: v && y,
          maxSamples: a ? e.getParameter(36183) : 0,
        };
      }
      function kn(e) {
        const t = this;
        let n = null,
          i = 0,
          r = !1,
          a = !1;
        const o = new Xe(),
          s = new I(),
          c = { value: null, needsUpdate: !1 };
        function l() {
          c.value !== n && ((c.value = n), (c.needsUpdate = i > 0)),
            (t.numPlanes = i),
            (t.numIntersection = 0);
        }
        function h(e, n, i, r) {
          const a = null !== e ? e.length : 0;
          let l = null;
          if (0 !== a) {
            if (((l = c.value), !0 !== r || null === l)) {
              const t = i + 4 * a,
                r = n.matrixWorldInverse;
              s.getNormalMatrix(r),
                (null === l || l.length < t) && (l = new Float32Array(t));
              for (let t = 0, n = i; t !== a; ++t, n += 4)
                o.copy(e[t]).applyMatrix4(r, s),
                  o.normal.toArray(l, n),
                  (l[n + 3] = o.constant);
            }
            (c.value = l), (c.needsUpdate = !0);
          }
          return (t.numPlanes = a), (t.numIntersection = 0), l;
        }
        (this.uniform = c),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (e, t, a) {
            const o = 0 !== e.length || t || 0 !== i || r;
            return (r = t), (n = h(e, a, 0)), (i = e.length), o;
          }),
          (this.beginShadows = function () {
            (a = !0), h(null);
          }),
          (this.endShadows = function () {
            (a = !1), l();
          }),
          (this.setState = function (t, o, s) {
            const u = t.clippingPlanes,
              p = t.clipIntersection,
              d = t.clipShadows,
              f = e.get(t);
            if (!r || null === u || 0 === u.length || (a && !d))
              a ? h(null) : l();
            else {
              const e = a ? 0 : i,
                t = 4 * e;
              let r = f.clippingState || null;
              (c.value = r), (r = h(u, o, t, s));
              for (let e = 0; e !== t; ++e) r[e] = n[e];
              (f.clippingState = r),
                (this.numIntersection = p ? this.numPlanes : 0),
                (this.numPlanes += e);
            }
          });
      }
      function Cn(e) {
        let t = new WeakMap();
        function n(e, t) {
          return (
            303 === t ? (e.mapping = 301) : 304 === t && (e.mapping = 302), e
          );
        }
        function i(e) {
          const n = e.target;
          n.removeEventListener("dispose", i);
          const r = t.get(n);
          void 0 !== r && (t.delete(n), r.dispose());
        }
        return {
          get: function (r) {
            if (r && r.isTexture) {
              const a = r.mapping;
              if (303 === a || 304 === a) {
                if (t.has(r)) return n(t.get(r).texture, r.mapping);
                {
                  const a = r.image;
                  if (a && a.height > 0) {
                    const o = e.getRenderList(),
                      s = e.getRenderTarget(),
                      c = new gn(a.height / 2);
                    return (
                      c.fromEquirectangularTexture(e, r),
                      t.set(r, c),
                      e.setRenderTarget(s),
                      e.setRenderList(o),
                      r.addEventListener("dispose", i),
                      n(c.texture, r.mapping)
                    );
                  }
                  return null;
                }
              }
            }
            return r;
          },
          dispose: function () {
            t = new WeakMap();
          },
        };
      }
      function On(e) {
        const t = {};
        function n(n) {
          if (void 0 !== t[n]) return t[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                e.getExtension("WEBGL_depth_texture") ||
                e.getExtension("MOZ_WEBGL_depth_texture") ||
                e.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                e.getExtension("EXT_texture_filter_anisotropic") ||
                e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                e.getExtension("WEBGL_compressed_texture_s3tc") ||
                e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                e.getExtension("WEBGL_compressed_texture_pvrtc") ||
                e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = e.getExtension(n);
          }
          return (t[n] = i), i;
        }
        return {
          has: function (e) {
            return null !== n(e);
          },
          init: function (e) {
            e.isWebGL2
              ? n("EXT_color_buffer_float")
              : (n("WEBGL_depth_texture"),
                n("OES_texture_float"),
                n("OES_texture_half_float"),
                n("OES_texture_half_float_linear"),
                n("OES_standard_derivatives"),
                n("OES_element_index_uint"),
                n("OES_vertex_array_object"),
                n("ANGLE_instanced_arrays")),
              n("OES_texture_float_linear"),
              n("EXT_color_buffer_half_float");
          },
          get: function (e) {
            const t = n(e);
            return (
              null === t &&
                console.warn(
                  "THREE.WebGLRenderer: " + e + " extension not supported."
                ),
              t
            );
          },
        };
      }
      function Nn(e, t, n, i) {
        const r = {},
          a = new WeakMap();
        function o(e) {
          const s = e.target;
          null !== s.index && t.remove(s.index);
          for (const e in s.attributes) t.remove(s.attributes[e]);
          s.removeEventListener("dispose", o), delete r[s.id];
          const c = a.get(s);
          c && (t.remove(c), a.delete(s)),
            i.releaseStatesOfGeometry(s),
            !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount,
            n.memory.geometries--;
        }
        function s(e) {
          const n = [],
            i = e.index,
            r = e.attributes.position;
          let o = 0;
          if (null !== i) {
            const e = i.array;
            o = i.version;
            for (let t = 0, i = e.length; t < i; t += 3) {
              const i = e[t + 0],
                r = e[t + 1],
                a = e[t + 2];
              n.push(i, r, r, a, a, i);
            }
          } else {
            const e = r.array;
            o = r.version;
            for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
              const e = t + 0,
                i = t + 1,
                r = t + 2;
              n.push(e, i, i, r, r, e);
            }
          }
          const s = new (Pt(n) > 65535 ? Tt : Mt)(n, 1);
          s.version = o;
          const c = a.get(e);
          c && t.remove(c), a.set(e, s);
        }
        return {
          get: function (e, t) {
            return (
              !0 === r[t.id] ||
                (t.addEventListener("dispose", o),
                (r[t.id] = !0),
                n.memory.geometries++),
              t
            );
          },
          update: function (e) {
            const n = e.attributes;
            for (const e in n) t.update(n[e], 34962);
            const i = e.morphAttributes;
            for (const e in i) {
              const n = i[e];
              for (let e = 0, i = n.length; e < i; e++) t.update(n[e], 34962);
            }
          },
          getWireframeAttribute: function (e) {
            const t = a.get(e);
            if (t) {
              const n = e.index;
              null !== n && t.version < n.version && s(e);
            } else s(e);
            return a.get(e);
          },
        };
      }
      function In(e, t, n, i) {
        const r = i.isWebGL2;
        let a, o, s;
        (this.setMode = function (e) {
          a = e;
        }),
          (this.setIndex = function (e) {
            (o = e.type), (s = e.bytesPerElement);
          }),
          (this.render = function (t, i) {
            e.drawElements(a, i, o, t * s), n.update(i, a, 1);
          }),
          (this.renderInstances = function (i, c, l) {
            if (0 === l) return;
            let h, u;
            if (r) (h = e), (u = "drawElementsInstanced");
            else if (
              ((h = t.get("ANGLE_instanced_arrays")),
              (u = "drawElementsInstancedANGLE"),
              null === h)
            )
              return void console.error(
                "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            h[u](a, c, o, i * s, l), n.update(c, a, l);
          });
      }
      function Dn(e) {
        const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
          memory: { geometries: 0, textures: 0 },
          render: t,
          programs: null,
          autoReset: !0,
          reset: function () {
            t.frame++,
              (t.calls = 0),
              (t.triangles = 0),
              (t.points = 0),
              (t.lines = 0);
          },
          update: function (e, n, i) {
            switch ((t.calls++, n)) {
              case 4:
                t.triangles += i * (e / 3);
                break;
              case 1:
                t.lines += i * (e / 2);
                break;
              case 3:
                t.lines += i * (e - 1);
                break;
              case 2:
                t.lines += i * e;
                break;
              case 0:
                t.points += i * e;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", n);
            }
          },
        };
      }
      function jn(e, t) {
        return e[0] - t[0];
      }
      function Fn(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1]);
      }
      function Hn(e) {
        const t = {},
          n = new Float32Array(8),
          i = [];
        for (let e = 0; e < 8; e++) i[e] = [e, 0];
        return {
          update: function (r, a, o, s) {
            const c = r.morphTargetInfluences,
              l = void 0 === c ? 0 : c.length;
            let h = t[a.id];
            if (void 0 === h) {
              h = [];
              for (let e = 0; e < l; e++) h[e] = [e, 0];
              t[a.id] = h;
            }
            for (let e = 0; e < l; e++) {
              const t = h[e];
              (t[0] = e), (t[1] = c[e]);
            }
            h.sort(Fn);
            for (let e = 0; e < 8; e++)
              e < l && h[e][1]
                ? ((i[e][0] = h[e][0]), (i[e][1] = h[e][1]))
                : ((i[e][0] = Number.MAX_SAFE_INTEGER), (i[e][1] = 0));
            i.sort(jn);
            const u = o.morphTargets && a.morphAttributes.position,
              p = o.morphNormals && a.morphAttributes.normal;
            let d = 0;
            for (let e = 0; e < 8; e++) {
              const t = i[e],
                r = t[0],
                o = t[1];
              r !== Number.MAX_SAFE_INTEGER && o
                ? (u &&
                    a.getAttribute("morphTarget" + e) !== u[r] &&
                    a.setAttribute("morphTarget" + e, u[r]),
                  p &&
                    a.getAttribute("morphNormal" + e) !== p[r] &&
                    a.setAttribute("morphNormal" + e, p[r]),
                  (n[e] = o),
                  (d += o))
                : (u &&
                    !0 === a.hasAttribute("morphTarget" + e) &&
                    a.deleteAttribute("morphTarget" + e),
                  p &&
                    !0 === a.hasAttribute("morphNormal" + e) &&
                    a.deleteAttribute("morphNormal" + e),
                  (n[e] = 0));
            }
            const f = a.morphTargetsRelative ? 1 : 1 - d;
            s.getUniforms().setValue(e, "morphTargetBaseInfluence", f),
              s.getUniforms().setValue(e, "morphTargetInfluences", n);
          },
        };
      }
      function Bn(e, t, n, i) {
        let r = new WeakMap();
        function a(e) {
          const t = e.target;
          t.removeEventListener("dispose", a),
            n.remove(t.instanceMatrix),
            null !== t.instanceColor && n.remove(t.instanceColor);
        }
        return {
          update: function (e) {
            const o = i.render.frame,
              s = e.geometry,
              c = t.get(e, s);
            return (
              r.get(c) !== o && (t.update(c), r.set(c, o)),
              e.isInstancedMesh &&
                (!1 === e.hasEventListener("dispose", a) &&
                  e.addEventListener("dispose", a),
                n.update(e.instanceMatrix, 34962),
                null !== e.instanceColor && n.update(e.instanceColor, 34962)),
              c
            );
          },
          dispose: function () {
            r = new WeakMap();
          },
        };
      }
      function zn(e = null, t = 1, i = 1, a = 1) {
        H.call(this, null),
          (this.image = { data: e, width: t, height: i, depth: a }),
          (this.magFilter = r),
          (this.minFilter = r),
          (this.wrapR = n),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.needsUpdate = !0);
      }
      function Un(e = null, t = 1, i = 1, a = 1) {
        H.call(this, null),
          (this.image = { data: e, width: t, height: i, depth: a }),
          (this.magFilter = r),
          (this.minFilter = r),
          (this.wrapR = n),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.needsUpdate = !0);
      }
      (En.physical = {
        uniforms: cn([
          En.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new N(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: new ut(0) },
            transmission: { value: 0 },
            transmissionMap: { value: null },
          },
        ]),
        vertexShader: Sn.meshphysical_vert,
        fragmentShader: Sn.meshphysical_frag,
      }),
        (zn.prototype = Object.create(H.prototype)),
        (zn.prototype.constructor = zn),
        (zn.prototype.isDataTexture2DArray = !0),
        (Un.prototype = Object.create(H.prototype)),
        (Un.prototype.constructor = Un),
        (Un.prototype.isDataTexture3D = !0);
      const Gn = new H(),
        Wn = new zn(),
        Vn = new Un(),
        qn = new mn(),
        Xn = [],
        Yn = [],
        Jn = new Float32Array(16),
        Zn = new Float32Array(9),
        Qn = new Float32Array(4);
      function Kn(e, t, n) {
        const i = e[0];
        if (i <= 0 || i > 0) return e;
        const r = t * n;
        let a = Xn[r];
        if (
          (void 0 === a && ((a = new Float32Array(r)), (Xn[r] = a)), 0 !== t)
        ) {
          i.toArray(a, 0);
          for (let i = 1, r = 0; i !== t; ++i) (r += n), e[i].toArray(a, r);
        }
        return a;
      }
      function $n(e, t) {
        if (e.length !== t.length) return !1;
        for (let n = 0, i = e.length; n < i; n++) if (e[n] !== t[n]) return !1;
        return !0;
      }
      function ei(e, t) {
        for (let n = 0, i = t.length; n < i; n++) e[n] = t[n];
      }
      function ti(e, t) {
        let n = Yn[t];
        void 0 === n && ((n = new Int32Array(t)), (Yn[t] = n));
        for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
        return n;
      }
      function ni(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t), (n[0] = t));
      }
      function ii(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y) ||
            (e.uniform2f(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
        else {
          if ($n(n, t)) return;
          e.uniform2fv(this.addr, t), ei(n, t);
        }
      }
      function ri(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
            (e.uniform3f(this.addr, t.x, t.y, t.z),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z));
        else if (void 0 !== t.r)
          (n[0] === t.r && n[1] === t.g && n[2] === t.b) ||
            (e.uniform3f(this.addr, t.r, t.g, t.b),
            (n[0] = t.r),
            (n[1] = t.g),
            (n[2] = t.b));
        else {
          if ($n(n, t)) return;
          e.uniform3fv(this.addr, t), ei(n, t);
        }
      }
      function ai(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
            (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z),
            (n[3] = t.w));
        else {
          if ($n(n, t)) return;
          e.uniform4fv(this.addr, t), ei(n, t);
        }
      }
      function oi(e, t) {
        const n = this.cache,
          i = t.elements;
        if (void 0 === i) {
          if ($n(n, t)) return;
          e.uniformMatrix2fv(this.addr, !1, t), ei(n, t);
        } else {
          if ($n(n, i)) return;
          Qn.set(i), e.uniformMatrix2fv(this.addr, !1, Qn), ei(n, i);
        }
      }
      function si(e, t) {
        const n = this.cache,
          i = t.elements;
        if (void 0 === i) {
          if ($n(n, t)) return;
          e.uniformMatrix3fv(this.addr, !1, t), ei(n, t);
        } else {
          if ($n(n, i)) return;
          Zn.set(i), e.uniformMatrix3fv(this.addr, !1, Zn), ei(n, i);
        }
      }
      function ci(e, t) {
        const n = this.cache,
          i = t.elements;
        if (void 0 === i) {
          if ($n(n, t)) return;
          e.uniformMatrix4fv(this.addr, !1, t), ei(n, t);
        } else {
          if ($n(n, i)) return;
          Jn.set(i), e.uniformMatrix4fv(this.addr, !1, Jn), ei(n, i);
        }
      }
      function li(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.safeSetTexture2D(t || Gn, r);
      }
      function hi(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture2DArray(t || Wn, r);
      }
      function ui(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture3D(t || Vn, r);
      }
      function pi(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.safeSetTextureCube(t || qn, r);
      }
      function di(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t), (n[0] = t));
      }
      function fi(e, t) {
        const n = this.cache;
        $n(n, t) || (e.uniform2iv(this.addr, t), ei(n, t));
      }
      function mi(e, t) {
        const n = this.cache;
        $n(n, t) || (e.uniform3iv(this.addr, t), ei(n, t));
      }
      function gi(e, t) {
        const n = this.cache;
        $n(n, t) || (e.uniform4iv(this.addr, t), ei(n, t));
      }
      function vi(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t), (n[0] = t));
      }
      function yi(e, t) {
        e.uniform1fv(this.addr, t);
      }
      function _i(e, t) {
        e.uniform1iv(this.addr, t);
      }
      function wi(e, t) {
        e.uniform2iv(this.addr, t);
      }
      function xi(e, t) {
        e.uniform3iv(this.addr, t);
      }
      function bi(e, t) {
        e.uniform4iv(this.addr, t);
      }
      function Mi(e, t) {
        const n = Kn(t, this.size, 2);
        e.uniform2fv(this.addr, n);
      }
      function Si(e, t) {
        const n = Kn(t, this.size, 3);
        e.uniform3fv(this.addr, n);
      }
      function Ti(e, t) {
        const n = Kn(t, this.size, 4);
        e.uniform4fv(this.addr, n);
      }
      function Ei(e, t) {
        const n = Kn(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, n);
      }
      function Ai(e, t) {
        const n = Kn(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, n);
      }
      function Li(e, t) {
        const n = Kn(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, n);
      }
      function Pi(e, t, n) {
        const i = t.length,
          r = ti(n, i);
        e.uniform1iv(this.addr, r);
        for (let e = 0; e !== i; ++e) n.safeSetTexture2D(t[e] || Gn, r[e]);
      }
      function Ri(e, t, n) {
        const i = t.length,
          r = ti(n, i);
        e.uniform1iv(this.addr, r);
        for (let e = 0; e !== i; ++e) n.safeSetTextureCube(t[e] || qn, r[e]);
      }
      function ki(e, t, n) {
        (this.id = e),
          (this.addr = n),
          (this.cache = []),
          (this.setValue = (function (e) {
            switch (e) {
              case 5126:
                return ni;
              case 35664:
                return ii;
              case 35665:
                return ri;
              case 35666:
                return ai;
              case 35674:
                return oi;
              case 35675:
                return si;
              case 35676:
                return ci;
              case 5124:
              case 35670:
                return di;
              case 35667:
              case 35671:
                return fi;
              case 35668:
              case 35672:
                return mi;
              case 35669:
              case 35673:
                return gi;
              case 5125:
                return vi;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return li;
              case 35679:
              case 36299:
              case 36307:
                return ui;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return pi;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return hi;
            }
          })(t.type));
      }
      function Ci(e, t, n) {
        (this.id = e),
          (this.addr = n),
          (this.cache = []),
          (this.size = t.size),
          (this.setValue = (function (e) {
            switch (e) {
              case 5126:
                return yi;
              case 35664:
                return Mi;
              case 35665:
                return Si;
              case 35666:
                return Ti;
              case 35674:
                return Ei;
              case 35675:
                return Ai;
              case 35676:
                return Li;
              case 5124:
              case 35670:
                return _i;
              case 35667:
              case 35671:
                return wi;
              case 35668:
              case 35672:
                return xi;
              case 35669:
              case 35673:
                return bi;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return Pi;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return Ri;
            }
          })(t.type));
      }
      function Oi(e) {
        (this.id = e), (this.seq = []), (this.map = {});
      }
      (Ci.prototype.updateCache = function (e) {
        const t = this.cache;
        e instanceof Float32Array &&
          t.length !== e.length &&
          (this.cache = new Float32Array(e.length)),
          ei(t, e);
      }),
        (Oi.prototype.setValue = function (e, t, n) {
          const i = this.seq;
          for (let r = 0, a = i.length; r !== a; ++r) {
            const a = i[r];
            a.setValue(e, t[a.id], n);
          }
        });
      const Ni = /(\w+)(\])?(\[|\.)?/g;
      function Ii(e, t) {
        e.seq.push(t), (e.map[t.id] = t);
      }
      function Di(e, t, n) {
        const i = e.name,
          r = i.length;
        for (Ni.lastIndex = 0; ; ) {
          const a = Ni.exec(i),
            o = Ni.lastIndex;
          let s = a[1];
          const c = "]" === a[2],
            l = a[3];
          if ((c && (s |= 0), void 0 === l || ("[" === l && o + 2 === r))) {
            Ii(n, void 0 === l ? new ki(s, e, t) : new Ci(s, e, t));
            break;
          }
          {
            let e = n.map[s];
            void 0 === e && ((e = new Oi(s)), Ii(n, e)), (n = e);
          }
        }
      }
      function ji(e, t) {
        (this.seq = []), (this.map = {});
        const n = e.getProgramParameter(t, 35718);
        for (let i = 0; i < n; ++i) {
          const n = e.getActiveUniform(t, i);
          Di(n, e.getUniformLocation(t, n.name), this);
        }
      }
      function Fi(e, t, n) {
        const i = e.createShader(t);
        return e.shaderSource(i, n), e.compileShader(i), i;
      }
      (ji.prototype.setValue = function (e, t, n, i) {
        const r = this.map[t];
        void 0 !== r && r.setValue(e, n, i);
      }),
        (ji.prototype.setOptional = function (e, t, n) {
          const i = t[n];
          void 0 !== i && this.setValue(e, n, i);
        }),
        (ji.upload = function (e, t, n, i) {
          for (let r = 0, a = t.length; r !== a; ++r) {
            const a = t[r],
              o = n[a.id];
            !1 !== o.needsUpdate && a.setValue(e, o.value, i);
          }
        }),
        (ji.seqWithValue = function (e, t) {
          const n = [];
          for (let i = 0, r = e.length; i !== r; ++i) {
            const r = e[i];
            r.id in t && n.push(r);
          }
          return n;
        });
      let Hi = 0;
      function Bi(e) {
        switch (e) {
          case S:
            return ["Linear", "( value )"];
          case T:
            return ["sRGB", "( value )"];
          case 3002:
            return ["RGBE", "( value )"];
          case 3004:
            return ["RGBM", "( value, 7.0 )"];
          case 3005:
            return ["RGBM", "( value, 16.0 )"];
          case 3006:
            return ["RGBD", "( value, 256.0 )"];
          case 3007:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
          case 3003:
            return ["LogLuv", "( value )"];
          default:
            return (
              console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
              ["Linear", "( value )"]
            );
        }
      }
      function zi(e, t, n) {
        const i = e.getShaderParameter(t, 35713),
          r = e.getShaderInfoLog(t).trim();
        return i && "" === r
          ? ""
          : "THREE.WebGLShader: gl.getShaderInfoLog() " +
              n +
              "\n" +
              r +
              (function (e) {
                const t = e.split("\n");
                for (let e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
                return t.join("\n");
              })(e.getShaderSource(t));
      }
      function Ui(e, t) {
        const n = Bi(t);
        return (
          "vec4 " +
          e +
          "( vec4 value ) { return " +
          n[0] +
          "ToLinear" +
          n[1] +
          "; }"
        );
      }
      function Gi(e, t) {
        const n = Bi(t);
        return (
          "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        );
      }
      function Wi(e, t) {
        let n;
        switch (t) {
          case 1:
            n = "Linear";
            break;
          case 2:
            n = "Reinhard";
            break;
          case 3:
            n = "OptimizedCineon";
            break;
          case 4:
            n = "ACESFilmic";
            break;
          case 5:
            n = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
              (n = "Linear");
        }
        return (
          "vec3 " +
          e +
          "( vec3 color ) { return " +
          n +
          "ToneMapping( color ); }"
        );
      }
      function Vi(e) {
        return "" !== e;
      }
      function qi(e, t) {
        return e
          .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
      }
      function Xi(e, t) {
        return e
          .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            t.numClippingPlanes - t.numClipIntersection
          );
      }
      const Yi = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Ji(e) {
        return e.replace(Yi, Zi);
      }
      function Zi(e, t) {
        const n = Sn[t];
        if (void 0 === n)
          throw new Error("Can not resolve #include <" + t + ">");
        return Ji(n);
      }
      const Qi =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        Ki =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function $i(e) {
        return e.replace(Ki, tr).replace(Qi, er);
      }
      function er(e, t, n, i) {
        return (
          console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
          ),
          tr(0, t, n, i)
        );
      }
      function tr(e, t, n, i) {
        let r = "";
        for (let e = parseInt(t); e < parseInt(n); e++)
          r += i
            .replace(/\[\s*i\s*\]/g, "[ " + e + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, e);
        return r;
      }
      function nr(e) {
        let t =
          "precision " +
          e.precision +
          " float;\nprecision " +
          e.precision +
          " int;";
        return (
          "highp" === e.precision
            ? (t += "\n#define HIGH_PRECISION")
            : "mediump" === e.precision
            ? (t += "\n#define MEDIUM_PRECISION")
            : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
          t
        );
      }
      function ir(e, t, n, i) {
        const r = e.getContext(),
          a = n.defines;
        let o = n.vertexShader,
          s = n.fragmentShader;
        const c = (function (e) {
            let t = "SHADOWMAP_TYPE_BASIC";
            return (
              1 === e.shadowMapType
                ? (t = "SHADOWMAP_TYPE_PCF")
                : 2 === e.shadowMapType
                ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
                : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
              t
            );
          })(n),
          l = (function (e) {
            let t = "ENVMAP_TYPE_CUBE";
            if (e.envMap)
              switch (e.envMapMode) {
                case 301:
                case 302:
                  t = "ENVMAP_TYPE_CUBE";
                  break;
                case 306:
                case 307:
                  t = "ENVMAP_TYPE_CUBE_UV";
              }
            return t;
          })(n),
          h = (function (e) {
            let t = "ENVMAP_MODE_REFLECTION";
            if (e.envMap)
              switch (e.envMapMode) {
                case 302:
                case 307:
                  t = "ENVMAP_MODE_REFRACTION";
              }
            return t;
          })(n),
          u = (function (e) {
            let t = "ENVMAP_BLENDING_NONE";
            if (e.envMap)
              switch (e.combine) {
                case 0:
                  t = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case 1:
                  t = "ENVMAP_BLENDING_MIX";
                  break;
                case 2:
                  t = "ENVMAP_BLENDING_ADD";
              }
            return t;
          })(n),
          p = e.gammaFactor > 0 ? e.gammaFactor : 1,
          d = n.isWebGL2
            ? ""
            : (function (e) {
                return [
                  e.extensionDerivatives ||
                  e.envMapCubeUV ||
                  e.bumpMap ||
                  e.tangentSpaceNormalMap ||
                  e.clearcoatNormalMap ||
                  e.flatShading ||
                  "physical" === e.shaderID
                    ? "#extension GL_OES_standard_derivatives : enable"
                    : "",
                  (e.extensionFragDepth || e.logarithmicDepthBuffer) &&
                  e.rendererExtensionFragDepth
                    ? "#extension GL_EXT_frag_depth : enable"
                    : "",
                  e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
                    ? "#extension GL_EXT_draw_buffers : require"
                    : "",
                  (e.extensionShaderTextureLOD || e.envMap) &&
                  e.rendererExtensionShaderTextureLod
                    ? "#extension GL_EXT_shader_texture_lod : enable"
                    : "",
                ]
                  .filter(Vi)
                  .join("\n");
              })(n),
          f = (function (e) {
            const t = [];
            for (const n in e) {
              const i = e[n];
              !1 !== i && t.push("#define " + n + " " + i);
            }
            return t.join("\n");
          })(a),
          m = r.createProgram();
        let g,
          v,
          y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial
          ? ((g = [f].filter(Vi).join("\n")),
            g.length > 0 && (g += "\n"),
            (v = [d, f].filter(Vi).join("\n")),
            v.length > 0 && (v += "\n"))
          : ((g = [
              nr(n),
              "#define SHADER_NAME " + n.shaderName,
              f,
              n.instancing ? "#define USE_INSTANCING" : "",
              n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define GAMMA_FACTOR " + p,
              "#define MAX_BONES " + n.maxBones,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + h : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMap && n.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              n.normalMap && n.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.displacementMap && n.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.vertexTangents ? "#define USE_TANGENT" : "",
              n.vertexColors ? "#define USE_COLOR" : "",
              n.vertexUvs ? "#define USE_UV" : "",
              n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.skinning ? "#define USE_SKINNING" : "",
              n.useVertexTexture ? "#define BONE_TEXTURE" : "",
              n.morphTargets ? "#define USE_MORPHTARGETS" : "",
              n.morphNormals && !1 === n.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + c : "",
              n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "\tattribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "\tattribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#ifdef USE_COLOR",
              "\tattribute vec3 color;",
              "#endif",
              "#ifdef USE_MORPHTARGETS",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(Vi)
              .join("\n")),
            (v = [
              d,
              nr(n),
              "#define SHADER_NAME " + n.shaderName,
              f,
              n.alphaTest
                ? "#define ALPHATEST " +
                  n.alphaTest +
                  (n.alphaTest % 1 ? "" : ".0")
                : "",
              "#define GAMMA_FACTOR " + p,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.matcap ? "#define USE_MATCAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + l : "",
              n.envMap ? "#define " + h : "",
              n.envMap ? "#define " + u : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMap && n.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              n.normalMap && n.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.sheen ? "#define USE_SHEEN" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.vertexTangents ? "#define USE_TANGENT" : "",
              n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
              n.vertexUvs ? "#define USE_UV" : "",
              n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              n.gradientMap ? "#define USE_GRADIENTMAP" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + c : "",
              n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              n.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              (n.extensionShaderTextureLOD || n.envMap) &&
              n.rendererExtensionShaderTextureLod
                ? "#define TEXTURE_LOD_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
              0 !== n.toneMapping ? Sn.tonemapping_pars_fragment : "",
              0 !== n.toneMapping ? Wi("toneMapping", n.toneMapping) : "",
              n.dithering ? "#define DITHERING" : "",
              Sn.encodings_pars_fragment,
              n.map ? Ui("mapTexelToLinear", n.mapEncoding) : "",
              n.matcap ? Ui("matcapTexelToLinear", n.matcapEncoding) : "",
              n.envMap ? Ui("envMapTexelToLinear", n.envMapEncoding) : "",
              n.emissiveMap
                ? Ui("emissiveMapTexelToLinear", n.emissiveMapEncoding)
                : "",
              n.lightMap ? Ui("lightMapTexelToLinear", n.lightMapEncoding) : "",
              Gi("linearToOutputTexel", n.outputEncoding),
              n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
              "\n",
            ]
              .filter(Vi)
              .join("\n"))),
          (o = Ji(o)),
          (o = qi(o, n)),
          (o = Xi(o, n)),
          (s = Ji(s)),
          (s = qi(s, n)),
          (s = Xi(s, n)),
          (o = $i(o)),
          (s = $i(s)),
          n.isWebGL2 &&
            !0 !== n.isRawShaderMaterial &&
            ((y = "#version 300 es\n"),
            (g =
              [
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join("\n") +
              "\n" +
              g),
            (v =
              [
                "#define varying in",
                n.glslVersion === P ? "" : "out highp vec4 pc_fragColor;",
                n.glslVersion === P ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join("\n") +
              "\n" +
              v));
        const _ = y + v + s,
          w = Fi(r, 35633, y + g + o),
          x = Fi(r, 35632, _);
        if (
          (r.attachShader(m, w),
          r.attachShader(m, x),
          void 0 !== n.index0AttributeName
            ? r.bindAttribLocation(m, 0, n.index0AttributeName)
            : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
          r.linkProgram(m),
          e.debug.checkShaderErrors)
        ) {
          const e = r.getProgramInfoLog(m).trim(),
            t = r.getShaderInfoLog(w).trim(),
            n = r.getShaderInfoLog(x).trim();
          let i = !0,
            a = !0;
          if (!1 === r.getProgramParameter(m, 35714)) {
            i = !1;
            const t = zi(r, w, "vertex"),
              n = zi(r, x, "fragment");
            console.error(
              "THREE.WebGLProgram: shader error: ",
              r.getError(),
              "35715",
              r.getProgramParameter(m, 35715),
              "gl.getProgramInfoLog",
              e,
              t,
              n
            );
          } else
            "" !== e
              ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e)
              : ("" !== t && "" !== n) || (a = !1);
          a &&
            (this.diagnostics = {
              runnable: i,
              programLog: e,
              vertexShader: { log: t, prefix: g },
              fragmentShader: { log: n, prefix: v },
            });
        }
        let b, M;
        return (
          r.deleteShader(w),
          r.deleteShader(x),
          (this.getUniforms = function () {
            return void 0 === b && (b = new ji(r, m)), b;
          }),
          (this.getAttributes = function () {
            return (
              void 0 === M &&
                (M = (function (e, t) {
                  const n = {},
                    i = e.getProgramParameter(t, 35721);
                  for (let r = 0; r < i; r++) {
                    const i = e.getActiveAttrib(t, r).name;
                    n[i] = e.getAttribLocation(t, i);
                  }
                  return n;
                })(r, m)),
              M
            );
          }),
          (this.destroy = function () {
            i.releaseStatesOfProgram(this),
              r.deleteProgram(m),
              (this.program = void 0);
          }),
          (this.name = n.shaderName),
          (this.id = Hi++),
          (this.cacheKey = t),
          (this.usedTimes = 1),
          (this.program = m),
          (this.vertexShader = w),
          (this.fragmentShader = x),
          this
        );
      }
      function rr(e, t, n, i, r, a) {
        const o = [],
          s = i.isWebGL2,
          c = i.logarithmicDepthBuffer,
          l = i.floatVertexTextures,
          h = i.maxVertexUniforms,
          u = i.vertexTextures;
        let p = i.precision;
        const d = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
          },
          f = [
            "precision",
            "isWebGL2",
            "supportsVertexTextures",
            "outputEncoding",
            "instancing",
            "instancingColor",
            "map",
            "mapEncoding",
            "matcap",
            "matcapEncoding",
            "envMap",
            "envMapMode",
            "envMapEncoding",
            "envMapCubeUV",
            "lightMap",
            "lightMapEncoding",
            "aoMap",
            "emissiveMap",
            "emissiveMapEncoding",
            "bumpMap",
            "normalMap",
            "objectSpaceNormalMap",
            "tangentSpaceNormalMap",
            "clearcoatMap",
            "clearcoatRoughnessMap",
            "clearcoatNormalMap",
            "displacementMap",
            "specularMap",
            "roughnessMap",
            "metalnessMap",
            "gradientMap",
            "alphaMap",
            "combine",
            "vertexColors",
            "vertexTangents",
            "vertexUvs",
            "uvsVertexOnly",
            "fog",
            "useFog",
            "fogExp2",
            "flatShading",
            "sizeAttenuation",
            "logarithmicDepthBuffer",
            "skinning",
            "maxBones",
            "useVertexTexture",
            "morphTargets",
            "morphNormals",
            "maxMorphTargets",
            "maxMorphNormals",
            "premultipliedAlpha",
            "numDirLights",
            "numPointLights",
            "numSpotLights",
            "numHemiLights",
            "numRectAreaLights",
            "numDirLightShadows",
            "numPointLightShadows",
            "numSpotLightShadows",
            "shadowMapEnabled",
            "shadowMapType",
            "toneMapping",
            "physicallyCorrectLights",
            "alphaTest",
            "doubleSided",
            "flipSided",
            "numClippingPlanes",
            "numClipIntersection",
            "depthPacking",
            "dithering",
            "sheen",
            "transmissionMap",
          ];
        function m(e) {
          let t;
          return (
            e && e.isTexture
              ? (t = e.encoding)
              : e && e.isWebGLRenderTarget
              ? (console.warn(
                  "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                ),
                (t = e.texture.encoding))
              : (t = S),
            t
          );
        }
        return {
          getParameters: function (r, o, f, g, v) {
            const y = g.fog,
              _ = r.isMeshStandardMaterial ? g.environment : null,
              w = t.get(r.envMap || _),
              x = d[r.type],
              b = v.isSkinnedMesh
                ? (function (e) {
                    const t = e.skeleton.bones;
                    if (l) return 1024;
                    {
                      const e = h,
                        n = Math.floor((e - 20) / 4),
                        i = Math.min(n, t.length);
                      return i < t.length
                        ? (console.warn(
                            "THREE.WebGLRenderer: Skeleton has " +
                              t.length +
                              " bones. This GPU supports " +
                              i +
                              "."
                          ),
                          0)
                        : i;
                    }
                  })(v)
                : 0;
            let M, S;
            if (
              (null !== r.precision &&
                ((p = i.getMaxPrecision(r.precision)),
                p !== r.precision &&
                  console.warn(
                    "THREE.WebGLProgram.getParameters:",
                    r.precision,
                    "not supported, using",
                    p,
                    "instead."
                  )),
              x)
            ) {
              const e = En[x];
              (M = e.vertexShader), (S = e.fragmentShader);
            } else (M = r.vertexShader), (S = r.fragmentShader);
            const T = e.getRenderTarget();
            return {
              isWebGL2: s,
              shaderID: x,
              shaderName: r.type,
              vertexShader: M,
              fragmentShader: S,
              defines: r.defines,
              isRawShaderMaterial: !0 === r.isRawShaderMaterial,
              glslVersion: r.glslVersion,
              precision: p,
              instancing: !0 === v.isInstancedMesh,
              instancingColor:
                !0 === v.isInstancedMesh && null !== v.instanceColor,
              supportsVertexTextures: u,
              outputEncoding: null !== T ? m(T.texture) : e.outputEncoding,
              map: !!r.map,
              mapEncoding: m(r.map),
              matcap: !!r.matcap,
              matcapEncoding: m(r.matcap),
              envMap: !!w,
              envMapMode: w && w.mapping,
              envMapEncoding: m(w),
              envMapCubeUV: !!w && (306 === w.mapping || 307 === w.mapping),
              lightMap: !!r.lightMap,
              lightMapEncoding: m(r.lightMap),
              aoMap: !!r.aoMap,
              emissiveMap: !!r.emissiveMap,
              emissiveMapEncoding: m(r.emissiveMap),
              bumpMap: !!r.bumpMap,
              normalMap: !!r.normalMap,
              objectSpaceNormalMap: 1 === r.normalMapType,
              tangentSpaceNormalMap: 0 === r.normalMapType,
              clearcoatMap: !!r.clearcoatMap,
              clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
              clearcoatNormalMap: !!r.clearcoatNormalMap,
              displacementMap: !!r.displacementMap,
              roughnessMap: !!r.roughnessMap,
              metalnessMap: !!r.metalnessMap,
              specularMap: !!r.specularMap,
              alphaMap: !!r.alphaMap,
              gradientMap: !!r.gradientMap,
              sheen: !!r.sheen,
              transmissionMap: !!r.transmissionMap,
              combine: r.combine,
              vertexTangents: r.normalMap && r.vertexTangents,
              vertexColors: r.vertexColors,
              vertexUvs: !!(
                r.map ||
                r.bumpMap ||
                r.normalMap ||
                r.specularMap ||
                r.alphaMap ||
                r.emissiveMap ||
                r.roughnessMap ||
                r.metalnessMap ||
                r.clearcoatMap ||
                r.clearcoatRoughnessMap ||
                r.clearcoatNormalMap ||
                r.displacementMap ||
                r.transmissionMap
              ),
              uvsVertexOnly: !(
                r.map ||
                r.bumpMap ||
                r.normalMap ||
                r.specularMap ||
                r.alphaMap ||
                r.emissiveMap ||
                r.roughnessMap ||
                r.metalnessMap ||
                r.clearcoatNormalMap ||
                r.transmissionMap ||
                !r.displacementMap
              ),
              fog: !!y,
              useFog: r.fog,
              fogExp2: y && y.isFogExp2,
              flatShading: r.flatShading,
              sizeAttenuation: r.sizeAttenuation,
              logarithmicDepthBuffer: c,
              skinning: r.skinning && b > 0,
              maxBones: b,
              useVertexTexture: l,
              morphTargets: r.morphTargets,
              morphNormals: r.morphNormals,
              maxMorphTargets: e.maxMorphTargets,
              maxMorphNormals: e.maxMorphNormals,
              numDirLights: o.directional.length,
              numPointLights: o.point.length,
              numSpotLights: o.spot.length,
              numRectAreaLights: o.rectArea.length,
              numHemiLights: o.hemi.length,
              numDirLightShadows: o.directionalShadowMap.length,
              numPointLightShadows: o.pointShadowMap.length,
              numSpotLightShadows: o.spotShadowMap.length,
              numClippingPlanes: a.numPlanes,
              numClipIntersection: a.numIntersection,
              dithering: r.dithering,
              shadowMapEnabled: e.shadowMap.enabled && f.length > 0,
              shadowMapType: e.shadowMap.type,
              toneMapping: r.toneMapped ? e.toneMapping : 0,
              physicallyCorrectLights: e.physicallyCorrectLights,
              premultipliedAlpha: r.premultipliedAlpha,
              alphaTest: r.alphaTest,
              doubleSided: 2 === r.side,
              flipSided: 1 === r.side,
              depthPacking: void 0 !== r.depthPacking && r.depthPacking,
              index0AttributeName: r.index0AttributeName,
              extensionDerivatives: r.extensions && r.extensions.derivatives,
              extensionFragDepth: r.extensions && r.extensions.fragDepth,
              extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
              extensionShaderTextureLOD:
                r.extensions && r.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: s || n.has("EXT_frag_depth"),
              rendererExtensionDrawBuffers: s || n.has("WEBGL_draw_buffers"),
              rendererExtensionShaderTextureLod:
                s || n.has("EXT_shader_texture_lod"),
              customProgramCacheKey: r.customProgramCacheKey(),
            };
          },
          getProgramCacheKey: function (t) {
            const n = [];
            if (
              (t.shaderID
                ? n.push(t.shaderID)
                : (n.push(t.fragmentShader), n.push(t.vertexShader)),
              void 0 !== t.defines)
            )
              for (const e in t.defines) n.push(e), n.push(t.defines[e]);
            if (!1 === t.isRawShaderMaterial) {
              for (let e = 0; e < f.length; e++) n.push(t[f[e]]);
              n.push(e.outputEncoding), n.push(e.gammaFactor);
            }
            return n.push(t.customProgramCacheKey), n.join();
          },
          getUniforms: function (e) {
            const t = d[e.type];
            let n;
            if (t) {
              const e = En[t];
              n = ln.clone(e.uniforms);
            } else n = e.uniforms;
            return n;
          },
          acquireProgram: function (t, n) {
            let i;
            for (let e = 0, t = o.length; e < t; e++) {
              const t = o[e];
              if (t.cacheKey === n) {
                (i = t), ++i.usedTimes;
                break;
              }
            }
            return void 0 === i && ((i = new ir(e, n, t, r)), o.push(i)), i;
          },
          releaseProgram: function (e) {
            if (0 == --e.usedTimes) {
              const t = o.indexOf(e);
              (o[t] = o[o.length - 1]), o.pop(), e.destroy();
            }
          },
          programs: o,
        };
      }
      function ar() {
        let e = new WeakMap();
        return {
          get: function (t) {
            let n = e.get(t);
            return void 0 === n && ((n = {}), e.set(t, n)), n;
          },
          remove: function (t) {
            e.delete(t);
          },
          update: function (t, n, i) {
            e.get(t)[n] = i;
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      function or(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.program !== t.program
          ? e.program.id - t.program.id
          : e.material.id !== t.material.id
          ? e.material.id - t.material.id
          : e.z !== t.z
          ? e.z - t.z
          : e.id - t.id;
      }
      function sr(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.z !== t.z
          ? t.z - e.z
          : e.id - t.id;
      }
      function cr(e) {
        const t = [];
        let n = 0;
        const i = [],
          r = [],
          a = { id: -1 };
        function o(i, r, o, s, c, l) {
          let h = t[n];
          const u = e.get(o);
          return (
            void 0 === h
              ? ((h = {
                  id: i.id,
                  object: i,
                  geometry: r,
                  material: o,
                  program: u.program || a,
                  groupOrder: s,
                  renderOrder: i.renderOrder,
                  z: c,
                  group: l,
                }),
                (t[n] = h))
              : ((h.id = i.id),
                (h.object = i),
                (h.geometry = r),
                (h.material = o),
                (h.program = u.program || a),
                (h.groupOrder = s),
                (h.renderOrder = i.renderOrder),
                (h.z = c),
                (h.group = l)),
            n++,
            h
          );
        }
        return {
          opaque: i,
          transparent: r,
          init: function () {
            (n = 0), (i.length = 0), (r.length = 0);
          },
          push: function (e, t, n, a, s, c) {
            const l = o(e, t, n, a, s, c);
            (!0 === n.transparent ? r : i).push(l);
          },
          unshift: function (e, t, n, a, s, c) {
            const l = o(e, t, n, a, s, c);
            (!0 === n.transparent ? r : i).unshift(l);
          },
          finish: function () {
            for (let e = n, i = t.length; e < i; e++) {
              const n = t[e];
              if (null === n.id) break;
              (n.id = null),
                (n.object = null),
                (n.geometry = null),
                (n.material = null),
                (n.program = null),
                (n.group = null);
            }
          },
          sort: function (e, t) {
            i.length > 1 && i.sort(e || or), r.length > 1 && r.sort(t || sr);
          },
        };
      }
      function lr(e) {
        let t = new WeakMap();
        return {
          get: function (n, i) {
            const r = t.get(n);
            let a;
            return (
              void 0 === r
                ? ((a = new cr(e)), t.set(n, new WeakMap()), t.get(n).set(i, a))
                : ((a = r.get(i)),
                  void 0 === a && ((a = new cr(e)), r.set(i, a))),
              a
            );
          },
          dispose: function () {
            t = new WeakMap();
          },
        };
      }
      function hr() {
        const e = {};
        return {
          get: function (t) {
            if (void 0 !== e[t.id]) return e[t.id];
            let n;
            switch (t.type) {
              case "DirectionalLight":
                n = { direction: new W(), color: new ut() };
                break;
              case "SpotLight":
                n = {
                  position: new W(),
                  direction: new W(),
                  color: new ut(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                n = {
                  position: new W(),
                  color: new ut(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                n = {
                  direction: new W(),
                  skyColor: new ut(),
                  groundColor: new ut(),
                };
                break;
              case "RectAreaLight":
                n = {
                  color: new ut(),
                  position: new W(),
                  halfWidth: new W(),
                  halfHeight: new W(),
                };
            }
            return (e[t.id] = n), n;
          },
        };
      }
      let ur = 0;
      function pr(e, t) {
        return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
      }
      function dr(e, t) {
        const n = new hr(),
          i = (function () {
            const e = {};
            return {
              get: function (t) {
                if (void 0 !== e[t.id]) return e[t.id];
                let n;
                switch (t.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                    n = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new N(),
                    };
                    break;
                  case "PointLight":
                    n = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new N(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3,
                    };
                }
                return (e[t.id] = n), n;
              },
            };
          })(),
          r = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          };
        for (let e = 0; e < 9; e++) r.probe.push(new W());
        const a = new W(),
          o = new ye(),
          s = new ye();
        return {
          setup: function (a) {
            let o = 0,
              s = 0,
              c = 0;
            for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
            let l = 0,
              h = 0,
              u = 0,
              p = 0,
              d = 0,
              f = 0,
              m = 0,
              g = 0;
            a.sort(pr);
            for (let e = 0, t = a.length; e < t; e++) {
              const t = a[e],
                v = t.color,
                y = t.intensity,
                _ = t.distance,
                w = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
              if (t.isAmbientLight)
                (o += v.r * y), (s += v.g * y), (c += v.b * y);
              else if (t.isLightProbe)
                for (let e = 0; e < 9; e++)
                  r.probe[e].addScaledVector(t.sh.coefficients[e], y);
              else if (t.isDirectionalLight) {
                const e = n.get(t);
                if (
                  (e.color.copy(t.color).multiplyScalar(t.intensity),
                  t.castShadow)
                ) {
                  const e = t.shadow,
                    n = i.get(t);
                  (n.shadowBias = e.bias),
                    (n.shadowNormalBias = e.normalBias),
                    (n.shadowRadius = e.radius),
                    (n.shadowMapSize = e.mapSize),
                    (r.directionalShadow[l] = n),
                    (r.directionalShadowMap[l] = w),
                    (r.directionalShadowMatrix[l] = t.shadow.matrix),
                    f++;
                }
                (r.directional[l] = e), l++;
              } else if (t.isSpotLight) {
                const e = n.get(t);
                if (
                  (e.position.setFromMatrixPosition(t.matrixWorld),
                  e.color.copy(v).multiplyScalar(y),
                  (e.distance = _),
                  (e.coneCos = Math.cos(t.angle)),
                  (e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra))),
                  (e.decay = t.decay),
                  t.castShadow)
                ) {
                  const e = t.shadow,
                    n = i.get(t);
                  (n.shadowBias = e.bias),
                    (n.shadowNormalBias = e.normalBias),
                    (n.shadowRadius = e.radius),
                    (n.shadowMapSize = e.mapSize),
                    (r.spotShadow[u] = n),
                    (r.spotShadowMap[u] = w),
                    (r.spotShadowMatrix[u] = t.shadow.matrix),
                    g++;
                }
                (r.spot[u] = e), u++;
              } else if (t.isRectAreaLight) {
                const e = n.get(t);
                e.color.copy(v).multiplyScalar(y),
                  e.halfWidth.set(0.5 * t.width, 0, 0),
                  e.halfHeight.set(0, 0.5 * t.height, 0),
                  (r.rectArea[p] = e),
                  p++;
              } else if (t.isPointLight) {
                const e = n.get(t);
                if (
                  (e.color.copy(t.color).multiplyScalar(t.intensity),
                  (e.distance = t.distance),
                  (e.decay = t.decay),
                  t.castShadow)
                ) {
                  const e = t.shadow,
                    n = i.get(t);
                  (n.shadowBias = e.bias),
                    (n.shadowNormalBias = e.normalBias),
                    (n.shadowRadius = e.radius),
                    (n.shadowMapSize = e.mapSize),
                    (n.shadowCameraNear = e.camera.near),
                    (n.shadowCameraFar = e.camera.far),
                    (r.pointShadow[h] = n),
                    (r.pointShadowMap[h] = w),
                    (r.pointShadowMatrix[h] = t.shadow.matrix),
                    m++;
                }
                (r.point[h] = e), h++;
              } else if (t.isHemisphereLight) {
                const e = n.get(t);
                e.skyColor.copy(t.color).multiplyScalar(y),
                  e.groundColor.copy(t.groundColor).multiplyScalar(y),
                  (r.hemi[d] = e),
                  d++;
              }
            }
            p > 0 &&
              (t.isWebGL2 || !0 === e.has("OES_texture_float_linear")
                ? ((r.rectAreaLTC1 = Tn.LTC_FLOAT_1),
                  (r.rectAreaLTC2 = Tn.LTC_FLOAT_2))
                : !0 === e.has("OES_texture_half_float_linear")
                ? ((r.rectAreaLTC1 = Tn.LTC_HALF_1),
                  (r.rectAreaLTC2 = Tn.LTC_HALF_2))
                : console.error(
                    "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                  )),
              (r.ambient[0] = o),
              (r.ambient[1] = s),
              (r.ambient[2] = c);
            const v = r.hash;
            (v.directionalLength === l &&
              v.pointLength === h &&
              v.spotLength === u &&
              v.rectAreaLength === p &&
              v.hemiLength === d &&
              v.numDirectionalShadows === f &&
              v.numPointShadows === m &&
              v.numSpotShadows === g) ||
              ((r.directional.length = l),
              (r.spot.length = u),
              (r.rectArea.length = p),
              (r.point.length = h),
              (r.hemi.length = d),
              (r.directionalShadow.length = f),
              (r.directionalShadowMap.length = f),
              (r.pointShadow.length = m),
              (r.pointShadowMap.length = m),
              (r.spotShadow.length = g),
              (r.spotShadowMap.length = g),
              (r.directionalShadowMatrix.length = f),
              (r.pointShadowMatrix.length = m),
              (r.spotShadowMatrix.length = g),
              (v.directionalLength = l),
              (v.pointLength = h),
              (v.spotLength = u),
              (v.rectAreaLength = p),
              (v.hemiLength = d),
              (v.numDirectionalShadows = f),
              (v.numPointShadows = m),
              (v.numSpotShadows = g),
              (r.version = ur++));
          },
          setupView: function (e, t) {
            let n = 0,
              i = 0,
              c = 0,
              l = 0,
              h = 0;
            const u = t.matrixWorldInverse;
            for (let t = 0, p = e.length; t < p; t++) {
              const p = e[t];
              if (p.isDirectionalLight) {
                const e = r.directional[n];
                e.direction.setFromMatrixPosition(p.matrixWorld),
                  a.setFromMatrixPosition(p.target.matrixWorld),
                  e.direction.sub(a),
                  e.direction.transformDirection(u),
                  n++;
              } else if (p.isSpotLight) {
                const e = r.spot[c];
                e.position.setFromMatrixPosition(p.matrixWorld),
                  e.position.applyMatrix4(u),
                  e.direction.setFromMatrixPosition(p.matrixWorld),
                  a.setFromMatrixPosition(p.target.matrixWorld),
                  e.direction.sub(a),
                  e.direction.transformDirection(u),
                  c++;
              } else if (p.isRectAreaLight) {
                const e = r.rectArea[l];
                e.position.setFromMatrixPosition(p.matrixWorld),
                  e.position.applyMatrix4(u),
                  s.identity(),
                  o.copy(p.matrixWorld),
                  o.premultiply(u),
                  s.extractRotation(o),
                  e.halfWidth.set(0.5 * p.width, 0, 0),
                  e.halfHeight.set(0, 0.5 * p.height, 0),
                  e.halfWidth.applyMatrix4(s),
                  e.halfHeight.applyMatrix4(s),
                  l++;
              } else if (p.isPointLight) {
                const e = r.point[i];
                e.position.setFromMatrixPosition(p.matrixWorld),
                  e.position.applyMatrix4(u),
                  i++;
              } else if (p.isHemisphereLight) {
                const e = r.hemi[h];
                e.direction.setFromMatrixPosition(p.matrixWorld),
                  e.direction.transformDirection(u),
                  e.direction.normalize(),
                  h++;
              }
            }
          },
          state: r,
        };
      }
      function fr(e, t) {
        const n = new dr(e, t),
          i = [],
          r = [];
        return {
          init: function () {
            (i.length = 0), (r.length = 0);
          },
          state: { lightsArray: i, shadowsArray: r, lights: n },
          setupLights: function () {
            n.setup(i);
          },
          setupLightsView: function (e) {
            n.setupView(i, e);
          },
          pushLight: function (e) {
            i.push(e);
          },
          pushShadow: function (e) {
            r.push(e);
          },
        };
      }
      function mr(e, t) {
        let n = new WeakMap();
        return {
          get: function (i, r = 0) {
            let a;
            return (
              !1 === n.has(i)
                ? ((a = new fr(e, t)), n.set(i, []), n.get(i).push(a))
                : r >= n.get(i).length
                ? ((a = new fr(e, t)), n.get(i).push(a))
                : (a = n.get(i)[r]),
              a
            );
          },
          dispose: function () {
            n = new WeakMap();
          },
        };
      }
      function gr(e) {
        ft.call(this),
          (this.type = "MeshDepthMaterial"),
          (this.depthPacking = 3200),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          this.setValues(e);
      }
      function vr(e) {
        ft.call(this),
          (this.type = "MeshDistanceMaterial"),
          (this.referencePosition = new W()),
          (this.nearDistance = 1),
          (this.farDistance = 1e3),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.fog = !1),
          this.setValues(e);
      }
      function yr(e, t, n) {
        let i = new wn();
        const a = new N(),
          o = new N(),
          c = new z(),
          l = [],
          h = [],
          u = {},
          p = { 0: 1, 1: 0, 2: 2 },
          d = new hn({
            defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new N() },
              radius: { value: 4 },
            },
            vertexShader:
              "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader:
              "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
          }),
          f = d.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const g = new Ht();
        g.setAttribute(
          "position",
          new yt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const v = new rn(g, d),
          y = this;
        function _(n, i) {
          const r = t.update(v);
          (d.uniforms.shadow_pass.value = n.map.texture),
            (d.uniforms.resolution.value = n.mapSize),
            (d.uniforms.radius.value = n.radius),
            e.setRenderTarget(n.mapPass),
            e.clear(),
            e.renderBufferDirect(i, null, r, d, v, null),
            (f.uniforms.shadow_pass.value = n.mapPass.texture),
            (f.uniforms.resolution.value = n.mapSize),
            (f.uniforms.radius.value = n.radius),
            e.setRenderTarget(n.map),
            e.clear(),
            e.renderBufferDirect(i, null, r, f, v, null);
        }
        function w(e, t, n) {
          const i = (e << 0) | (t << 1) | (n << 2);
          let r = l[i];
          return (
            void 0 === r &&
              ((r = new gr({
                depthPacking: 3201,
                morphTargets: e,
                skinning: t,
              })),
              (l[i] = r)),
            r
          );
        }
        function x(e, t, n) {
          const i = (e << 0) | (t << 1) | (n << 2);
          let r = h[i];
          return (
            void 0 === r &&
              ((r = new vr({ morphTargets: e, skinning: t })), (h[i] = r)),
            r
          );
        }
        function b(t, n, i, r, a, o, s) {
          let c = null,
            l = w,
            h = t.customDepthMaterial;
          if (
            (!0 === r.isPointLight && ((l = x), (h = t.customDistanceMaterial)),
            void 0 === h)
          ) {
            let e = !1;
            !0 === i.morphTargets &&
              (e =
                n.morphAttributes &&
                n.morphAttributes.position &&
                n.morphAttributes.position.length > 0);
            let r = !1;
            !0 === t.isSkinnedMesh &&
              (!0 === i.skinning
                ? (r = !0)
                : console.warn(
                    "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
                    t
                  )),
              (c = l(e, r, !0 === t.isInstancedMesh));
          } else c = h;
          if (
            e.localClippingEnabled &&
            !0 === i.clipShadows &&
            0 !== i.clippingPlanes.length
          ) {
            const e = c.uuid,
              t = i.uuid;
            let n = u[e];
            void 0 === n && ((n = {}), (u[e] = n));
            let r = n[t];
            void 0 === r && ((r = c.clone()), (n[t] = r)), (c = r);
          }
          return (
            (c.visible = i.visible),
            (c.wireframe = i.wireframe),
            (c.side =
              3 === s
                ? null !== i.shadowSide
                  ? i.shadowSide
                  : i.side
                : null !== i.shadowSide
                ? i.shadowSide
                : p[i.side]),
            (c.clipShadows = i.clipShadows),
            (c.clippingPlanes = i.clippingPlanes),
            (c.clipIntersection = i.clipIntersection),
            (c.wireframeLinewidth = i.wireframeLinewidth),
            (c.linewidth = i.linewidth),
            !0 === r.isPointLight &&
              !0 === c.isMeshDistanceMaterial &&
              (c.referencePosition.setFromMatrixPosition(r.matrixWorld),
              (c.nearDistance = a),
              (c.farDistance = o)),
            c
          );
        }
        function M(n, r, a, o, s) {
          if (!1 === n.visible) return;
          if (
            n.layers.test(r.layers) &&
            (n.isMesh || n.isLine || n.isPoints) &&
            (n.castShadow || (n.receiveShadow && 3 === s)) &&
            (!n.frustumCulled || i.intersectsObject(n))
          ) {
            n.modelViewMatrix.multiplyMatrices(
              a.matrixWorldInverse,
              n.matrixWorld
            );
            const i = t.update(n),
              r = n.material;
            if (Array.isArray(r)) {
              const t = i.groups;
              for (let c = 0, l = t.length; c < l; c++) {
                const l = t[c],
                  h = r[l.materialIndex];
                if (h && h.visible) {
                  const t = b(n, i, h, o, a.near, a.far, s);
                  e.renderBufferDirect(a, null, i, t, n, l);
                }
              }
            } else if (r.visible) {
              const t = b(n, i, r, o, a.near, a.far, s);
              e.renderBufferDirect(a, null, i, t, n, null);
            }
          }
          const c = n.children;
          for (let e = 0, t = c.length; e < t; e++) M(c[e], r, a, o, s);
        }
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = 1),
          (this.render = function (t, l, h) {
            if (!1 === y.enabled) return;
            if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;
            if (0 === t.length) return;
            const u = e.getRenderTarget(),
              p = e.getActiveCubeFace(),
              d = e.getActiveMipmapLevel(),
              f = e.state;
            f.setBlending(0),
              f.buffers.color.setClear(1, 1, 1, 1),
              f.buffers.depth.setTest(!0),
              f.setScissorTest(!1);
            for (let u = 0, p = t.length; u < p; u++) {
              const p = t[u],
                d = p.shadow;
              if (void 0 === d) {
                console.warn("THREE.WebGLShadowMap:", p, "has no shadow.");
                continue;
              }
              if (!1 === d.autoUpdate && !1 === d.needsUpdate) continue;
              a.copy(d.mapSize);
              const g = d.getFrameExtents();
              if (
                (a.multiply(g),
                o.copy(d.mapSize),
                (a.x > n || a.y > n) &&
                  (a.x > n &&
                    ((o.x = Math.floor(n / g.x)),
                    (a.x = o.x * g.x),
                    (d.mapSize.x = o.x)),
                  a.y > n &&
                    ((o.y = Math.floor(n / g.y)),
                    (a.y = o.y * g.y),
                    (d.mapSize.y = o.y))),
                null === d.map && !d.isPointLightShadow && 3 === this.type)
              ) {
                const e = { minFilter: s, magFilter: s, format: m };
                (d.map = new U(a.x, a.y, e)),
                  (d.map.texture.name = p.name + ".shadowMap"),
                  (d.mapPass = new U(a.x, a.y, e)),
                  d.camera.updateProjectionMatrix();
              }
              if (null === d.map) {
                const e = { minFilter: r, magFilter: r, format: m };
                (d.map = new U(a.x, a.y, e)),
                  (d.map.texture.name = p.name + ".shadowMap"),
                  d.camera.updateProjectionMatrix();
              }
              e.setRenderTarget(d.map), e.clear();
              const v = d.getViewportCount();
              for (let e = 0; e < v; e++) {
                const t = d.getViewport(e);
                c.set(o.x * t.x, o.y * t.y, o.x * t.z, o.y * t.w),
                  f.viewport(c),
                  d.updateMatrices(p, e),
                  (i = d.getFrustum()),
                  M(l, h, d.camera, p, this.type);
              }
              d.isPointLightShadow || 3 !== this.type || _(d, h),
                (d.needsUpdate = !1);
            }
            (y.needsUpdate = !1), e.setRenderTarget(u, p, d);
          });
      }
      function _r(t, n, i) {
        const r = i.isWebGL2,
          a = new (function () {
            let e = !1;
            const n = new z();
            let i = null;
            const r = new z(0, 0, 0, 0);
            return {
              setMask: function (n) {
                i === n || e || (t.colorMask(n, n, n, n), (i = n));
              },
              setLocked: function (t) {
                e = t;
              },
              setClear: function (e, i, a, o, s) {
                !0 === s && ((e *= o), (i *= o), (a *= o)),
                  n.set(e, i, a, o),
                  !1 === r.equals(n) && (t.clearColor(e, i, a, o), r.copy(n));
              },
              reset: function () {
                (e = !1), (i = null), r.set(-1, 0, 0, 0);
              },
            };
          })(),
          o = new (function () {
            let e = !1,
              n = null,
              i = null,
              r = null;
            return {
              setTest: function (e) {
                e ? N(2929) : I(2929);
              },
              setMask: function (i) {
                n === i || e || (t.depthMask(i), (n = i));
              },
              setFunc: function (e) {
                if (i !== e) {
                  if (e)
                    switch (e) {
                      case 0:
                        t.depthFunc(512);
                        break;
                      case 1:
                        t.depthFunc(519);
                        break;
                      case 2:
                        t.depthFunc(513);
                        break;
                      case 3:
                        t.depthFunc(515);
                        break;
                      case 4:
                        t.depthFunc(514);
                        break;
                      case 5:
                        t.depthFunc(518);
                        break;
                      case 6:
                        t.depthFunc(516);
                        break;
                      case 7:
                        t.depthFunc(517);
                        break;
                      default:
                        t.depthFunc(515);
                    }
                  else t.depthFunc(515);
                  i = e;
                }
              },
              setLocked: function (t) {
                e = t;
              },
              setClear: function (e) {
                r !== e && (t.clearDepth(e), (r = e));
              },
              reset: function () {
                (e = !1), (n = null), (i = null), (r = null);
              },
            };
          })(),
          s = new (function () {
            let e = !1,
              n = null,
              i = null,
              r = null,
              a = null,
              o = null,
              s = null,
              c = null,
              l = null;
            return {
              setTest: function (t) {
                e || (t ? N(2960) : I(2960));
              },
              setMask: function (i) {
                n === i || e || (t.stencilMask(i), (n = i));
              },
              setFunc: function (e, n, o) {
                (i === e && r === n && a === o) ||
                  (t.stencilFunc(e, n, o), (i = e), (r = n), (a = o));
              },
              setOp: function (e, n, i) {
                (o === e && s === n && c === i) ||
                  (t.stencilOp(e, n, i), (o = e), (s = n), (c = i));
              },
              setLocked: function (t) {
                e = t;
              },
              setClear: function (e) {
                l !== e && (t.clearStencil(e), (l = e));
              },
              reset: function () {
                (e = !1),
                  (n = null),
                  (i = null),
                  (r = null),
                  (a = null),
                  (o = null),
                  (s = null),
                  (c = null),
                  (l = null);
              },
            };
          })();
        let c = {},
          l = null,
          h = null,
          u = null,
          p = null,
          d = null,
          f = null,
          m = null,
          g = null,
          v = null,
          y = !1,
          _ = null,
          w = null,
          x = null,
          b = null,
          M = null;
        const S = t.getParameter(35661);
        let T = !1,
          E = 0;
        const A = t.getParameter(7938);
        -1 !== A.indexOf("WebGL")
          ? ((E = parseFloat(/^WebGL (\d)/.exec(A)[1])), (T = E >= 1))
          : -1 !== A.indexOf("OpenGL ES") &&
            ((E = parseFloat(/^OpenGL ES (\d)/.exec(A)[1])), (T = E >= 2));
        let L = null,
          P = {};
        const R = new z(),
          k = new z();
        function C(e, n, i) {
          const r = new Uint8Array(4),
            a = t.createTexture();
          t.bindTexture(e, a),
            t.texParameteri(e, 10241, 9728),
            t.texParameteri(e, 10240, 9728);
          for (let e = 0; e < i; e++)
            t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
          return a;
        }
        const O = {};
        function N(e) {
          !0 !== c[e] && (t.enable(e), (c[e] = !0));
        }
        function I(e) {
          !1 !== c[e] && (t.disable(e), (c[e] = !1));
        }
        (O[3553] = C(3553, 3553, 1)),
          (O[34067] = C(34067, 34069, 6)),
          a.setClear(0, 0, 0, 1),
          o.setClear(1),
          s.setClear(0),
          N(2929),
          o.setFunc(3),
          H(!1),
          B(1),
          N(2884),
          F(0);
        const D = { [e]: 32774, 101: 32778, 102: 32779 };
        if (r) (D[103] = 32775), (D[104] = 32776);
        else {
          const e = n.get("EXT_blend_minmax");
          null !== e && ((D[103] = e.MIN_EXT), (D[104] = e.MAX_EXT));
        }
        const j = {
          200: 0,
          201: 1,
          202: 768,
          204: 770,
          210: 776,
          208: 774,
          206: 772,
          203: 769,
          205: 771,
          209: 775,
          207: 773,
        };
        function F(n, i, r, a, o, s, c, l) {
          if (0 !== n) {
            if ((h || (N(3042), (h = !0)), 5 === n))
              (o = o || i),
                (s = s || r),
                (c = c || a),
                (i === p && o === m) ||
                  (t.blendEquationSeparate(D[i], D[o]), (p = i), (m = o)),
                (r === d && a === f && s === g && c === v) ||
                  (t.blendFuncSeparate(j[r], j[a], j[s], j[c]),
                  (d = r),
                  (f = a),
                  (g = s),
                  (v = c)),
                (u = n),
                (y = null);
            else if (n !== u || l !== y) {
              if (
                ((p === e && m === e) ||
                  (t.blendEquation(32774), (p = e), (m = e)),
                l)
              )
                switch (n) {
                  case 1:
                    t.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case 2:
                    t.blendFunc(1, 1);
                    break;
                  case 3:
                    t.blendFuncSeparate(0, 0, 769, 771);
                    break;
                  case 4:
                    t.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", n);
                }
              else
                switch (n) {
                  case 1:
                    t.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case 2:
                    t.blendFunc(770, 1);
                    break;
                  case 3:
                    t.blendFunc(0, 769);
                    break;
                  case 4:
                    t.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", n);
                }
              (d = null), (f = null), (g = null), (v = null), (u = n), (y = l);
            }
          } else h && (I(3042), (h = !1));
        }
        function H(e) {
          _ !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (_ = e));
        }
        function B(e) {
          0 !== e
            ? (N(2884),
              e !== w &&
                (1 === e
                  ? t.cullFace(1029)
                  : 2 === e
                  ? t.cullFace(1028)
                  : t.cullFace(1032)))
            : I(2884),
            (w = e);
        }
        function U(e, n, i) {
          e
            ? (N(32823),
              (b === n && M === i) || (t.polygonOffset(n, i), (b = n), (M = i)))
            : I(32823);
        }
        function G(e) {
          void 0 === e && (e = 33984 + S - 1),
            L !== e && (t.activeTexture(e), (L = e));
        }
        return {
          buffers: { color: a, depth: o, stencil: s },
          enable: N,
          disable: I,
          useProgram: function (e) {
            return l !== e && (t.useProgram(e), (l = e), !0);
          },
          setBlending: F,
          setMaterial: function (e, t) {
            2 === e.side ? I(2884) : N(2884);
            let n = 1 === e.side;
            t && (n = !n),
              H(n),
              1 === e.blending && !1 === e.transparent
                ? F(0)
                : F(
                    e.blending,
                    e.blendEquation,
                    e.blendSrc,
                    e.blendDst,
                    e.blendEquationAlpha,
                    e.blendSrcAlpha,
                    e.blendDstAlpha,
                    e.premultipliedAlpha
                  ),
              o.setFunc(e.depthFunc),
              o.setTest(e.depthTest),
              o.setMask(e.depthWrite),
              a.setMask(e.colorWrite);
            const i = e.stencilWrite;
            s.setTest(i),
              i &&
                (s.setMask(e.stencilWriteMask),
                s.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                s.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
              U(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits);
          },
          setFlipSided: H,
          setCullFace: B,
          setLineWidth: function (e) {
            e !== x && (T && t.lineWidth(e), (x = e));
          },
          setPolygonOffset: U,
          setScissorTest: function (e) {
            e ? N(3089) : I(3089);
          },
          activeTexture: G,
          bindTexture: function (e, n) {
            null === L && G();
            let i = P[L];
            void 0 === i &&
              ((i = { type: void 0, texture: void 0 }), (P[L] = i)),
              (i.type === e && i.texture === n) ||
                (t.bindTexture(e, n || O[e]), (i.type = e), (i.texture = n));
          },
          unbindTexture: function () {
            const e = P[L];
            void 0 !== e &&
              void 0 !== e.type &&
              (t.bindTexture(e.type, null),
              (e.type = void 0),
              (e.texture = void 0));
          },
          compressedTexImage2D: function () {
            try {
              t.compressedTexImage2D.apply(t, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texImage2D: function () {
            try {
              t.texImage2D.apply(t, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texImage3D: function () {
            try {
              t.texImage3D.apply(t, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          scissor: function (e) {
            !1 === R.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), R.copy(e));
          },
          viewport: function (e) {
            !1 === k.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), k.copy(e));
          },
          reset: function () {
            (c = {}),
              (L = null),
              (P = {}),
              (l = null),
              (h = null),
              (u = null),
              (p = null),
              (d = null),
              (f = null),
              (m = null),
              (g = null),
              (v = null),
              (y = !1),
              (_ = null),
              (w = null),
              (x = null),
              (b = null),
              (M = null),
              a.reset(),
              o.reset(),
              s.reset();
          },
        };
      }
      function wr(e, y, _, w, x, b, M) {
        const S = x.isWebGL2,
          T = x.maxTextures,
          E = x.maxCubemapSize,
          A = x.maxTextureSize,
          L = x.maxSamples,
          P = new WeakMap();
        let R,
          k = !1;
        try {
          k =
            "undefined" != typeof OffscreenCanvas &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (e) {}
        function C(e, t) {
          return k
            ? new OffscreenCanvas(e, t)
            : document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              );
        }
        function N(e, t, n, i) {
          let r = 1;
          if (
            ((e.width > i || e.height > i) &&
              (r = i / Math.max(e.width, e.height)),
            r < 1 || !0 === t)
          ) {
            if (
              ("undefined" != typeof HTMLImageElement &&
                e instanceof HTMLImageElement) ||
              ("undefined" != typeof HTMLCanvasElement &&
                e instanceof HTMLCanvasElement) ||
              ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
            ) {
              const i = t ? O.floorPowerOfTwo : Math.floor,
                a = i(r * e.width),
                o = i(r * e.height);
              void 0 === R && (R = C(a, o));
              const s = n ? C(a, o) : R;
              return (
                (s.width = a),
                (s.height = o),
                s.getContext("2d").drawImage(e, 0, 0, a, o),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    e.width +
                    "x" +
                    e.height +
                    ") to (" +
                    a +
                    "x" +
                    o +
                    ")."
                ),
                s
              );
            }
            return (
              "data" in e &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                    e.width +
                    "x" +
                    e.height +
                    ")."
                ),
              e
            );
          }
          return e;
        }
        function I(e) {
          return O.isPowerOfTwo(e.width) && O.isPowerOfTwo(e.height);
        }
        function D(e, t) {
          return (
            e.generateMipmaps && t && e.minFilter !== r && e.minFilter !== s
          );
        }
        function j(t, n, i, r) {
          e.generateMipmap(t),
            (w.get(n).__maxMipLevel = Math.log(Math.max(i, r)) * Math.LOG2E);
        }
        function F(t, n, i) {
          if (!1 === S) return n;
          if (null !== t) {
            if (void 0 !== e[t]) return e[t];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                t +
                "'"
            );
          }
          let r = n;
          return (
            6403 === n &&
              (5126 === i && (r = 33326),
              5131 === i && (r = 33325),
              5121 === i && (r = 33321)),
            6407 === n &&
              (5126 === i && (r = 34837),
              5131 === i && (r = 34843),
              5121 === i && (r = 32849)),
            6408 === n &&
              (5126 === i && (r = 34836),
              5131 === i && (r = 34842),
              5121 === i && (r = 32856)),
            (33325 !== r && 33326 !== r && 34842 !== r && 34836 !== r) ||
              y.get("EXT_color_buffer_float"),
            r
          );
        }
        function H(e) {
          return e === r || e === a || e === o ? 9728 : 9729;
        }
        function B(t) {
          const n = t.target;
          n.removeEventListener("dispose", B),
            (function (t) {
              const n = w.get(t);
              void 0 !== n.__webglInit &&
                (e.deleteTexture(n.__webglTexture), w.remove(t));
            })(n),
            n.isVideoTexture && P.delete(n),
            M.memory.textures--;
        }
        function z(t) {
          const n = t.target;
          n.removeEventListener("dispose", z),
            (function (t) {
              const n = w.get(t),
                i = w.get(t.texture);
              if (t) {
                if (
                  (void 0 !== i.__webglTexture &&
                    e.deleteTexture(i.__webglTexture),
                  t.depthTexture && t.depthTexture.dispose(),
                  t.isWebGLCubeRenderTarget)
                )
                  for (let t = 0; t < 6; t++)
                    e.deleteFramebuffer(n.__webglFramebuffer[t]),
                      n.__webglDepthbuffer &&
                        e.deleteRenderbuffer(n.__webglDepthbuffer[t]);
                else
                  e.deleteFramebuffer(n.__webglFramebuffer),
                    n.__webglDepthbuffer &&
                      e.deleteRenderbuffer(n.__webglDepthbuffer),
                    n.__webglMultisampledFramebuffer &&
                      e.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                    n.__webglColorRenderbuffer &&
                      e.deleteRenderbuffer(n.__webglColorRenderbuffer),
                    n.__webglDepthRenderbuffer &&
                      e.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                w.remove(t.texture), w.remove(t);
              }
            })(n),
            M.memory.textures--;
        }
        let U = 0;
        function G(e, t) {
          const n = w.get(e);
          if (
            (e.isVideoTexture &&
              (function (e) {
                const t = M.render.frame;
                P.get(e) !== t && (P.set(e, t), e.update());
              })(e),
            e.version > 0 && n.__version !== e.version)
          ) {
            const i = e.image;
            if (void 0 === i)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is undefined"
              );
            else {
              if (!1 !== i.complete) return void J(n, e, t);
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            }
          }
          _.activeTexture(33984 + t), _.bindTexture(3553, n.__webglTexture);
        }
        function W(t, n) {
          const i = w.get(t);
          t.version > 0 && i.__version !== t.version
            ? (function (t, n, i) {
                if (6 !== n.image.length) return;
                Y(t, n),
                  _.activeTexture(33984 + i),
                  _.bindTexture(34067, t.__webglTexture),
                  e.pixelStorei(37440, n.flipY),
                  e.pixelStorei(37441, n.premultiplyAlpha),
                  e.pixelStorei(3317, n.unpackAlignment);
                const r =
                    n &&
                    (n.isCompressedTexture || n.image[0].isCompressedTexture),
                  a = n.image[0] && n.image[0].isDataTexture,
                  o = [];
                for (let e = 0; e < 6; e++)
                  o[e] =
                    r || a
                      ? a
                        ? n.image[e].image
                        : n.image[e]
                      : N(n.image[e], !1, !0, E);
                const s = o[0],
                  c = I(s) || S,
                  l = b.convert(n.format),
                  h = b.convert(n.type),
                  u = F(n.internalFormat, l, h);
                let p;
                if ((X(34067, n, c), r)) {
                  for (let e = 0; e < 6; e++) {
                    p = o[e].mipmaps;
                    for (let t = 0; t < p.length; t++) {
                      const i = p[t];
                      n.format !== m && n.format !== f
                        ? null !== l
                          ? _.compressedTexImage2D(
                              34069 + e,
                              t,
                              u,
                              i.width,
                              i.height,
                              0,
                              i.data
                            )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                            )
                        : _.texImage2D(
                            34069 + e,
                            t,
                            u,
                            i.width,
                            i.height,
                            0,
                            l,
                            h,
                            i.data
                          );
                    }
                  }
                  t.__maxMipLevel = p.length - 1;
                } else {
                  p = n.mipmaps;
                  for (let e = 0; e < 6; e++)
                    if (a) {
                      _.texImage2D(
                        34069 + e,
                        0,
                        u,
                        o[e].width,
                        o[e].height,
                        0,
                        l,
                        h,
                        o[e].data
                      );
                      for (let t = 0; t < p.length; t++) {
                        const n = p[t].image[e].image;
                        _.texImage2D(
                          34069 + e,
                          t + 1,
                          u,
                          n.width,
                          n.height,
                          0,
                          l,
                          h,
                          n.data
                        );
                      }
                    } else {
                      _.texImage2D(34069 + e, 0, u, l, h, o[e]);
                      for (let t = 0; t < p.length; t++) {
                        const n = p[t];
                        _.texImage2D(34069 + e, t + 1, u, l, h, n.image[e]);
                      }
                    }
                  t.__maxMipLevel = p.length;
                }
                D(n, c) && j(34067, n, s.width, s.height),
                  (t.__version = n.version),
                  n.onUpdate && n.onUpdate(n);
              })(i, t, n)
            : (_.activeTexture(33984 + n),
              _.bindTexture(34067, i.__webglTexture));
        }
        const V = { [t]: 10497, [n]: 33071, [i]: 33648 },
          q = {
            [r]: 9728,
            [a]: 9984,
            [o]: 9986,
            [s]: 9729,
            1007: 9985,
            [c]: 9987,
          };
        function X(t, i, a) {
          a
            ? (e.texParameteri(t, 10242, V[i.wrapS]),
              e.texParameteri(t, 10243, V[i.wrapT]),
              (32879 !== t && 35866 !== t) ||
                e.texParameteri(t, 32882, V[i.wrapR]),
              e.texParameteri(t, 10240, q[i.magFilter]),
              e.texParameteri(t, 10241, q[i.minFilter]))
            : (e.texParameteri(t, 10242, 33071),
              e.texParameteri(t, 10243, 33071),
              (32879 !== t && 35866 !== t) || e.texParameteri(t, 32882, 33071),
              (i.wrapS === n && i.wrapT === n) ||
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                ),
              e.texParameteri(t, 10240, H(i.magFilter)),
              e.texParameteri(t, 10241, H(i.minFilter)),
              i.minFilter !== r &&
                i.minFilter !== s &&
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                ));
          const o = y.get("EXT_texture_filter_anisotropic");
          if (o) {
            if (i.type === u && null === y.get("OES_texture_float_linear"))
              return;
            if (
              i.type === p &&
              null === (S || y.get("OES_texture_half_float_linear"))
            )
              return;
            (i.anisotropy > 1 || w.get(i).__currentAnisotropy) &&
              (e.texParameterf(
                t,
                o.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(i.anisotropy, x.getMaxAnisotropy())
              ),
              (w.get(i).__currentAnisotropy = i.anisotropy));
          }
        }
        function Y(t, n) {
          void 0 === t.__webglInit &&
            ((t.__webglInit = !0),
            n.addEventListener("dispose", B),
            (t.__webglTexture = e.createTexture()),
            M.memory.textures++);
        }
        function J(t, i, a) {
          let o = 3553;
          i.isDataTexture2DArray && (o = 35866),
            i.isDataTexture3D && (o = 32879),
            Y(t, i),
            _.activeTexture(33984 + a),
            _.bindTexture(o, t.__webglTexture),
            e.pixelStorei(37440, i.flipY),
            e.pixelStorei(37441, i.premultiplyAlpha),
            e.pixelStorei(3317, i.unpackAlignment);
          const c =
              (function (e) {
                return (
                  !S &&
                  (e.wrapS !== n ||
                    e.wrapT !== n ||
                    (e.minFilter !== r && e.minFilter !== s))
                );
              })(i) && !1 === I(i.image),
            p = N(i.image, c, !1, A),
            y = I(p) || S,
            w = b.convert(i.format);
          let x,
            M = b.convert(i.type),
            T = F(i.internalFormat, w, M);
          X(o, i, y);
          const E = i.mipmaps;
          if (i.isDepthTexture)
            (T = 6402),
              S
                ? (T =
                    i.type === u
                      ? 36012
                      : i.type === h
                      ? 33190
                      : i.type === d
                      ? 35056
                      : 33189)
                : i.type === u &&
                  console.error(
                    "WebGLRenderer: Floating point depth texture requires WebGL2."
                  ),
              i.format === g &&
                6402 === T &&
                i.type !== l &&
                i.type !== h &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                ),
                (i.type = l),
                (M = b.convert(i.type))),
              i.format === v &&
                6402 === T &&
                ((T = 34041),
                i.type !== d &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                  ),
                  (i.type = d),
                  (M = b.convert(i.type)))),
              _.texImage2D(3553, 0, T, p.width, p.height, 0, w, M, null);
          else if (i.isDataTexture)
            if (E.length > 0 && y) {
              for (let e = 0, t = E.length; e < t; e++)
                (x = E[e]),
                  _.texImage2D(3553, e, T, x.width, x.height, 0, w, M, x.data);
              (i.generateMipmaps = !1), (t.__maxMipLevel = E.length - 1);
            } else
              _.texImage2D(3553, 0, T, p.width, p.height, 0, w, M, p.data),
                (t.__maxMipLevel = 0);
          else if (i.isCompressedTexture) {
            for (let e = 0, t = E.length; e < t; e++)
              (x = E[e]),
                i.format !== m && i.format !== f
                  ? null !== w
                    ? _.compressedTexImage2D(
                        3553,
                        e,
                        T,
                        x.width,
                        x.height,
                        0,
                        x.data
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : _.texImage2D(
                      3553,
                      e,
                      T,
                      x.width,
                      x.height,
                      0,
                      w,
                      M,
                      x.data
                    );
            t.__maxMipLevel = E.length - 1;
          } else if (i.isDataTexture2DArray)
            _.texImage3D(
              35866,
              0,
              T,
              p.width,
              p.height,
              p.depth,
              0,
              w,
              M,
              p.data
            ),
              (t.__maxMipLevel = 0);
          else if (i.isDataTexture3D)
            _.texImage3D(
              32879,
              0,
              T,
              p.width,
              p.height,
              p.depth,
              0,
              w,
              M,
              p.data
            ),
              (t.__maxMipLevel = 0);
          else if (E.length > 0 && y) {
            for (let e = 0, t = E.length; e < t; e++)
              (x = E[e]), _.texImage2D(3553, e, T, w, M, x);
            (i.generateMipmaps = !1), (t.__maxMipLevel = E.length - 1);
          } else _.texImage2D(3553, 0, T, w, M, p), (t.__maxMipLevel = 0);
          D(i, y) && j(o, i, p.width, p.height),
            (t.__version = i.version),
            i.onUpdate && i.onUpdate(i);
        }
        function Z(t, n, i, r) {
          const a = b.convert(n.texture.format),
            o = b.convert(n.texture.type),
            s = F(n.texture.internalFormat, a, o);
          _.texImage2D(r, 0, s, n.width, n.height, 0, a, o, null),
            e.bindFramebuffer(36160, t),
            e.framebufferTexture2D(
              36160,
              i,
              r,
              w.get(n.texture).__webglTexture,
              0
            ),
            e.bindFramebuffer(36160, null);
        }
        function Q(t, n, i) {
          if (
            (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer)
          ) {
            let r = 33189;
            if (i) {
              const t = n.depthTexture;
              t &&
                t.isDepthTexture &&
                (t.type === u ? (r = 36012) : t.type === h && (r = 33190));
              const i = K(n);
              e.renderbufferStorageMultisample(36161, i, r, n.width, n.height);
            } else e.renderbufferStorage(36161, r, n.width, n.height);
            e.framebufferRenderbuffer(36160, 36096, 36161, t);
          } else if (n.depthBuffer && n.stencilBuffer) {
            if (i) {
              const t = K(n);
              e.renderbufferStorageMultisample(
                36161,
                t,
                35056,
                n.width,
                n.height
              );
            } else e.renderbufferStorage(36161, 34041, n.width, n.height);
            e.framebufferRenderbuffer(36160, 33306, 36161, t);
          } else {
            const t = b.convert(n.texture.format),
              r = b.convert(n.texture.type),
              a = F(n.texture.internalFormat, t, r);
            if (i) {
              const t = K(n);
              e.renderbufferStorageMultisample(36161, t, a, n.width, n.height);
            } else e.renderbufferStorage(36161, a, n.width, n.height);
          }
          e.bindRenderbuffer(36161, null);
        }
        function K(e) {
          return S && e.isWebGLMultisampleRenderTarget
            ? Math.min(L, e.samples)
            : 0;
        }
        let $ = !1,
          ee = !1;
        (this.allocateTextureUnit = function () {
          const e = U;
          return (
            e >= T &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  e +
                  " texture units while this GPU supports only " +
                  T
              ),
            (U += 1),
            e
          );
        }),
          (this.resetTextureUnits = function () {
            U = 0;
          }),
          (this.setTexture2D = G),
          (this.setTexture2DArray = function (e, t) {
            const n = w.get(e);
            e.version > 0 && n.__version !== e.version
              ? J(n, e, t)
              : (_.activeTexture(33984 + t),
                _.bindTexture(35866, n.__webglTexture));
          }),
          (this.setTexture3D = function (e, t) {
            const n = w.get(e);
            e.version > 0 && n.__version !== e.version
              ? J(n, e, t)
              : (_.activeTexture(33984 + t),
                _.bindTexture(32879, n.__webglTexture));
          }),
          (this.setTextureCube = W),
          (this.setupRenderTarget = function (t) {
            const n = w.get(t),
              i = w.get(t.texture);
            t.addEventListener("dispose", z),
              (i.__webglTexture = e.createTexture()),
              M.memory.textures++;
            const r = !0 === t.isWebGLCubeRenderTarget,
              a = !0 === t.isWebGLMultisampleRenderTarget,
              o = I(t) || S;
            if (
              (!S ||
                t.texture.format !== f ||
                (t.texture.type !== u && t.texture.type !== p) ||
                ((t.texture.format = m),
                console.warn(
                  "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
                )),
              r)
            ) {
              n.__webglFramebuffer = [];
              for (let t = 0; t < 6; t++)
                n.__webglFramebuffer[t] = e.createFramebuffer();
            } else if (((n.__webglFramebuffer = e.createFramebuffer()), a))
              if (S) {
                (n.__webglMultisampledFramebuffer = e.createFramebuffer()),
                  (n.__webglColorRenderbuffer = e.createRenderbuffer()),
                  e.bindRenderbuffer(36161, n.__webglColorRenderbuffer);
                const i = b.convert(t.texture.format),
                  r = b.convert(t.texture.type),
                  a = F(t.texture.internalFormat, i, r),
                  o = K(t);
                e.renderbufferStorageMultisample(
                  36161,
                  o,
                  a,
                  t.width,
                  t.height
                ),
                  e.bindFramebuffer(36160, n.__webglMultisampledFramebuffer),
                  e.framebufferRenderbuffer(
                    36160,
                    36064,
                    36161,
                    n.__webglColorRenderbuffer
                  ),
                  e.bindRenderbuffer(36161, null),
                  t.depthBuffer &&
                    ((n.__webglDepthRenderbuffer = e.createRenderbuffer()),
                    Q(n.__webglDepthRenderbuffer, t, !0)),
                  e.bindFramebuffer(36160, null);
              } else
                console.warn(
                  "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                );
            if (r) {
              _.bindTexture(34067, i.__webglTexture), X(34067, t.texture, o);
              for (let e = 0; e < 6; e++)
                Z(n.__webglFramebuffer[e], t, 36064, 34069 + e);
              D(t.texture, o) && j(34067, t.texture, t.width, t.height),
                _.bindTexture(34067, null);
            } else
              _.bindTexture(3553, i.__webglTexture),
                X(3553, t.texture, o),
                Z(n.__webglFramebuffer, t, 36064, 3553),
                D(t.texture, o) && j(3553, t.texture, t.width, t.height),
                _.bindTexture(3553, null);
            t.depthBuffer &&
              (function (t) {
                const n = w.get(t),
                  i = !0 === t.isWebGLCubeRenderTarget;
                if (t.depthTexture) {
                  if (i)
                    throw new Error(
                      "target.depthTexture not supported in Cube render targets"
                    );
                  !(function (t, n) {
                    if (n && n.isWebGLCubeRenderTarget)
                      throw new Error(
                        "Depth Texture with cube render targets is not supported"
                      );
                    if (
                      (e.bindFramebuffer(36160, t),
                      !n.depthTexture || !n.depthTexture.isDepthTexture)
                    )
                      throw new Error(
                        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                      );
                    (w.get(n.depthTexture).__webglTexture &&
                      n.depthTexture.image.width === n.width &&
                      n.depthTexture.image.height === n.height) ||
                      ((n.depthTexture.image.width = n.width),
                      (n.depthTexture.image.height = n.height),
                      (n.depthTexture.needsUpdate = !0)),
                      G(n.depthTexture, 0);
                    const i = w.get(n.depthTexture).__webglTexture;
                    if (n.depthTexture.format === g)
                      e.framebufferTexture2D(36160, 36096, 3553, i, 0);
                    else {
                      if (n.depthTexture.format !== v)
                        throw new Error("Unknown depthTexture format");
                      e.framebufferTexture2D(36160, 33306, 3553, i, 0);
                    }
                  })(n.__webglFramebuffer, t);
                } else if (i) {
                  n.__webglDepthbuffer = [];
                  for (let i = 0; i < 6; i++)
                    e.bindFramebuffer(36160, n.__webglFramebuffer[i]),
                      (n.__webglDepthbuffer[i] = e.createRenderbuffer()),
                      Q(n.__webglDepthbuffer[i], t, !1);
                } else
                  e.bindFramebuffer(36160, n.__webglFramebuffer),
                    (n.__webglDepthbuffer = e.createRenderbuffer()),
                    Q(n.__webglDepthbuffer, t, !1);
                e.bindFramebuffer(36160, null);
              })(t);
          }),
          (this.updateRenderTargetMipmap = function (e) {
            const t = e.texture;
            if (D(t, I(e) || S)) {
              const n = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                i = w.get(t).__webglTexture;
              _.bindTexture(n, i),
                j(n, t, e.width, e.height),
                _.bindTexture(n, null);
            }
          }),
          (this.updateMultisampleRenderTarget = function (t) {
            if (t.isWebGLMultisampleRenderTarget)
              if (S) {
                const n = w.get(t);
                e.bindFramebuffer(36008, n.__webglMultisampledFramebuffer),
                  e.bindFramebuffer(36009, n.__webglFramebuffer);
                const i = t.width,
                  r = t.height;
                let a = 16384;
                t.depthBuffer && (a |= 256),
                  t.stencilBuffer && (a |= 1024),
                  e.blitFramebuffer(0, 0, i, r, 0, 0, i, r, a, 9728),
                  e.bindFramebuffer(36160, n.__webglMultisampledFramebuffer);
              } else
                console.warn(
                  "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                );
          }),
          (this.safeSetTexture2D = function (e, t) {
            e &&
              e.isWebGLRenderTarget &&
              (!1 === $ &&
                (console.warn(
                  "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
                ),
                ($ = !0)),
              (e = e.texture)),
              G(e, t);
          }),
          (this.safeSetTextureCube = function (e, t) {
            e &&
              e.isWebGLCubeRenderTarget &&
              (!1 === ee &&
                (console.warn(
                  "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                ),
                (ee = !0)),
              (e = e.texture)),
              W(e, t);
          });
      }
      function xr(e, t, n) {
        const i = n.isWebGL2;
        return {
          convert: function (e) {
            let n;
            if (1009 === e) return 5121;
            if (1017 === e) return 32819;
            if (1018 === e) return 32820;
            if (1019 === e) return 33635;
            if (1010 === e) return 5120;
            if (1011 === e) return 5122;
            if (e === l) return 5123;
            if (1013 === e) return 5124;
            if (e === h) return 5125;
            if (e === u) return 5126;
            if (e === p)
              return i
                ? 5131
                : ((n = t.get("OES_texture_half_float")),
                  null !== n ? n.HALF_FLOAT_OES : null);
            if (1021 === e) return 6406;
            if (e === f) return 6407;
            if (e === m) return 6408;
            if (1024 === e) return 6409;
            if (1025 === e) return 6410;
            if (e === g) return 6402;
            if (e === v) return 34041;
            if (1028 === e) return 6403;
            if (1029 === e) return 36244;
            if (1030 === e) return 33319;
            if (1031 === e) return 33320;
            if (1032 === e) return 36248;
            if (1033 === e) return 36249;
            if (33776 === e || 33777 === e || 33778 === e || 33779 === e) {
              if (((n = t.get("WEBGL_compressed_texture_s3tc")), null === n))
                return null;
              if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
            if (35840 === e || 35841 === e || 35842 === e || 35843 === e) {
              if (((n = t.get("WEBGL_compressed_texture_pvrtc")), null === n))
                return null;
              if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (36196 === e)
              return (
                (n = t.get("WEBGL_compressed_texture_etc1")),
                null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
              );
            if (
              (37492 === e || 37496 === e) &&
              ((n = t.get("WEBGL_compressed_texture_etc")), null !== n)
            ) {
              if (37492 === e) return n.COMPRESSED_RGB8_ETC2;
              if (37496 === e) return n.COMPRESSED_RGBA8_ETC2_EAC;
            }
            return 37808 === e ||
              37809 === e ||
              37810 === e ||
              37811 === e ||
              37812 === e ||
              37813 === e ||
              37814 === e ||
              37815 === e ||
              37816 === e ||
              37817 === e ||
              37818 === e ||
              37819 === e ||
              37820 === e ||
              37821 === e ||
              37840 === e ||
              37841 === e ||
              37842 === e ||
              37843 === e ||
              37844 === e ||
              37845 === e ||
              37846 === e ||
              37847 === e ||
              37848 === e ||
              37849 === e ||
              37850 === e ||
              37851 === e ||
              37852 === e ||
              37853 === e
              ? ((n = t.get("WEBGL_compressed_texture_astc")),
                null !== n ? e : null)
              : 36492 === e
              ? ((n = t.get("EXT_texture_compression_bptc")),
                null !== n ? e : null)
              : e === d
              ? i
                ? 34042
                : ((n = t.get("WEBGL_depth_texture")),
                  null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
              : void 0;
          },
        };
      }
      function br(e = []) {
        pn.call(this), (this.cameras = e);
      }
      function Mr() {
        Ge.call(this), (this.type = "Group");
      }
      function Sr() {
        (this._targetRay = null), (this._grip = null), (this._hand = null);
      }
      function Tr(e, t) {
        const n = this;
        let i = null,
          r = 1,
          a = null,
          o = "local-floor",
          s = null;
        const c = [],
          l = new Map(),
          h = new pn();
        h.layers.enable(1), (h.viewport = new z());
        const u = new pn();
        u.layers.enable(2), (u.viewport = new z());
        const p = [h, u],
          d = new br();
        d.layers.enable(1), d.layers.enable(2);
        let f = null,
          m = null;
        function g(e) {
          const t = l.get(e.inputSource);
          t && t.dispatchEvent({ type: e.type, data: e.inputSource });
        }
        function v() {
          l.forEach(function (e, t) {
            e.disconnect(t);
          }),
            l.clear(),
            (f = null),
            (m = null),
            e.setFramebuffer(null),
            e.setRenderTarget(e.getRenderTarget()),
            M.stop(),
            (n.isPresenting = !1),
            n.dispatchEvent({ type: "sessionend" });
        }
        function y(e) {
          const t = i.inputSources;
          for (let e = 0; e < c.length; e++) l.set(t[e], c[e]);
          for (let t = 0; t < e.removed.length; t++) {
            const n = e.removed[t],
              i = l.get(n);
            i &&
              (i.dispatchEvent({ type: "disconnected", data: n }), l.delete(n));
          }
          for (let t = 0; t < e.added.length; t++) {
            const n = e.added[t],
              i = l.get(n);
            i && i.dispatchEvent({ type: "connected", data: n });
          }
        }
        (this.enabled = !1),
          (this.isPresenting = !1),
          (this.getController = function (e) {
            let t = c[e];
            return (
              void 0 === t && ((t = new Sr()), (c[e] = t)),
              t.getTargetRaySpace()
            );
          }),
          (this.getControllerGrip = function (e) {
            let t = c[e];
            return (
              void 0 === t && ((t = new Sr()), (c[e] = t)), t.getGripSpace()
            );
          }),
          (this.getHand = function (e) {
            let t = c[e];
            return (
              void 0 === t && ((t = new Sr()), (c[e] = t)), t.getHandSpace()
            );
          }),
          (this.setFramebufferScaleFactor = function (e) {
            (r = e),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
          (this.setReferenceSpaceType = function (e) {
            (o = e),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change reference space type while presenting."
                );
          }),
          (this.getReferenceSpace = function () {
            return a;
          }),
          (this.getSession = function () {
            return i;
          }),
          (this.setSession = async function (e) {
            if (((i = e), null !== i)) {
              i.addEventListener("select", g),
                i.addEventListener("selectstart", g),
                i.addEventListener("selectend", g),
                i.addEventListener("squeeze", g),
                i.addEventListener("squeezestart", g),
                i.addEventListener("squeezeend", g),
                i.addEventListener("end", v),
                i.addEventListener("inputsourceschange", y);
              const e = t.getContextAttributes();
              !0 !== e.xrCompatible && (await t.makeXRCompatible());
              const s = {
                  antialias: e.antialias,
                  alpha: e.alpha,
                  depth: e.depth,
                  stencil: e.stencil,
                  framebufferScaleFactor: r,
                },
                c = new XRWebGLLayer(i, t, s);
              i.updateRenderState({ baseLayer: c }),
                (a = await i.requestReferenceSpace(o)),
                M.setContext(i),
                M.start(),
                (n.isPresenting = !0),
                n.dispatchEvent({ type: "sessionstart" });
            }
          });
        const _ = new W(),
          w = new W();
        function x(e, t) {
          null === t
            ? e.matrixWorld.copy(e.matrix)
            : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.copy(e.matrixWorld).invert();
        }
        this.getCamera = function (e) {
          (d.near = u.near = h.near = e.near),
            (d.far = u.far = h.far = e.far),
            (f === d.near && m === d.far) ||
              (i.updateRenderState({ depthNear: d.near, depthFar: d.far }),
              (f = d.near),
              (m = d.far));
          const t = e.parent,
            n = d.cameras;
          x(d, t);
          for (let e = 0; e < n.length; e++) x(n[e], t);
          e.matrixWorld.copy(d.matrixWorld),
            e.matrix.copy(d.matrix),
            e.matrix.decompose(e.position, e.quaternion, e.scale);
          const r = e.children;
          for (let e = 0, t = r.length; e < t; e++) r[e].updateMatrixWorld(!0);
          return (
            2 === n.length
              ? (function (e, t, n) {
                  _.setFromMatrixPosition(t.matrixWorld),
                    w.setFromMatrixPosition(n.matrixWorld);
                  const i = _.distanceTo(w),
                    r = t.projectionMatrix.elements,
                    a = n.projectionMatrix.elements,
                    o = r[14] / (r[10] - 1),
                    s = r[14] / (r[10] + 1),
                    c = (r[9] + 1) / r[5],
                    l = (r[9] - 1) / r[5],
                    h = (r[8] - 1) / r[0],
                    u = (a[8] + 1) / a[0],
                    p = o * h,
                    d = o * u,
                    f = i / (-h + u),
                    m = f * -h;
                  t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                    e.translateX(m),
                    e.translateZ(f),
                    e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                    e.matrixWorldInverse.copy(e.matrixWorld).invert();
                  const g = o + f,
                    v = s + f,
                    y = p - m,
                    x = d + (i - m),
                    b = ((c * s) / v) * g,
                    M = ((l * s) / v) * g;
                  e.projectionMatrix.makePerspective(y, x, b, M, g, v);
                })(d, h, u)
              : d.projectionMatrix.copy(h.projectionMatrix),
            d
          );
        };
        let b = null;
        const M = new xn();
        M.setAnimationLoop(function (t, n) {
          if (((s = n.getViewerPose(a)), null !== s)) {
            const t = s.views,
              n = i.renderState.baseLayer;
            e.setFramebuffer(n.framebuffer);
            let r = !1;
            t.length !== d.cameras.length && ((d.cameras.length = 0), (r = !0));
            for (let e = 0; e < t.length; e++) {
              const i = t[e],
                a = n.getViewport(i),
                o = p[e];
              o.matrix.fromArray(i.transform.matrix),
                o.projectionMatrix.fromArray(i.projectionMatrix),
                o.viewport.set(a.x, a.y, a.width, a.height),
                0 === e && d.matrix.copy(o.matrix),
                !0 === r && d.cameras.push(o);
            }
          }
          const r = i.inputSources;
          for (let e = 0; e < c.length; e++) {
            const t = c[e],
              i = r[e];
            t.update(i, n, a);
          }
          b && b(t, n);
        }),
          (this.setAnimationLoop = function (e) {
            b = e;
          }),
          (this.dispose = function () {});
      }
      function Er(e) {
        function t(t, n) {
          (t.opacity.value = n.opacity),
            n.color && t.diffuse.value.copy(n.color),
            n.emissive &&
              t.emissive.value
                .copy(n.emissive)
                .multiplyScalar(n.emissiveIntensity),
            n.map && (t.map.value = n.map),
            n.alphaMap && (t.alphaMap.value = n.alphaMap),
            n.specularMap && (t.specularMap.value = n.specularMap);
          const i = e.get(n).envMap;
          if (i) {
            (t.envMap.value = i),
              (t.flipEnvMap.value =
                i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1),
              (t.reflectivity.value = n.reflectivity),
              (t.refractionRatio.value = n.refractionRatio);
            const r = e.get(i).__maxMipLevel;
            void 0 !== r && (t.maxMipLevel.value = r);
          }
          let r, a;
          n.lightMap &&
            ((t.lightMap.value = n.lightMap),
            (t.lightMapIntensity.value = n.lightMapIntensity)),
            n.aoMap &&
              ((t.aoMap.value = n.aoMap),
              (t.aoMapIntensity.value = n.aoMapIntensity)),
            n.map
              ? (r = n.map)
              : n.specularMap
              ? (r = n.specularMap)
              : n.displacementMap
              ? (r = n.displacementMap)
              : n.normalMap
              ? (r = n.normalMap)
              : n.bumpMap
              ? (r = n.bumpMap)
              : n.roughnessMap
              ? (r = n.roughnessMap)
              : n.metalnessMap
              ? (r = n.metalnessMap)
              : n.alphaMap
              ? (r = n.alphaMap)
              : n.emissiveMap
              ? (r = n.emissiveMap)
              : n.clearcoatMap
              ? (r = n.clearcoatMap)
              : n.clearcoatNormalMap
              ? (r = n.clearcoatNormalMap)
              : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap),
            void 0 !== r &&
              (r.isWebGLRenderTarget && (r = r.texture),
              !0 === r.matrixAutoUpdate && r.updateMatrix(),
              t.uvTransform.value.copy(r.matrix)),
            n.aoMap ? (a = n.aoMap) : n.lightMap && (a = n.lightMap),
            void 0 !== a &&
              (a.isWebGLRenderTarget && (a = a.texture),
              !0 === a.matrixAutoUpdate && a.updateMatrix(),
              t.uv2Transform.value.copy(a.matrix));
        }
        function n(t, n) {
          (t.roughness.value = n.roughness),
            (t.metalness.value = n.metalness),
            n.roughnessMap && (t.roughnessMap.value = n.roughnessMap),
            n.metalnessMap && (t.metalnessMap.value = n.metalnessMap),
            n.emissiveMap && (t.emissiveMap.value = n.emissiveMap),
            n.bumpMap &&
              ((t.bumpMap.value = n.bumpMap),
              (t.bumpScale.value = n.bumpScale),
              1 === n.side && (t.bumpScale.value *= -1)),
            n.normalMap &&
              ((t.normalMap.value = n.normalMap),
              t.normalScale.value.copy(n.normalScale),
              1 === n.side && t.normalScale.value.negate()),
            n.displacementMap &&
              ((t.displacementMap.value = n.displacementMap),
              (t.displacementScale.value = n.displacementScale),
              (t.displacementBias.value = n.displacementBias)),
            e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity);
        }
        return {
          refreshFogUniforms: function (e, t) {
            e.fogColor.value.copy(t.color),
              t.isFog
                ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far))
                : t.isFogExp2 && (e.fogDensity.value = t.density);
          },
          refreshMaterialUniforms: function (e, i, r, a) {
            i.isMeshBasicMaterial
              ? t(e, i)
              : i.isMeshLambertMaterial
              ? (t(e, i),
                (function (e, t) {
                  t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                })(e, i))
              : i.isMeshToonMaterial
              ? (t(e, i),
                (function (e, t) {
                  t.gradientMap && (e.gradientMap.value = t.gradientMap),
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
                    t.bumpMap &&
                      ((e.bumpMap.value = t.bumpMap),
                      (e.bumpScale.value = t.bumpScale),
                      1 === t.side && (e.bumpScale.value *= -1)),
                    t.normalMap &&
                      ((e.normalMap.value = t.normalMap),
                      e.normalScale.value.copy(t.normalScale),
                      1 === t.side && e.normalScale.value.negate()),
                    t.displacementMap &&
                      ((e.displacementMap.value = t.displacementMap),
                      (e.displacementScale.value = t.displacementScale),
                      (e.displacementBias.value = t.displacementBias));
                })(e, i))
              : i.isMeshPhongMaterial
              ? (t(e, i),
                (function (e, t) {
                  e.specular.value.copy(t.specular),
                    (e.shininess.value = Math.max(t.shininess, 1e-4)),
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
                    t.bumpMap &&
                      ((e.bumpMap.value = t.bumpMap),
                      (e.bumpScale.value = t.bumpScale),
                      1 === t.side && (e.bumpScale.value *= -1)),
                    t.normalMap &&
                      ((e.normalMap.value = t.normalMap),
                      e.normalScale.value.copy(t.normalScale),
                      1 === t.side && e.normalScale.value.negate()),
                    t.displacementMap &&
                      ((e.displacementMap.value = t.displacementMap),
                      (e.displacementScale.value = t.displacementScale),
                      (e.displacementBias.value = t.displacementBias));
                })(e, i))
              : i.isMeshStandardMaterial
              ? (t(e, i),
                i.isMeshPhysicalMaterial
                  ? (function (e, t) {
                      n(e, t),
                        (e.reflectivity.value = t.reflectivity),
                        (e.clearcoat.value = t.clearcoat),
                        (e.clearcoatRoughness.value = t.clearcoatRoughness),
                        t.sheen && e.sheen.value.copy(t.sheen),
                        t.clearcoatMap &&
                          (e.clearcoatMap.value = t.clearcoatMap),
                        t.clearcoatRoughnessMap &&
                          (e.clearcoatRoughnessMap.value =
                            t.clearcoatRoughnessMap),
                        t.clearcoatNormalMap &&
                          (e.clearcoatNormalScale.value.copy(
                            t.clearcoatNormalScale
                          ),
                          (e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                          1 === t.side &&
                            e.clearcoatNormalScale.value.negate()),
                        (e.transmission.value = t.transmission),
                        t.transmissionMap &&
                          (e.transmissionMap.value = t.transmissionMap);
                    })(e, i)
                  : n(e, i))
              : i.isMeshMatcapMaterial
              ? (t(e, i),
                (function (e, t) {
                  t.matcap && (e.matcap.value = t.matcap),
                    t.bumpMap &&
                      ((e.bumpMap.value = t.bumpMap),
                      (e.bumpScale.value = t.bumpScale),
                      1 === t.side && (e.bumpScale.value *= -1)),
                    t.normalMap &&
                      ((e.normalMap.value = t.normalMap),
                      e.normalScale.value.copy(t.normalScale),
                      1 === t.side && e.normalScale.value.negate()),
                    t.displacementMap &&
                      ((e.displacementMap.value = t.displacementMap),
                      (e.displacementScale.value = t.displacementScale),
                      (e.displacementBias.value = t.displacementBias));
                })(e, i))
              : i.isMeshDepthMaterial
              ? (t(e, i),
                (function (e, t) {
                  t.displacementMap &&
                    ((e.displacementMap.value = t.displacementMap),
                    (e.displacementScale.value = t.displacementScale),
                    (e.displacementBias.value = t.displacementBias));
                })(e, i))
              : i.isMeshDistanceMaterial
              ? (t(e, i),
                (function (e, t) {
                  t.displacementMap &&
                    ((e.displacementMap.value = t.displacementMap),
                    (e.displacementScale.value = t.displacementScale),
                    (e.displacementBias.value = t.displacementBias)),
                    e.referencePosition.value.copy(t.referencePosition),
                    (e.nearDistance.value = t.nearDistance),
                    (e.farDistance.value = t.farDistance);
                })(e, i))
              : i.isMeshNormalMaterial
              ? (t(e, i),
                (function (e, t) {
                  t.bumpMap &&
                    ((e.bumpMap.value = t.bumpMap),
                    (e.bumpScale.value = t.bumpScale),
                    1 === t.side && (e.bumpScale.value *= -1)),
                    t.normalMap &&
                      ((e.normalMap.value = t.normalMap),
                      e.normalScale.value.copy(t.normalScale),
                      1 === t.side && e.normalScale.value.negate()),
                    t.displacementMap &&
                      ((e.displacementMap.value = t.displacementMap),
                      (e.displacementScale.value = t.displacementScale),
                      (e.displacementBias.value = t.displacementBias));
                })(e, i))
              : i.isLineBasicMaterial
              ? ((function (e, t) {
                  e.diffuse.value.copy(t.color), (e.opacity.value = t.opacity);
                })(e, i),
                i.isLineDashedMaterial &&
                  (function (e, t) {
                    (e.dashSize.value = t.dashSize),
                      (e.totalSize.value = t.dashSize + t.gapSize),
                      (e.scale.value = t.scale);
                  })(e, i))
              : i.isPointsMaterial
              ? (function (e, t, n, i) {
                  let r;
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    (e.size.value = t.size * n),
                    (e.scale.value = 0.5 * i),
                    t.map && (e.map.value = t.map),
                    t.alphaMap && (e.alphaMap.value = t.alphaMap),
                    t.map ? (r = t.map) : t.alphaMap && (r = t.alphaMap),
                    void 0 !== r &&
                      (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                      e.uvTransform.value.copy(r.matrix));
                })(e, i, r, a)
              : i.isSpriteMaterial
              ? (function (e, t) {
                  let n;
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    (e.rotation.value = t.rotation),
                    t.map && (e.map.value = t.map),
                    t.alphaMap && (e.alphaMap.value = t.alphaMap),
                    t.map ? (n = t.map) : t.alphaMap && (n = t.alphaMap),
                    void 0 !== n &&
                      (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                      e.uvTransform.value.copy(n.matrix));
                })(e, i)
              : i.isShadowMaterial
              ? (e.color.value.copy(i.color), (e.opacity.value = i.opacity))
              : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
          },
        };
      }
      function Ar(e) {
        const t =
            void 0 !== (e = e || {}).canvas
              ? e.canvas
              : (function () {
                  const e = document.createElementNS(
                    "http://www.w3.org/1999/xhtml",
                    "canvas"
                  );
                  return (e.style.display = "block"), e;
                })(),
          n = void 0 !== e.context ? e.context : null,
          i = void 0 !== e.alpha && e.alpha,
          r = void 0 === e.depth || e.depth,
          a = void 0 === e.stencil || e.stencil,
          o = void 0 !== e.antialias && e.antialias,
          s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
          c = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
          l = void 0 !== e.powerPreference ? e.powerPreference : "default",
          h =
            void 0 !== e.failIfMajorPerformanceCaveat &&
            e.failIfMajorPerformanceCaveat;
        let d = null,
          f = null;
        const g = [];
        (this.domElement = t),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.gammaFactor = 2),
          (this.outputEncoding = S),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = 0),
          (this.toneMappingExposure = 1),
          (this.maxMorphTargets = 8),
          (this.maxMorphNormals = 4);
        const v = this;
        let y = !1,
          _ = null,
          w = 0,
          x = 0,
          b = null,
          M = null,
          T = -1,
          E = null;
        const A = new z(),
          L = new z();
        let P = null,
          R = t.width,
          k = t.height,
          C = 1,
          I = null,
          D = null;
        const j = new z(0, 0, R, k),
          F = new z(0, 0, R, k);
        let H = !1;
        const B = new wn();
        let U = !1,
          G = !1;
        const V = new ye(),
          q = new W(),
          X = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function Y() {
          return null === b ? C : 1;
        }
        let J,
          Z,
          Q,
          K,
          $,
          ee,
          te,
          ne,
          ie,
          re,
          ae,
          oe,
          se,
          ce,
          le,
          he,
          ue,
          pe,
          de,
          fe,
          me,
          ge = n;
        function ve(e, n) {
          for (let i = 0; i < e.length; i++) {
            const r = e[i],
              a = t.getContext(r, n);
            if (null !== a) return a;
          }
          return null;
        }
        try {
          const e = {
            alpha: i,
            depth: r,
            stencil: a,
            antialias: o,
            premultipliedAlpha: s,
            preserveDrawingBuffer: c,
            powerPreference: l,
            failIfMajorPerformanceCaveat: h,
          };
          if (
            (t.addEventListener("webglcontextlost", be, !1),
            t.addEventListener("webglcontextrestored", Me, !1),
            null === ge)
          ) {
            const t = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (!0 === v.isWebGL1Renderer && t.shift(),
              (ge = ve(t, e)),
              null === ge)
            )
              throw ve(t)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          void 0 === ge.getShaderPrecisionFormat &&
            (ge.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (e) {
          throw (console.error("THREE.WebGLRenderer: " + e.message), e);
        }
        function _e() {
          (J = new On(ge)),
            (Z = new Rn(ge, J, e)),
            J.init(Z),
            (fe = new xr(ge, J, Z)),
            (Q = new _r(ge, J, Z)),
            Q.scissor(L.copy(F).multiplyScalar(C).floor()),
            Q.viewport(A.copy(j).multiplyScalar(C).floor()),
            (K = new Dn(ge)),
            ($ = new ar()),
            (ee = new wr(ge, J, Q, $, Z, fe, K)),
            (te = new Cn(v)),
            (ne = new bn(ge, Z)),
            (me = new Ln(ge, J, ne, Z)),
            (ie = new Nn(ge, ne, K, me)),
            (re = new Bn(ge, ie, ne, K)),
            (ue = new Hn(ge)),
            (le = new kn($)),
            (ae = new rr(v, te, J, Z, me, le)),
            (oe = new Er($)),
            (se = new lr($)),
            (ce = new mr(J, Z)),
            (he = new An(v, te, Q, re, s)),
            (pe = new Pn(ge, J, K, Z)),
            (de = new In(ge, J, K, Z)),
            (K.programs = ae.programs),
            (v.capabilities = Z),
            (v.extensions = J),
            (v.properties = $),
            (v.renderLists = se),
            (v.state = Q),
            (v.info = K);
        }
        _e();
        const we = new Tr(v, ge);
        this.xr = we;
        const xe = new yr(v, re, Z.maxTextureSize);
        function be(e) {
          e.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (y = !0);
        }
        function Me() {
          console.log("THREE.WebGLRenderer: Context Restored."), (y = !1), _e();
        }
        function Se(e) {
          const t = e.target;
          t.removeEventListener("dispose", Se),
            (function (e) {
              Te(e), $.remove(e);
            })(t);
        }
        function Te(e) {
          const t = $.get(e).program;
          void 0 !== t && ae.releaseProgram(t);
        }
        (this.shadowMap = xe),
          (this.getContext = function () {
            return ge;
          }),
          (this.getContextAttributes = function () {
            return ge.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            const e = J.get("WEBGL_lose_context");
            e && e.loseContext();
          }),
          (this.forceContextRestore = function () {
            const e = J.get("WEBGL_lose_context");
            e && e.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return C;
          }),
          (this.setPixelRatio = function (e) {
            void 0 !== e && ((C = e), this.setSize(R, k, !1));
          }),
          (this.getSize = function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
                ),
                (e = new N())),
              e.set(R, k)
            );
          }),
          (this.setSize = function (e, n, i) {
            we.isPresenting
              ? console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                )
              : ((R = e),
                (k = n),
                (t.width = Math.floor(e * C)),
                (t.height = Math.floor(n * C)),
                !1 !== i &&
                  ((t.style.width = e + "px"), (t.style.height = n + "px")),
                this.setViewport(0, 0, e, n));
          }),
          (this.getDrawingBufferSize = function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
                ),
                (e = new N())),
              e.set(R * C, k * C).floor()
            );
          }),
          (this.setDrawingBufferSize = function (e, n, i) {
            (R = e),
              (k = n),
              (C = i),
              (t.width = Math.floor(e * i)),
              (t.height = Math.floor(n * i)),
              this.setViewport(0, 0, e, n);
          }),
          (this.getCurrentViewport = function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
                ),
                (e = new z())),
              e.copy(A)
            );
          }),
          (this.getViewport = function (e) {
            return e.copy(j);
          }),
          (this.setViewport = function (e, t, n, i) {
            e.isVector4 ? j.set(e.x, e.y, e.z, e.w) : j.set(e, t, n, i),
              Q.viewport(A.copy(j).multiplyScalar(C).floor());
          }),
          (this.getScissor = function (e) {
            return e.copy(F);
          }),
          (this.setScissor = function (e, t, n, i) {
            e.isVector4 ? F.set(e.x, e.y, e.z, e.w) : F.set(e, t, n, i),
              Q.scissor(L.copy(F).multiplyScalar(C).floor());
          }),
          (this.getScissorTest = function () {
            return H;
          }),
          (this.setScissorTest = function (e) {
            Q.setScissorTest((H = e));
          }),
          (this.setOpaqueSort = function (e) {
            I = e;
          }),
          (this.setTransparentSort = function (e) {
            D = e;
          }),
          (this.getClearColor = function (e) {
            return (
              void 0 === e &&
                (console.warn(
                  "WebGLRenderer: .getClearColor() now requires a Color as an argument"
                ),
                (e = new ut())),
              e.copy(he.getClearColor())
            );
          }),
          (this.setClearColor = function () {
            he.setClearColor.apply(he, arguments);
          }),
          (this.getClearAlpha = function () {
            return he.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            he.setClearAlpha.apply(he, arguments);
          }),
          (this.clear = function (e, t, n) {
            let i = 0;
            (void 0 === e || e) && (i |= 16384),
              (void 0 === t || t) && (i |= 256),
              (void 0 === n || n) && (i |= 1024),
              ge.clear(i);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            t.removeEventListener("webglcontextlost", be, !1),
              t.removeEventListener("webglcontextrestored", Me, !1),
              se.dispose(),
              ce.dispose(),
              $.dispose(),
              te.dispose(),
              re.dispose(),
              me.dispose(),
              we.dispose(),
              Ae.stop();
          }),
          (this.renderBufferImmediate = function (e, t) {
            me.initAttributes();
            const n = $.get(e);
            e.hasPositions && !n.position && (n.position = ge.createBuffer()),
              e.hasNormals && !n.normal && (n.normal = ge.createBuffer()),
              e.hasUvs && !n.uv && (n.uv = ge.createBuffer()),
              e.hasColors && !n.color && (n.color = ge.createBuffer());
            const i = t.getAttributes();
            e.hasPositions &&
              (ge.bindBuffer(34962, n.position),
              ge.bufferData(34962, e.positionArray, 35048),
              me.enableAttribute(i.position),
              ge.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
              e.hasNormals &&
                (ge.bindBuffer(34962, n.normal),
                ge.bufferData(34962, e.normalArray, 35048),
                me.enableAttribute(i.normal),
                ge.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
              e.hasUvs &&
                (ge.bindBuffer(34962, n.uv),
                ge.bufferData(34962, e.uvArray, 35048),
                me.enableAttribute(i.uv),
                ge.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
              e.hasColors &&
                (ge.bindBuffer(34962, n.color),
                ge.bufferData(34962, e.colorArray, 35048),
                me.enableAttribute(i.color),
                ge.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
              me.disableUnusedAttributes(),
              ge.drawArrays(4, 0, e.count),
              (e.count = 0);
          }),
          (this.renderBufferDirect = function (e, t, n, i, r, a) {
            null === t && (t = X);
            const o = r.isMesh && r.matrixWorld.determinant() < 0,
              s = Ce(e, t, i, r);
            Q.setMaterial(i, o);
            let c = n.index;
            const l = n.attributes.position;
            if (null === c) {
              if (void 0 === l || 0 === l.count) return;
            } else if (0 === c.count) return;
            let h,
              u = 1;
            !0 === i.wireframe && ((c = ie.getWireframeAttribute(n)), (u = 2)),
              (i.morphTargets || i.morphNormals) && ue.update(r, n, i, s),
              me.setup(r, i, s, n, c);
            let p = pe;
            null !== c && ((h = ne.get(c)), (p = de), p.setIndex(h));
            const d = null !== c ? c.count : l.count,
              f = n.drawRange.start * u,
              m = n.drawRange.count * u,
              g = null !== a ? a.start * u : 0,
              v = null !== a ? a.count * u : 1 / 0,
              y = Math.max(f, g),
              _ = Math.min(d, f + m, g + v) - 1,
              w = Math.max(0, _ - y + 1);
            if (0 !== w) {
              if (r.isMesh)
                !0 === i.wireframe
                  ? (Q.setLineWidth(i.wireframeLinewidth * Y()), p.setMode(1))
                  : p.setMode(4);
              else if (r.isLine) {
                let e = i.linewidth;
                void 0 === e && (e = 1),
                  Q.setLineWidth(e * Y()),
                  r.isLineSegments
                    ? p.setMode(1)
                    : r.isLineLoop
                    ? p.setMode(2)
                    : p.setMode(3);
              } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
              if (r.isInstancedMesh) p.renderInstances(y, w, r.count);
              else if (n.isInstancedBufferGeometry) {
                const e = Math.min(n.instanceCount, n._maxInstanceCount);
                p.renderInstances(y, w, e);
              } else p.render(y, w);
            }
          }),
          (this.compile = function (e, t) {
            (f = ce.get(e)),
              f.init(),
              e.traverseVisible(function (e) {
                e.isLight &&
                  e.layers.test(t.layers) &&
                  (f.pushLight(e), e.castShadow && f.pushShadow(e));
              }),
              f.setupLights();
            const n = new WeakMap();
            e.traverse(function (t) {
              const i = t.material;
              if (i)
                if (Array.isArray(i))
                  for (let r = 0; r < i.length; r++) {
                    const a = i[r];
                    !1 === n.has(a) && (ke(a, e, t), n.set(a));
                  }
                else !1 === n.has(i) && (ke(i, e, t), n.set(i));
            });
          });
        let Ee = null;
        const Ae = new xn();
        function Le(e, t, n, i) {
          if (!1 === e.visible) return;
          if (e.layers.test(t.layers))
            if (e.isGroup) n = e.renderOrder;
            else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
            else if (e.isLight) f.pushLight(e), e.castShadow && f.pushShadow(e);
            else if (e.isSprite) {
              if (!e.frustumCulled || B.intersectsSprite(e)) {
                i && q.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);
                const t = re.update(e),
                  r = e.material;
                r.visible && d.push(e, t, r, n, q.z, null);
              }
            } else if (e.isImmediateRenderObject)
              i && q.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V),
                d.push(e, null, e.material, n, q.z, null);
            else if (
              (e.isMesh || e.isLine || e.isPoints) &&
              (e.isSkinnedMesh &&
                e.skeleton.frame !== K.render.frame &&
                (e.skeleton.update(), (e.skeleton.frame = K.render.frame)),
              !e.frustumCulled || B.intersectsObject(e))
            ) {
              i && q.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);
              const t = re.update(e),
                r = e.material;
              if (Array.isArray(r)) {
                const i = t.groups;
                for (let a = 0, o = i.length; a < o; a++) {
                  const o = i[a],
                    s = r[o.materialIndex];
                  s && s.visible && d.push(e, t, s, n, q.z, o);
                }
              } else r.visible && d.push(e, t, r, n, q.z, null);
            }
          const r = e.children;
          for (let e = 0, a = r.length; e < a; e++) Le(r[e], t, n, i);
        }
        function Pe(e, t, n) {
          const i = !0 === t.isScene ? t.overrideMaterial : null;
          for (let r = 0, a = e.length; r < a; r++) {
            const a = e[r],
              o = a.object,
              s = a.geometry,
              c = null === i ? a.material : i,
              l = a.group;
            if (n.isArrayCamera) {
              const e = n.cameras;
              for (let n = 0, i = e.length; n < i; n++) {
                const i = e[n];
                o.layers.test(i.layers) &&
                  (Q.viewport(A.copy(i.viewport)),
                  f.setupLightsView(i),
                  Re(o, t, i, s, c, l));
              }
            } else Re(o, t, n, s, c, l);
          }
        }
        function Re(e, t, n, i, r, a) {
          if (
            (e.onBeforeRender(v, t, n, i, r, a),
            e.modelViewMatrix.multiplyMatrices(
              n.matrixWorldInverse,
              e.matrixWorld
            ),
            e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
            e.isImmediateRenderObject)
          ) {
            const i = Ce(n, t, r, e);
            Q.setMaterial(r),
              me.reset(),
              (function (e, t) {
                e.render(function (e) {
                  v.renderBufferImmediate(e, t);
                });
              })(e, i);
          } else v.renderBufferDirect(n, t, i, r, e, a);
          e.onAfterRender(v, t, n, i, r, a);
        }
        function ke(e, t, n) {
          !0 !== t.isScene && (t = X);
          const i = $.get(e),
            r = f.state.lights,
            a = f.state.shadowsArray,
            o = r.state.version,
            s = ae.getParameters(e, r.state, a, t, n),
            c = ae.getProgramCacheKey(s);
          let l = i.program,
            h = !0;
          if (
            ((i.environment = e.isMeshStandardMaterial ? t.environment : null),
            (i.fog = t.fog),
            (i.envMap = te.get(e.envMap || i.environment)),
            void 0 === l)
          )
            e.addEventListener("dispose", Se);
          else if (l.cacheKey !== c) Te(e);
          else if (i.lightsStateVersion !== o) h = !1;
          else {
            if (void 0 !== s.shaderID) return;
            h = !1;
          }
          h &&
            ((s.uniforms = ae.getUniforms(e)),
            e.onBeforeCompile(s, v),
            (l = ae.acquireProgram(s, c)),
            (i.program = l),
            (i.uniforms = s.uniforms),
            (i.outputEncoding = s.outputEncoding));
          const u = i.uniforms;
          ((e.isShaderMaterial || e.isRawShaderMaterial) &&
            !0 !== e.clipping) ||
            ((i.numClippingPlanes = le.numPlanes),
            (i.numIntersection = le.numIntersection),
            (u.clippingPlanes = le.uniform)),
            (i.needsLights = (function (e) {
              return (
                e.isMeshLambertMaterial ||
                e.isMeshToonMaterial ||
                e.isMeshPhongMaterial ||
                e.isMeshStandardMaterial ||
                e.isShadowMaterial ||
                (e.isShaderMaterial && !0 === e.lights)
              );
            })(e)),
            (i.lightsStateVersion = o),
            i.needsLights &&
              ((u.ambientLightColor.value = r.state.ambient),
              (u.lightProbe.value = r.state.probe),
              (u.directionalLights.value = r.state.directional),
              (u.directionalLightShadows.value = r.state.directionalShadow),
              (u.spotLights.value = r.state.spot),
              (u.spotLightShadows.value = r.state.spotShadow),
              (u.rectAreaLights.value = r.state.rectArea),
              (u.ltc_1.value = r.state.rectAreaLTC1),
              (u.ltc_2.value = r.state.rectAreaLTC2),
              (u.pointLights.value = r.state.point),
              (u.pointLightShadows.value = r.state.pointShadow),
              (u.hemisphereLights.value = r.state.hemi),
              (u.directionalShadowMap.value = r.state.directionalShadowMap),
              (u.directionalShadowMatrix.value =
                r.state.directionalShadowMatrix),
              (u.spotShadowMap.value = r.state.spotShadowMap),
              (u.spotShadowMatrix.value = r.state.spotShadowMatrix),
              (u.pointShadowMap.value = r.state.pointShadowMap),
              (u.pointShadowMatrix.value = r.state.pointShadowMatrix));
          const p = i.program.getUniforms(),
            d = ji.seqWithValue(p.seq, u);
          i.uniformsList = d;
        }
        function Ce(e, t, n, i) {
          !0 !== t.isScene && (t = X), ee.resetTextureUnits();
          const r = t.fog,
            a = n.isMeshStandardMaterial ? t.environment : null,
            o = null === b ? v.outputEncoding : b.texture.encoding,
            s = te.get(n.envMap || a),
            c = $.get(n),
            l = f.state.lights;
          if (!0 === U && (!0 === G || e !== E)) {
            const t = e === E && n.id === T;
            le.setState(n, e, t);
          }
          n.version === c.__version
            ? (n.fog && c.fog !== r) ||
              c.environment !== a ||
              (c.needsLights && c.lightsStateVersion !== l.state.version)
              ? ke(n, t, i)
              : void 0 === c.numClippingPlanes ||
                (c.numClippingPlanes === le.numPlanes &&
                  c.numIntersection === le.numIntersection)
              ? (c.outputEncoding !== o || c.envMap !== s) && ke(n, t, i)
              : ke(n, t, i)
            : (ke(n, t, i), (c.__version = n.version));
          let h = !1,
            p = !1,
            d = !1;
          const g = c.program,
            y = g.getUniforms(),
            _ = c.uniforms;
          if (
            (Q.useProgram(g.program) && ((h = !0), (p = !0), (d = !0)),
            n.id !== T && ((T = n.id), (p = !0)),
            h || E !== e)
          ) {
            if (
              (y.setValue(ge, "projectionMatrix", e.projectionMatrix),
              Z.logarithmicDepthBuffer &&
                y.setValue(
                  ge,
                  "logDepthBufFC",
                  2 / (Math.log(e.far + 1) / Math.LN2)
                ),
              E !== e && ((E = e), (p = !0), (d = !0)),
              n.isShaderMaterial ||
                n.isMeshPhongMaterial ||
                n.isMeshToonMaterial ||
                n.isMeshStandardMaterial ||
                n.envMap)
            ) {
              const t = y.map.cameraPosition;
              void 0 !== t &&
                t.setValue(ge, q.setFromMatrixPosition(e.matrixWorld));
            }
            (n.isMeshPhongMaterial ||
              n.isMeshToonMaterial ||
              n.isMeshLambertMaterial ||
              n.isMeshBasicMaterial ||
              n.isMeshStandardMaterial ||
              n.isShaderMaterial) &&
              y.setValue(ge, "isOrthographic", !0 === e.isOrthographicCamera),
              (n.isMeshPhongMaterial ||
                n.isMeshToonMaterial ||
                n.isMeshLambertMaterial ||
                n.isMeshBasicMaterial ||
                n.isMeshStandardMaterial ||
                n.isShaderMaterial ||
                n.isShadowMaterial ||
                n.skinning) &&
                y.setValue(ge, "viewMatrix", e.matrixWorldInverse);
          }
          if (n.skinning) {
            y.setOptional(ge, i, "bindMatrix"),
              y.setOptional(ge, i, "bindMatrixInverse");
            const e = i.skeleton;
            if (e) {
              const t = e.bones;
              if (Z.floatVertexTextures) {
                if (null === e.boneTexture) {
                  let n = Math.sqrt(4 * t.length);
                  (n = O.ceilPowerOfTwo(n)), (n = Math.max(n, 4));
                  const i = new Float32Array(n * n * 4);
                  i.set(e.boneMatrices);
                  const r = new vn(i, n, n, m, u);
                  (e.boneMatrices = i),
                    (e.boneTexture = r),
                    (e.boneTextureSize = n);
                }
                y.setValue(ge, "boneTexture", e.boneTexture, ee),
                  y.setValue(ge, "boneTextureSize", e.boneTextureSize);
              } else y.setOptional(ge, e, "boneMatrices");
            }
          }
          var w, x;
          return (
            (p || c.receiveShadow !== i.receiveShadow) &&
              ((c.receiveShadow = i.receiveShadow),
              y.setValue(ge, "receiveShadow", i.receiveShadow)),
            p &&
              (y.setValue(ge, "toneMappingExposure", v.toneMappingExposure),
              c.needsLights &&
                ((x = d),
                ((w = _).ambientLightColor.needsUpdate = x),
                (w.lightProbe.needsUpdate = x),
                (w.directionalLights.needsUpdate = x),
                (w.directionalLightShadows.needsUpdate = x),
                (w.pointLights.needsUpdate = x),
                (w.pointLightShadows.needsUpdate = x),
                (w.spotLights.needsUpdate = x),
                (w.spotLightShadows.needsUpdate = x),
                (w.rectAreaLights.needsUpdate = x),
                (w.hemisphereLights.needsUpdate = x)),
              r && n.fog && oe.refreshFogUniforms(_, r),
              oe.refreshMaterialUniforms(_, n, C, k),
              ji.upload(ge, c.uniformsList, _, ee)),
            n.isShaderMaterial &&
              !0 === n.uniformsNeedUpdate &&
              (ji.upload(ge, c.uniformsList, _, ee),
              (n.uniformsNeedUpdate = !1)),
            n.isSpriteMaterial && y.setValue(ge, "center", i.center),
            y.setValue(ge, "modelViewMatrix", i.modelViewMatrix),
            y.setValue(ge, "normalMatrix", i.normalMatrix),
            y.setValue(ge, "modelMatrix", i.matrixWorld),
            g
          );
        }
        Ae.setAnimationLoop(function (e) {
          we.isPresenting || (Ee && Ee(e));
        }),
          "undefined" != typeof window && Ae.setContext(window),
          (this.setAnimationLoop = function (e) {
            (Ee = e),
              we.setAnimationLoop(e),
              null === e ? Ae.stop() : Ae.start();
          }),
          (this.render = function (e, t) {
            let n, i;
            if (
              (void 0 !== arguments[2] &&
                (console.warn(
                  "THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
                ),
                (n = arguments[2])),
              void 0 !== arguments[3] &&
                (console.warn(
                  "THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
                ),
                (i = arguments[3])),
              void 0 !== t && !0 !== t.isCamera)
            )
              return void console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
            if (!0 === y) return;
            me.resetDefaultState(),
              (T = -1),
              (E = null),
              !0 === e.autoUpdate && e.updateMatrixWorld(),
              null === t.parent && t.updateMatrixWorld(),
              !0 === we.enabled &&
                !0 === we.isPresenting &&
                (t = we.getCamera(t)),
              !0 === e.isScene && e.onBeforeRender(v, e, t, n || b),
              (f = ce.get(e, g.length)),
              f.init(),
              g.push(f),
              V.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
              B.setFromProjectionMatrix(V),
              (G = this.localClippingEnabled),
              (U = le.init(this.clippingPlanes, G, t)),
              (d = se.get(e, t)),
              d.init(),
              Le(e, t, 0, v.sortObjects),
              d.finish(),
              !0 === v.sortObjects && d.sort(I, D),
              !0 === U && le.beginShadows();
            const r = f.state.shadowsArray;
            xe.render(r, e, t),
              f.setupLights(),
              f.setupLightsView(t),
              !0 === U && le.endShadows(),
              !0 === this.info.autoReset && this.info.reset(),
              void 0 !== n && this.setRenderTarget(n),
              he.render(d, e, t, i);
            const a = d.opaque,
              o = d.transparent;
            a.length > 0 && Pe(a, e, t),
              o.length > 0 && Pe(o, e, t),
              !0 === e.isScene && e.onAfterRender(v, e, t),
              null !== b &&
                (ee.updateRenderTargetMipmap(b),
                ee.updateMultisampleRenderTarget(b)),
              Q.buffers.depth.setTest(!0),
              Q.buffers.depth.setMask(!0),
              Q.buffers.color.setMask(!0),
              Q.setPolygonOffset(!1),
              g.pop(),
              (f = g.length > 0 ? g[g.length - 1] : null),
              (d = null);
          }),
          (this.setFramebuffer = function (e) {
            _ !== e && null === b && ge.bindFramebuffer(36160, e), (_ = e);
          }),
          (this.getActiveCubeFace = function () {
            return w;
          }),
          (this.getActiveMipmapLevel = function () {
            return x;
          }),
          (this.getRenderList = function () {
            return d;
          }),
          (this.setRenderList = function (e) {
            d = e;
          }),
          (this.getRenderTarget = function () {
            return b;
          }),
          (this.setRenderTarget = function (e, t = 0, n = 0) {
            (b = e),
              (w = t),
              (x = n),
              e &&
                void 0 === $.get(e).__webglFramebuffer &&
                ee.setupRenderTarget(e);
            let i = _,
              r = !1;
            if (e) {
              const n = $.get(e).__webglFramebuffer;
              e.isWebGLCubeRenderTarget
                ? ((i = n[t]), (r = !0))
                : (i = e.isWebGLMultisampleRenderTarget
                    ? $.get(e).__webglMultisampledFramebuffer
                    : n),
                A.copy(e.viewport),
                L.copy(e.scissor),
                (P = e.scissorTest);
            } else
              A.copy(j).multiplyScalar(C).floor(),
                L.copy(F).multiplyScalar(C).floor(),
                (P = H);
            if (
              (M !== i && (ge.bindFramebuffer(36160, i), (M = i)),
              Q.viewport(A),
              Q.scissor(L),
              Q.setScissorTest(P),
              r)
            ) {
              const i = $.get(e.texture);
              ge.framebufferTexture2D(
                36160,
                36064,
                34069 + t,
                i.__webglTexture,
                n
              );
            }
          }),
          (this.readRenderTargetPixels = function (e, t, n, i, r, a, o) {
            if (!e || !e.isWebGLRenderTarget)
              return void console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
            let s = $.get(e).__webglFramebuffer;
            if ((e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s)) {
              let o = !1;
              s !== M && (ge.bindFramebuffer(36160, s), (o = !0));
              try {
                const s = e.texture,
                  c = s.format,
                  l = s.type;
                if (c !== m && fe.convert(c) !== ge.getParameter(35739))
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                const h =
                  l === p &&
                  (J.has("EXT_color_buffer_half_float") ||
                    (Z.isWebGL2 && J.has("EXT_color_buffer_float")));
                if (
                  !(
                    1009 === l ||
                    fe.convert(l) === ge.getParameter(35738) ||
                    (l === u &&
                      (Z.isWebGL2 ||
                        J.has("OES_texture_float") ||
                        J.has("WEBGL_color_buffer_float"))) ||
                    h
                  )
                )
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                36053 === ge.checkFramebufferStatus(36160)
                  ? t >= 0 &&
                    t <= e.width - i &&
                    n >= 0 &&
                    n <= e.height - r &&
                    ge.readPixels(t, n, i, r, fe.convert(c), fe.convert(l), a)
                  : console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                    );
              } finally {
                o && ge.bindFramebuffer(36160, M);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (e, t, n = 0) {
            const i = Math.pow(2, -n),
              r = Math.floor(t.image.width * i),
              a = Math.floor(t.image.height * i),
              o = fe.convert(t.format);
            ee.setTexture2D(t, 0),
              ge.copyTexImage2D(3553, n, o, e.x, e.y, r, a, 0),
              Q.unbindTexture();
          }),
          (this.copyTextureToTexture = function (e, t, n, i = 0) {
            const r = t.image.width,
              a = t.image.height,
              o = fe.convert(n.format),
              s = fe.convert(n.type);
            ee.setTexture2D(n, 0),
              ge.pixelStorei(37440, n.flipY),
              ge.pixelStorei(37441, n.premultiplyAlpha),
              ge.pixelStorei(3317, n.unpackAlignment),
              t.isDataTexture
                ? ge.texSubImage2D(3553, i, e.x, e.y, r, a, o, s, t.image.data)
                : t.isCompressedTexture
                ? ge.compressedTexSubImage2D(
                    3553,
                    i,
                    e.x,
                    e.y,
                    t.mipmaps[0].width,
                    t.mipmaps[0].height,
                    o,
                    t.mipmaps[0].data
                  )
                : ge.texSubImage2D(3553, i, e.x, e.y, o, s, t.image),
              0 === i && n.generateMipmaps && ge.generateMipmap(3553),
              Q.unbindTexture();
          }),
          (this.initTexture = function (e) {
            ee.setTexture2D(e, 0), Q.unbindTexture();
          }),
          (this.resetState = function () {
            Q.reset(), me.reset();
          }),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      function Lr(e) {
        Ar.call(this, e);
      }
      (gr.prototype = Object.create(ft.prototype)),
        (gr.prototype.constructor = gr),
        (gr.prototype.isMeshDepthMaterial = !0),
        (gr.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e),
            (this.depthPacking = e.depthPacking),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }),
        (vr.prototype = Object.create(ft.prototype)),
        (vr.prototype.constructor = vr),
        (vr.prototype.isMeshDistanceMaterial = !0),
        (vr.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e),
            this.referencePosition.copy(e.referencePosition),
            (this.nearDistance = e.nearDistance),
            (this.farDistance = e.farDistance),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }),
        (br.prototype = Object.assign(Object.create(pn.prototype), {
          constructor: br,
          isArrayCamera: !0,
        })),
        (Mr.prototype = Object.assign(Object.create(Ge.prototype), {
          constructor: Mr,
          isGroup: !0,
        })),
        Object.assign(Sr.prototype, {
          constructor: Sr,
          getHandSpace: function () {
            return (
              null === this._hand &&
                ((this._hand = new Mr()),
                (this._hand.matrixAutoUpdate = !1),
                (this._hand.visible = !1),
                (this._hand.joints = {}),
                (this._hand.inputState = { pinching: !1 })),
              this._hand
            );
          },
          getTargetRaySpace: function () {
            return (
              null === this._targetRay &&
                ((this._targetRay = new Mr()),
                (this._targetRay.matrixAutoUpdate = !1),
                (this._targetRay.visible = !1)),
              this._targetRay
            );
          },
          getGripSpace: function () {
            return (
              null === this._grip &&
                ((this._grip = new Mr()),
                (this._grip.matrixAutoUpdate = !1),
                (this._grip.visible = !1)),
              this._grip
            );
          },
          dispatchEvent: function (e) {
            return (
              null !== this._targetRay && this._targetRay.dispatchEvent(e),
              null !== this._grip && this._grip.dispatchEvent(e),
              null !== this._hand && this._hand.dispatchEvent(e),
              this
            );
          },
          disconnect: function (e) {
            return (
              this.dispatchEvent({ type: "disconnected", data: e }),
              null !== this._targetRay && (this._targetRay.visible = !1),
              null !== this._grip && (this._grip.visible = !1),
              null !== this._hand && (this._hand.visible = !1),
              this
            );
          },
          update: function (e, t, n) {
            let i = null,
              r = null,
              a = null;
            const o = this._targetRay,
              s = this._grip,
              c = this._hand;
            if (e && "visible-blurred" !== t.session.visibilityState)
              if (c && e.hand) {
                a = !0;
                for (const i of e.hand.values()) {
                  const e = t.getJointPose(i, n);
                  if (void 0 === c.joints[i.jointName]) {
                    const e = new Mr();
                    (e.matrixAutoUpdate = !1),
                      (e.visible = !1),
                      (c.joints[i.jointName] = e),
                      c.add(e);
                  }
                  const r = c.joints[i.jointName];
                  null !== e &&
                    (r.matrix.fromArray(e.transform.matrix),
                    r.matrix.decompose(r.position, r.rotation, r.scale),
                    (r.jointRadius = e.radius)),
                    (r.visible = null !== e);
                }
                const i = c.joints["index-finger-tip"],
                  r = c.joints["thumb-tip"],
                  o = i.position.distanceTo(r.position),
                  s = 0.02,
                  l = 0.005;
                c.inputState.pinching && o > s + l
                  ? ((c.inputState.pinching = !1),
                    this.dispatchEvent({
                      type: "pinchend",
                      handedness: e.handedness,
                      target: this,
                    }))
                  : !c.inputState.pinching &&
                    o <= s - l &&
                    ((c.inputState.pinching = !0),
                    this.dispatchEvent({
                      type: "pinchstart",
                      handedness: e.handedness,
                      target: this,
                    }));
              } else
                null !== o &&
                  ((i = t.getPose(e.targetRaySpace, n)),
                  null !== i &&
                    (o.matrix.fromArray(i.transform.matrix),
                    o.matrix.decompose(o.position, o.rotation, o.scale))),
                  null !== s &&
                    e.gripSpace &&
                    ((r = t.getPose(e.gripSpace, n)),
                    null !== r &&
                      (s.matrix.fromArray(r.transform.matrix),
                      s.matrix.decompose(s.position, s.rotation, s.scale)));
            return (
              null !== o && (o.visible = null !== i),
              null !== s && (s.visible = null !== r),
              null !== c && (c.visible = null !== a),
              this
            );
          },
        }),
        Object.assign(Tr.prototype, R.prototype),
        (Lr.prototype = Object.assign(Object.create(Ar.prototype), {
          constructor: Lr,
          isWebGL1Renderer: !0,
        }));
      class Pr extends Ge {
        constructor() {
          super(),
            Object.defineProperty(this, "isScene", { value: !0 }),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            null !== e.background && (this.background = e.background.clone()),
            null !== e.environment &&
              (this.environment = e.environment.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            null !== e.overrideMaterial &&
              (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.autoUpdate = e.autoUpdate),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            null !== this.background &&
              (t.object.background = this.background.toJSON(e)),
            null !== this.environment &&
              (t.object.environment = this.environment.toJSON(e)),
            null !== this.fog && (t.object.fog = this.fog.toJSON()),
            t
          );
        }
      }
      function Rr(e, t) {
        (this.array = e),
          (this.stride = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.usage = A),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0),
          (this.uuid = O.generateUUID());
      }
      Object.defineProperty(Rr.prototype, "needsUpdate", {
        set: function (e) {
          !0 === e && this.version++;
        },
      }),
        Object.assign(Rr.prototype, {
          isInterleavedBuffer: !0,
          onUploadCallback: function () {},
          setUsage: function (e) {
            return (this.usage = e), this;
          },
          copy: function (e) {
            return (
              (this.array = new e.array.constructor(e.array)),
              (this.count = e.count),
              (this.stride = e.stride),
              (this.usage = e.usage),
              this
            );
          },
          copyAt: function (e, t, n) {
            (e *= this.stride), (n *= t.stride);
            for (let i = 0, r = this.stride; i < r; i++)
              this.array[e + i] = t.array[n + i];
            return this;
          },
          set: function (e, t = 0) {
            return this.array.set(e, t), this;
          },
          clone: function (e) {
            void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = O.generateUUID()),
              void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
                (e.arrayBuffers[this.array.buffer._uuid] =
                  this.array.slice(0).buffer);
            const t = new Rr(
              new this.array.constructor(
                e.arrayBuffers[this.array.buffer._uuid]
              ),
              this.stride
            );
            return t.setUsage(this.usage), t;
          },
          onUpload: function (e) {
            return (this.onUploadCallback = e), this;
          },
          toJSON: function (e) {
            return (
              void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = O.generateUUID()),
              void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
                (e.arrayBuffers[this.array.buffer._uuid] =
                  Array.prototype.slice.call(
                    new Uint32Array(this.array.buffer)
                  )),
              {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride,
              }
            );
          },
        });
      const kr = new W();
      function Cr(e, t, n, i) {
        (this.name = ""),
          (this.data = e),
          (this.itemSize = t),
          (this.offset = n),
          (this.normalized = !0 === i);
      }
      function Or(e) {
        ft.call(this),
          (this.type = "SpriteMaterial"),
          (this.color = new ut(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.rotation = 0),
          (this.sizeAttenuation = !0),
          (this.transparent = !0),
          this.setValues(e);
      }
      let Nr;
      Object.defineProperties(Cr.prototype, {
        count: {
          get: function () {
            return this.data.count;
          },
        },
        array: {
          get: function () {
            return this.data.array;
          },
        },
        needsUpdate: {
          set: function (e) {
            this.data.needsUpdate = e;
          },
        },
      }),
        Object.assign(Cr.prototype, {
          isInterleavedBufferAttribute: !0,
          applyMatrix4: function (e) {
            for (let t = 0, n = this.data.count; t < n; t++)
              (kr.x = this.getX(t)),
                (kr.y = this.getY(t)),
                (kr.z = this.getZ(t)),
                kr.applyMatrix4(e),
                this.setXYZ(t, kr.x, kr.y, kr.z);
            return this;
          },
          setX: function (e, t) {
            return (
              (this.data.array[e * this.data.stride + this.offset] = t), this
            );
          },
          setY: function (e, t) {
            return (
              (this.data.array[e * this.data.stride + this.offset + 1] = t),
              this
            );
          },
          setZ: function (e, t) {
            return (
              (this.data.array[e * this.data.stride + this.offset + 2] = t),
              this
            );
          },
          setW: function (e, t) {
            return (
              (this.data.array[e * this.data.stride + this.offset + 3] = t),
              this
            );
          },
          getX: function (e) {
            return this.data.array[e * this.data.stride + this.offset];
          },
          getY: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 1];
          },
          getZ: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 2];
          },
          getW: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 3];
          },
          setXY: function (e, t, n) {
            return (
              (e = e * this.data.stride + this.offset),
              (this.data.array[e + 0] = t),
              (this.data.array[e + 1] = n),
              this
            );
          },
          setXYZ: function (e, t, n, i) {
            return (
              (e = e * this.data.stride + this.offset),
              (this.data.array[e + 0] = t),
              (this.data.array[e + 1] = n),
              (this.data.array[e + 2] = i),
              this
            );
          },
          setXYZW: function (e, t, n, i, r) {
            return (
              (e = e * this.data.stride + this.offset),
              (this.data.array[e + 0] = t),
              (this.data.array[e + 1] = n),
              (this.data.array[e + 2] = i),
              (this.data.array[e + 3] = r),
              this
            );
          },
          clone: function (e) {
            if (void 0 === e) {
              console.log(
                "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
              );
              const e = [];
              for (let t = 0; t < this.count; t++) {
                const n = t * this.data.stride + this.offset;
                for (let t = 0; t < this.itemSize; t++)
                  e.push(this.data.array[n + t]);
              }
              return new yt(
                new this.array.constructor(e),
                this.itemSize,
                this.normalized
              );
            }
            return (
              void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
              void 0 === e.interleavedBuffers[this.data.uuid] &&
                (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
              new Cr(
                e.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
          },
          toJSON: function (e) {
            if (void 0 === e) {
              console.log(
                "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
              );
              const e = [];
              for (let t = 0; t < this.count; t++) {
                const n = t * this.data.stride + this.offset;
                for (let t = 0; t < this.itemSize; t++)
                  e.push(this.data.array[n + t]);
              }
              return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: e,
                normalized: this.normalized,
              };
            }
            return (
              void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
              void 0 === e.interleavedBuffers[this.data.uuid] &&
                (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
          },
        }),
        (Or.prototype = Object.create(ft.prototype)),
        (Or.prototype.constructor = Or),
        (Or.prototype.isSpriteMaterial = !0),
        (Or.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.rotation = e.rotation),
            (this.sizeAttenuation = e.sizeAttenuation),
            this
          );
        });
      const Ir = new W(),
        Dr = new W(),
        jr = new W(),
        Fr = new N(),
        Hr = new N(),
        Br = new ye(),
        zr = new W(),
        Ur = new W(),
        Gr = new W(),
        Wr = new N(),
        Vr = new N(),
        qr = new N();
      function Xr(e) {
        if ((Ge.call(this), (this.type = "Sprite"), void 0 === Nr)) {
          Nr = new Ht();
          const e = new Rr(
            new Float32Array([
              -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5,
              0.5, 0, 0, 1,
            ]),
            5
          );
          Nr.setIndex([0, 1, 2, 0, 2, 3]),
            Nr.setAttribute("position", new Cr(e, 3, 0, !1)),
            Nr.setAttribute("uv", new Cr(e, 2, 3, !1));
        }
        (this.geometry = Nr),
          (this.material = void 0 !== e ? e : new Or()),
          (this.center = new N(0.5, 0.5));
      }
      function Yr(e, t, n, i, r, a) {
        Fr.subVectors(e, n).addScalar(0.5).multiply(i),
          void 0 !== r
            ? ((Hr.x = a * Fr.x - r * Fr.y), (Hr.y = r * Fr.x + a * Fr.y))
            : Hr.copy(Fr),
          e.copy(t),
          (e.x += Hr.x),
          (e.y += Hr.y),
          e.applyMatrix4(Br);
      }
      Xr.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: Xr,
        isSprite: !0,
        raycast: function (e, t) {
          null === e.camera &&
            console.error(
              'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            Dr.setFromMatrixScale(this.matrixWorld),
            Br.copy(e.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
              e.camera.matrixWorldInverse,
              this.matrixWorld
            ),
            jr.setFromMatrixPosition(this.modelViewMatrix),
            e.camera.isPerspectiveCamera &&
              !1 === this.material.sizeAttenuation &&
              Dr.multiplyScalar(-jr.z);
          const n = this.material.rotation;
          let i, r;
          0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
          const a = this.center;
          Yr(zr.set(-0.5, -0.5, 0), jr, a, Dr, i, r),
            Yr(Ur.set(0.5, -0.5, 0), jr, a, Dr, i, r),
            Yr(Gr.set(0.5, 0.5, 0), jr, a, Dr, i, r),
            Wr.set(0, 0),
            Vr.set(1, 0),
            qr.set(1, 1);
          let o = e.ray.intersectTriangle(zr, Ur, Gr, !1, Ir);
          if (
            null === o &&
            (Yr(Ur.set(-0.5, 0.5, 0), jr, a, Dr, i, r),
            Vr.set(0, 1),
            (o = e.ray.intersectTriangle(zr, Gr, Ur, !1, Ir)),
            null === o)
          )
            return;
          const s = e.ray.origin.distanceTo(Ir);
          s < e.near ||
            s > e.far ||
            t.push({
              distance: s,
              point: Ir.clone(),
              uv: rt.getUV(Ir, zr, Ur, Gr, Wr, Vr, qr, new N()),
              face: null,
              object: this,
            });
        },
        copy: function (e) {
          return (
            Ge.prototype.copy.call(this, e),
            void 0 !== e.center && this.center.copy(e.center),
            (this.material = e.material),
            this
          );
        },
      });
      const Jr = new W(),
        Zr = new W();
      function Qr() {
        Ge.call(this),
          (this._currentLevel = 0),
          (this.type = "LOD"),
          Object.defineProperties(this, {
            levels: { enumerable: !0, value: [] },
          }),
          (this.autoUpdate = !0);
      }
      Qr.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: Qr,
        isLOD: !0,
        copy: function (e) {
          Ge.prototype.copy.call(this, e, !1);
          const t = e.levels;
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            this.addLevel(n.object.clone(), n.distance);
          }
          return (this.autoUpdate = e.autoUpdate), this;
        },
        addLevel: function (e, t = 0) {
          t = Math.abs(t);
          const n = this.levels;
          let i;
          for (i = 0; i < n.length && !(t < n[i].distance); i++);
          return n.splice(i, 0, { distance: t, object: e }), this.add(e), this;
        },
        getCurrentLevel: function () {
          return this._currentLevel;
        },
        getObjectForDistance: function (e) {
          const t = this.levels;
          if (t.length > 0) {
            let n, i;
            for (n = 1, i = t.length; n < i && !(e < t[n].distance); n++);
            return t[n - 1].object;
          }
          return null;
        },
        raycast: function (e, t) {
          if (this.levels.length > 0) {
            Jr.setFromMatrixPosition(this.matrixWorld);
            const n = e.ray.origin.distanceTo(Jr);
            this.getObjectForDistance(n).raycast(e, t);
          }
        },
        update: function (e) {
          const t = this.levels;
          if (t.length > 1) {
            Jr.setFromMatrixPosition(e.matrixWorld),
              Zr.setFromMatrixPosition(this.matrixWorld);
            const n = Jr.distanceTo(Zr) / e.zoom;
            let i, r;
            for (
              t[0].object.visible = !0, i = 1, r = t.length;
              i < r && n >= t[i].distance;
              i++
            )
              (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
            for (this._currentLevel = i - 1; i < r; i++)
              t[i].object.visible = !1;
          }
        },
        toJSON: function (e) {
          const t = Ge.prototype.toJSON.call(this, e);
          !1 === this.autoUpdate && (t.object.autoUpdate = !1),
            (t.object.levels = []);
          const n = this.levels;
          for (let e = 0, i = n.length; e < i; e++) {
            const i = n[e];
            t.object.levels.push({
              object: i.object.uuid,
              distance: i.distance,
            });
          }
          return t;
        },
      });
      const Kr = new W(),
        $r = new z(),
        ea = new z(),
        ta = new W(),
        na = new ye();
      function ia(e, t) {
        e &&
          e.isGeometry &&
          console.error(
            "THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          ),
          rn.call(this, e, t),
          (this.type = "SkinnedMesh"),
          (this.bindMode = "attached"),
          (this.bindMatrix = new ye()),
          (this.bindMatrixInverse = new ye());
      }
      function ra() {
        Ge.call(this), (this.type = "Bone");
      }
      (ia.prototype = Object.assign(Object.create(rn.prototype), {
        constructor: ia,
        isSkinnedMesh: !0,
        copy: function (e) {
          return (
            rn.prototype.copy.call(this, e),
            (this.bindMode = e.bindMode),
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            (this.skeleton = e.skeleton),
            this
          );
        },
        bind: function (e, t) {
          (this.skeleton = e),
            void 0 === t &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (t = this.matrixWorld)),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert();
        },
        pose: function () {
          this.skeleton.pose();
        },
        normalizeSkinWeights: function () {
          const e = new z(),
            t = this.geometry.attributes.skinWeight;
          for (let n = 0, i = t.count; n < i; n++) {
            (e.x = t.getX(n)),
              (e.y = t.getY(n)),
              (e.z = t.getZ(n)),
              (e.w = t.getW(n));
            const i = 1 / e.manhattanLength();
            i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
              t.setXYZW(n, e.x, e.y, e.z, e.w);
          }
        },
        updateMatrixWorld: function (e) {
          rn.prototype.updateMatrixWorld.call(this, e),
            "attached" === this.bindMode
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : "detached" === this.bindMode
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        },
        boneTransform: function (e, t) {
          const n = this.skeleton,
            i = this.geometry;
          $r.fromBufferAttribute(i.attributes.skinIndex, e),
            ea.fromBufferAttribute(i.attributes.skinWeight, e),
            Kr.fromBufferAttribute(i.attributes.position, e).applyMatrix4(
              this.bindMatrix
            ),
            t.set(0, 0, 0);
          for (let e = 0; e < 4; e++) {
            const i = ea.getComponent(e);
            if (0 !== i) {
              const r = $r.getComponent(e);
              na.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                t.addScaledVector(ta.copy(Kr).applyMatrix4(na), i);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        },
      })),
        (ra.prototype = Object.assign(Object.create(Ge.prototype), {
          constructor: ra,
          isBone: !0,
        }));
      const aa = new ye(),
        oa = new ye();
      function sa(e = [], t = []) {
        (this.uuid = O.generateUUID()),
          (this.bones = e.slice(0)),
          (this.boneInverses = t),
          (this.boneMatrices = null),
          (this.boneTexture = null),
          (this.boneTextureSize = 0),
          (this.frame = -1),
          this.init();
      }
      Object.assign(sa.prototype, {
        init: function () {
          const e = this.bones,
            t = this.boneInverses;
          if (
            ((this.boneMatrices = new Float32Array(16 * e.length)),
            0 === t.length)
          )
            this.calculateInverses();
          else if (e.length !== t.length) {
            console.warn(
              "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
            ),
              (this.boneInverses = []);
            for (let e = 0, t = this.bones.length; e < t; e++)
              this.boneInverses.push(new ye());
          }
        },
        calculateInverses: function () {
          this.boneInverses.length = 0;
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = new ye();
            this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
              this.boneInverses.push(t);
          }
        },
        pose: function () {
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = this.bones[e];
            t && t.matrixWorld.copy(this.boneInverses[e]).invert();
          }
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = this.bones[e];
            t &&
              (t.parent && t.parent.isBone
                ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                  t.matrix.multiply(t.matrixWorld))
                : t.matrix.copy(t.matrixWorld),
              t.matrix.decompose(t.position, t.quaternion, t.scale));
          }
        },
        update: function () {
          const e = this.bones,
            t = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture;
          for (let i = 0, r = e.length; i < r; i++) {
            const r = e[i] ? e[i].matrixWorld : oa;
            aa.multiplyMatrices(r, t[i]), aa.toArray(n, 16 * i);
          }
          null !== i && (i.needsUpdate = !0);
        },
        clone: function () {
          return new sa(this.bones, this.boneInverses);
        },
        getBoneByName: function (e) {
          for (let t = 0, n = this.bones.length; t < n; t++) {
            const n = this.bones[t];
            if (n.name === e) return n;
          }
        },
        dispose: function () {
          null !== this.boneTexture &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
        },
        fromJSON: function (e, t) {
          this.uuid = e.uuid;
          for (let n = 0, i = e.bones.length; n < i; n++) {
            const i = e.bones[n];
            let r = t[i];
            void 0 === r &&
              (console.warn("THREE.Skeleton: No bone found with UUID:", i),
              (r = new ra())),
              this.bones.push(r),
              this.boneInverses.push(new ye().fromArray(e.boneInverses[n]));
          }
          return this.init(), this;
        },
        toJSON: function () {
          const e = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON",
            },
            bones: [],
            boneInverses: [],
          };
          e.uuid = this.uuid;
          const t = this.bones,
            n = this.boneInverses;
          for (let i = 0, r = t.length; i < r; i++) {
            const r = t[i];
            e.bones.push(r.uuid);
            const a = n[i];
            e.boneInverses.push(a.toArray());
          }
          return e;
        },
      });
      const ca = new ye(),
        la = new ye(),
        ha = [],
        ua = new rn();
      function pa(e, t, n) {
        rn.call(this, e, t),
          (this.instanceMatrix = new yt(new Float32Array(16 * n), 16)),
          (this.instanceColor = null),
          (this.count = n),
          (this.frustumCulled = !1);
      }
      function da(e) {
        ft.call(this),
          (this.type = "LineBasicMaterial"),
          (this.color = new ut(16777215)),
          (this.linewidth = 1),
          (this.linecap = "round"),
          (this.linejoin = "round"),
          (this.morphTargets = !1),
          this.setValues(e);
      }
      (pa.prototype = Object.assign(Object.create(rn.prototype), {
        constructor: pa,
        isInstancedMesh: !0,
        copy: function (e) {
          return (
            rn.prototype.copy.call(this, e),
            this.instanceMatrix.copy(e.instanceMatrix),
            null !== e.instanceColor &&
              (this.instanceColor = e.instanceColor.clone()),
            (this.count = e.count),
            this
          );
        },
        getColorAt: function (e, t) {
          t.fromArray(this.instanceColor.array, 3 * e);
        },
        getMatrixAt: function (e, t) {
          t.fromArray(this.instanceMatrix.array, 16 * e);
        },
        raycast: function (e, t) {
          const n = this.matrixWorld,
            i = this.count;
          if (
            ((ua.geometry = this.geometry),
            (ua.material = this.material),
            void 0 !== ua.material)
          )
            for (let r = 0; r < i; r++) {
              this.getMatrixAt(r, ca),
                la.multiplyMatrices(n, ca),
                (ua.matrixWorld = la),
                ua.raycast(e, ha);
              for (let e = 0, n = ha.length; e < n; e++) {
                const n = ha[e];
                (n.instanceId = r), (n.object = this), t.push(n);
              }
              ha.length = 0;
            }
        },
        setColorAt: function (e, t) {
          null === this.instanceColor &&
            (this.instanceColor = new yt(new Float32Array(3 * this.count), 3)),
            t.toArray(this.instanceColor.array, 3 * e);
        },
        setMatrixAt: function (e, t) {
          t.toArray(this.instanceMatrix.array, 16 * e);
        },
        updateMorphTargets: function () {},
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      })),
        (da.prototype = Object.create(ft.prototype)),
        (da.prototype.constructor = da),
        (da.prototype.isLineBasicMaterial = !0),
        (da.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            (this.morphTargets = e.morphTargets),
            this
          );
        });
      const fa = new W(),
        ma = new W(),
        ga = new ye(),
        va = new ve(),
        ya = new le();
      function _a(e = new Ht(), t = new da()) {
        Ge.call(this),
          (this.type = "Line"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      _a.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: _a,
        isLine: !0,
        copy: function (e) {
          return (
            Ge.prototype.copy.call(this, e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        },
        computeLineDistances: function () {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (null === e.index) {
              const t = e.attributes.position,
                n = [0];
              for (let e = 1, i = t.count; e < i; e++)
                fa.fromBufferAttribute(t, e - 1),
                  ma.fromBufferAttribute(t, e),
                  (n[e] = n[e - 1]),
                  (n[e] += fa.distanceTo(ma));
              e.setAttribute("lineDistance", new At(n, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        },
        raycast: function (e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Line.threshold;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            ya.copy(n.boundingSphere),
            ya.applyMatrix4(i),
            (ya.radius += r),
            !1 === e.ray.intersectsSphere(ya))
          )
            return;
          ga.copy(i).invert(), va.copy(e.ray).applyMatrix4(ga);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a,
            s = new W(),
            c = new W(),
            l = new W(),
            h = new W(),
            u = this.isLineSegments ? 2 : 1;
          if (n.isBufferGeometry) {
            const i = n.index,
              r = n.attributes.position;
            if (null !== i) {
              const n = i.array;
              for (let i = 0, a = n.length - 1; i < a; i += u) {
                const a = n[i],
                  u = n[i + 1];
                if (
                  (s.fromBufferAttribute(r, a),
                  c.fromBufferAttribute(r, u),
                  va.distanceSqToSegment(s, c, h, l) > o)
                )
                  continue;
                h.applyMatrix4(this.matrixWorld);
                const p = e.ray.origin.distanceTo(h);
                p < e.near ||
                  p > e.far ||
                  t.push({
                    distance: p,
                    point: l.clone().applyMatrix4(this.matrixWorld),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            } else
              for (let n = 0, i = r.count - 1; n < i; n += u) {
                if (
                  (s.fromBufferAttribute(r, n),
                  c.fromBufferAttribute(r, n + 1),
                  va.distanceSqToSegment(s, c, h, l) > o)
                )
                  continue;
                h.applyMatrix4(this.matrixWorld);
                const i = e.ray.origin.distanceTo(h);
                i < e.near ||
                  i > e.far ||
                  t.push({
                    distance: i,
                    point: l.clone().applyMatrix4(this.matrixWorld),
                    index: n,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        },
        updateMorphTargets: function () {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const e = t[n[0]];
              if (void 0 !== e) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t].name || String(t);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = t);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            void 0 !== t &&
              t.length > 0 &&
              console.error(
                "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        },
      });
      const wa = new W(),
        xa = new W();
      function ba(e, t) {
        _a.call(this, e, t), (this.type = "LineSegments");
      }
      function Ma(e, t) {
        _a.call(this, e, t), (this.type = "LineLoop");
      }
      function Sa(e) {
        ft.call(this),
          (this.type = "PointsMaterial"),
          (this.color = new ut(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.size = 1),
          (this.sizeAttenuation = !0),
          (this.morphTargets = !1),
          this.setValues(e);
      }
      (ba.prototype = Object.assign(Object.create(_a.prototype), {
        constructor: ba,
        isLineSegments: !0,
        computeLineDistances: function () {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (null === e.index) {
              const t = e.attributes.position,
                n = [];
              for (let e = 0, i = t.count; e < i; e += 2)
                wa.fromBufferAttribute(t, e),
                  xa.fromBufferAttribute(t, e + 1),
                  (n[e] = 0 === e ? 0 : n[e - 1]),
                  (n[e + 1] = n[e] + wa.distanceTo(xa));
              e.setAttribute("lineDistance", new At(n, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        },
      })),
        (Ma.prototype = Object.assign(Object.create(_a.prototype), {
          constructor: Ma,
          isLineLoop: !0,
        })),
        (Sa.prototype = Object.create(ft.prototype)),
        (Sa.prototype.constructor = Sa),
        (Sa.prototype.isPointsMaterial = !0),
        (Sa.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.morphTargets = e.morphTargets),
            this
          );
        });
      const Ta = new ye(),
        Ea = new ve(),
        Aa = new le(),
        La = new W();
      function Pa(e = new Ht(), t = new Sa()) {
        Ge.call(this),
          (this.type = "Points"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      function Ra(e, t, n, i, r, a, o) {
        const s = Ea.distanceSqToPoint(e);
        if (s < n) {
          const n = new W();
          Ea.closestPointToPoint(e, n), n.applyMatrix4(i);
          const c = r.ray.origin.distanceTo(n);
          if (c < r.near || c > r.far) return;
          a.push({
            distance: c,
            distanceToRay: Math.sqrt(s),
            point: n,
            index: t,
            face: null,
            object: o,
          });
        }
      }
      function ka(e, t, n, i, r, a, o, c, l) {
        H.call(this, e, t, n, i, r, a, o, c, l),
          (this.format = void 0 !== o ? o : f),
          (this.minFilter = void 0 !== a ? a : s),
          (this.magFilter = void 0 !== r ? r : s),
          (this.generateMipmaps = !1);
        const h = this;
        "requestVideoFrameCallback" in e &&
          e.requestVideoFrameCallback(function t() {
            (h.needsUpdate = !0), e.requestVideoFrameCallback(t);
          });
      }
      function Ca(e, t, n, i, r, a, o, s, c, l, h, u) {
        H.call(this, null, a, o, s, c, l, i, r, h, u),
          (this.image = { width: t, height: n }),
          (this.mipmaps = e),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
      function Oa(e, t, n, i, r, a, o, s, c) {
        H.call(this, e, t, n, i, r, a, o, s, c), (this.needsUpdate = !0);
      }
      function Na(e, t, n, i, a, o, s, c, h, u) {
        if ((u = void 0 !== u ? u : g) !== g && u !== v)
          throw new Error(
            "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
          );
        void 0 === n && u === g && (n = l),
          void 0 === n && u === v && (n = d),
          H.call(this, null, i, a, o, s, c, u, n, h),
          (this.image = { width: e, height: t }),
          (this.magFilter = void 0 !== s ? s : r),
          (this.minFilter = void 0 !== c ? c : r),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
      (Pa.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: Pa,
        isPoints: !0,
        copy: function (e) {
          return (
            Ge.prototype.copy.call(this, e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        },
        raycast: function (e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Points.threshold;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            Aa.copy(n.boundingSphere),
            Aa.applyMatrix4(i),
            (Aa.radius += r),
            !1 === e.ray.intersectsSphere(Aa))
          )
            return;
          Ta.copy(i).invert(), Ea.copy(e.ray).applyMatrix4(Ta);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a;
          if (n.isBufferGeometry) {
            const r = n.index,
              a = n.attributes.position;
            if (null !== r) {
              const n = r.array;
              for (let r = 0, s = n.length; r < s; r++) {
                const s = n[r];
                La.fromBufferAttribute(a, s), Ra(La, s, o, i, e, t, this);
              }
            } else
              for (let n = 0, r = a.count; n < r; n++)
                La.fromBufferAttribute(a, n), Ra(La, n, o, i, e, t, this);
          } else
            console.error(
              "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        },
        updateMorphTargets: function () {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const e = t[n[0]];
              if (void 0 !== e) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t].name || String(t);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = t);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            void 0 !== t &&
              t.length > 0 &&
              console.error(
                "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        },
      })),
        (ka.prototype = Object.assign(Object.create(H.prototype), {
          constructor: ka,
          clone: function () {
            return new this.constructor(this.image).copy(this);
          },
          isVideoTexture: !0,
          update: function () {
            const e = this.image;
            !1 == "requestVideoFrameCallback" in e &&
              e.readyState >= e.HAVE_CURRENT_DATA &&
              (this.needsUpdate = !0);
          },
        })),
        (Ca.prototype = Object.create(H.prototype)),
        (Ca.prototype.constructor = Ca),
        (Ca.prototype.isCompressedTexture = !0),
        (Oa.prototype = Object.create(H.prototype)),
        (Oa.prototype.constructor = Oa),
        (Oa.prototype.isCanvasTexture = !0),
        (Na.prototype = Object.create(H.prototype)),
        (Na.prototype.constructor = Na),
        (Na.prototype.isDepthTexture = !0);
      new W(), new W(), new W(), new rt();
      function Ia(e, t, n, i, r) {
        let a, o;
        if (
          r ===
          (function (e, t, n, i) {
            let r = 0;
            for (let a = t, o = n - i; a < n; a += i)
              (r += (e[o] - e[a]) * (e[a + 1] + e[o + 1])), (o = a);
            return r;
          })(e, t, n, i) >
            0
        )
          for (a = t; a < n; a += i) o = no(a, e[a], e[a + 1], o);
        else for (a = n - i; a >= t; a -= i) o = no(a, e[a], e[a + 1], o);
        return o && Za(o, o.next) && (io(o), (o = o.next)), o;
      }
      function Da(e, t) {
        if (!e) return e;
        t || (t = e);
        let n,
          i = e;
        do {
          if (
            ((n = !1),
            i.steiner || (!Za(i, i.next) && 0 !== Ja(i.prev, i, i.next)))
          )
            i = i.next;
          else {
            if ((io(i), (i = t = i.prev), i === i.next)) break;
            n = !0;
          }
        } while (n || i !== t);
        return t;
      }
      function ja(e, t, n, i, r, a, o) {
        if (!e) return;
        !o &&
          a &&
          (function (e, t, n, i) {
            let r = e;
            do {
              null === r.z && (r.z = Va(r.x, r.y, t, n, i)),
                (r.prevZ = r.prev),
                (r.nextZ = r.next),
                (r = r.next);
            } while (r !== e);
            (r.prevZ.nextZ = null),
              (r.prevZ = null),
              (function (e) {
                let t,
                  n,
                  i,
                  r,
                  a,
                  o,
                  s,
                  c,
                  l = 1;
                do {
                  for (n = e, e = null, a = null, o = 0; n; ) {
                    for (
                      o++, i = n, s = 0, t = 0;
                      t < l && (s++, (i = i.nextZ), i);
                      t++
                    );
                    for (c = l; s > 0 || (c > 0 && i); )
                      0 !== s && (0 === c || !i || n.z <= i.z)
                        ? ((r = n), (n = n.nextZ), s--)
                        : ((r = i), (i = i.nextZ), c--),
                        a ? (a.nextZ = r) : (e = r),
                        (r.prevZ = a),
                        (a = r);
                    n = i;
                  }
                  (a.nextZ = null), (l *= 2);
                } while (o > 1);
              })(r);
          })(e, i, r, a);
        let s,
          c,
          l = e;
        for (; e.prev !== e.next; )
          if (((s = e.prev), (c = e.next), a ? Ha(e, i, r, a) : Fa(e)))
            t.push(s.i / n),
              t.push(e.i / n),
              t.push(c.i / n),
              io(e),
              (e = c.next),
              (l = c.next);
          else if ((e = c) === l) {
            o
              ? 1 === o
                ? ja((e = Ba(Da(e), t, n)), t, n, i, r, a, 2)
                : 2 === o && za(e, t, n, i, r, a)
              : ja(Da(e), t, n, i, r, a, 1);
            break;
          }
      }
      function Fa(e) {
        const t = e.prev,
          n = e,
          i = e.next;
        if (Ja(t, n, i) >= 0) return !1;
        let r = e.next.next;
        for (; r !== e.prev; ) {
          if (
            Xa(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
            Ja(r.prev, r, r.next) >= 0
          )
            return !1;
          r = r.next;
        }
        return !0;
      }
      function Ha(e, t, n, i) {
        const r = e.prev,
          a = e,
          o = e.next;
        if (Ja(r, a, o) >= 0) return !1;
        const s = r.x < a.x ? (r.x < o.x ? r.x : o.x) : a.x < o.x ? a.x : o.x,
          c = r.y < a.y ? (r.y < o.y ? r.y : o.y) : a.y < o.y ? a.y : o.y,
          l = r.x > a.x ? (r.x > o.x ? r.x : o.x) : a.x > o.x ? a.x : o.x,
          h = r.y > a.y ? (r.y > o.y ? r.y : o.y) : a.y > o.y ? a.y : o.y,
          u = Va(s, c, t, n, i),
          p = Va(l, h, t, n, i);
        let d = e.prevZ,
          f = e.nextZ;
        for (; d && d.z >= u && f && f.z <= p; ) {
          if (
            d !== e.prev &&
            d !== e.next &&
            Xa(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
            Ja(d.prev, d, d.next) >= 0
          )
            return !1;
          if (
            ((d = d.prevZ),
            f !== e.prev &&
              f !== e.next &&
              Xa(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
              Ja(f.prev, f, f.next) >= 0)
          )
            return !1;
          f = f.nextZ;
        }
        for (; d && d.z >= u; ) {
          if (
            d !== e.prev &&
            d !== e.next &&
            Xa(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
            Ja(d.prev, d, d.next) >= 0
          )
            return !1;
          d = d.prevZ;
        }
        for (; f && f.z <= p; ) {
          if (
            f !== e.prev &&
            f !== e.next &&
            Xa(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
            Ja(f.prev, f, f.next) >= 0
          )
            return !1;
          f = f.nextZ;
        }
        return !0;
      }
      function Ba(e, t, n) {
        let i = e;
        do {
          const r = i.prev,
            a = i.next.next;
          !Za(r, a) &&
            Qa(r, i, i.next, a) &&
            eo(r, a) &&
            eo(a, r) &&
            (t.push(r.i / n),
            t.push(i.i / n),
            t.push(a.i / n),
            io(i),
            io(i.next),
            (i = e = a)),
            (i = i.next);
        } while (i !== e);
        return Da(i);
      }
      function za(e, t, n, i, r, a) {
        let o = e;
        do {
          let e = o.next.next;
          for (; e !== o.prev; ) {
            if (o.i !== e.i && Ya(o, e)) {
              let s = to(o, e);
              return (
                (o = Da(o, o.next)),
                (s = Da(s, s.next)),
                ja(o, t, n, i, r, a),
                void ja(s, t, n, i, r, a)
              );
            }
            e = e.next;
          }
          o = o.next;
        } while (o !== e);
      }
      function Ua(e, t) {
        return e.x - t.x;
      }
      function Ga(e, t) {
        if (
          (t = (function (e, t) {
            let n = t;
            const i = e.x,
              r = e.y;
            let a,
              o = -1 / 0;
            do {
              if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                const e =
                  n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
                if (e <= i && e > o) {
                  if (((o = e), e === i)) {
                    if (r === n.y) return n;
                    if (r === n.next.y) return n.next;
                  }
                  a = n.x < n.next.x ? n : n.next;
                }
              }
              n = n.next;
            } while (n !== t);
            if (!a) return null;
            if (i === o) return a;
            const s = a,
              c = a.x,
              l = a.y;
            let h,
              u = 1 / 0;
            n = a;
            do {
              i >= n.x &&
                n.x >= c &&
                i !== n.x &&
                Xa(r < l ? i : o, r, c, l, r < l ? o : i, r, n.x, n.y) &&
                ((h = Math.abs(r - n.y) / (i - n.x)),
                eo(n, e) &&
                  (h < u ||
                    (h === u && (n.x > a.x || (n.x === a.x && Wa(a, n))))) &&
                  ((a = n), (u = h))),
                (n = n.next);
            } while (n !== s);
            return a;
          })(e, t))
        ) {
          const n = to(t, e);
          Da(t, t.next), Da(n, n.next);
        }
      }
      function Wa(e, t) {
        return Ja(e.prev, e, t.prev) < 0 && Ja(t.next, e, e.next) < 0;
      }
      function Va(e, t, n, i, r) {
        return (
          (e =
            1431655765 &
            ((e =
              858993459 &
              ((e =
                252645135 &
                ((e = 16711935 & ((e = 32767 * (e - n) * r) | (e << 8))) |
                  (e << 4))) |
                (e << 2))) |
              (e << 1))) |
          ((t =
            1431655765 &
            ((t =
              858993459 &
              ((t =
                252645135 &
                ((t = 16711935 & ((t = 32767 * (t - i) * r) | (t << 8))) |
                  (t << 4))) |
                (t << 2))) |
              (t << 1))) <<
            1)
        );
      }
      function qa(e) {
        let t = e,
          n = e;
        do {
          (t.x < n.x || (t.x === n.x && t.y < n.y)) && (n = t), (t = t.next);
        } while (t !== e);
        return n;
      }
      function Xa(e, t, n, i, r, a, o, s) {
        return (
          (r - o) * (t - s) - (e - o) * (a - s) >= 0 &&
          (e - o) * (i - s) - (n - o) * (t - s) >= 0 &&
          (n - o) * (a - s) - (r - o) * (i - s) >= 0
        );
      }
      function Ya(e, t) {
        return (
          e.next.i !== t.i &&
          e.prev.i !== t.i &&
          !(function (e, t) {
            let n = e;
            do {
              if (
                n.i !== e.i &&
                n.next.i !== e.i &&
                n.i !== t.i &&
                n.next.i !== t.i &&
                Qa(n, n.next, e, t)
              )
                return !0;
              n = n.next;
            } while (n !== e);
            return !1;
          })(e, t) &&
          ((eo(e, t) &&
            eo(t, e) &&
            (function (e, t) {
              let n = e,
                i = !1;
              const r = (e.x + t.x) / 2,
                a = (e.y + t.y) / 2;
              do {
                n.y > a != n.next.y > a &&
                  n.next.y !== n.y &&
                  r < ((n.next.x - n.x) * (a - n.y)) / (n.next.y - n.y) + n.x &&
                  (i = !i),
                  (n = n.next);
              } while (n !== e);
              return i;
            })(e, t) &&
            (Ja(e.prev, e, t.prev) || Ja(e, t.prev, t))) ||
            (Za(e, t) &&
              Ja(e.prev, e, e.next) > 0 &&
              Ja(t.prev, t, t.next) > 0))
        );
      }
      function Ja(e, t, n) {
        return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
      }
      function Za(e, t) {
        return e.x === t.x && e.y === t.y;
      }
      function Qa(e, t, n, i) {
        const r = $a(Ja(e, t, n)),
          a = $a(Ja(e, t, i)),
          o = $a(Ja(n, i, e)),
          s = $a(Ja(n, i, t));
        return (
          (r !== a && o !== s) ||
          !(0 !== r || !Ka(e, n, t)) ||
          !(0 !== a || !Ka(e, i, t)) ||
          !(0 !== o || !Ka(n, e, i)) ||
          !(0 !== s || !Ka(n, t, i))
        );
      }
      function Ka(e, t, n) {
        return (
          t.x <= Math.max(e.x, n.x) &&
          t.x >= Math.min(e.x, n.x) &&
          t.y <= Math.max(e.y, n.y) &&
          t.y >= Math.min(e.y, n.y)
        );
      }
      function $a(e) {
        return e > 0 ? 1 : e < 0 ? -1 : 0;
      }
      function eo(e, t) {
        return Ja(e.prev, e, e.next) < 0
          ? Ja(e, t, e.next) >= 0 && Ja(e, e.prev, t) >= 0
          : Ja(e, t, e.prev) < 0 || Ja(e, e.next, t) < 0;
      }
      function to(e, t) {
        const n = new ro(e.i, e.x, e.y),
          i = new ro(t.i, t.x, t.y),
          r = e.next,
          a = t.prev;
        return (
          (e.next = t),
          (t.prev = e),
          (n.next = r),
          (r.prev = n),
          (i.next = n),
          (n.prev = i),
          (a.next = i),
          (i.prev = a),
          i
        );
      }
      function no(e, t, n, i) {
        const r = new ro(e, t, n);
        return (
          i
            ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
            : ((r.prev = r), (r.next = r)),
          r
        );
      }
      function io(e) {
        (e.next.prev = e.prev),
          (e.prev.next = e.next),
          e.prevZ && (e.prevZ.nextZ = e.nextZ),
          e.nextZ && (e.nextZ.prevZ = e.prevZ);
      }
      function ro(e, t, n) {
        (this.i = e),
          (this.x = t),
          (this.y = n),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      const ao = {
        area: function (e) {
          const t = e.length;
          let n = 0;
          for (let i = t - 1, r = 0; r < t; i = r++)
            n += e[i].x * e[r].y - e[r].x * e[i].y;
          return 0.5 * n;
        },
        isClockWise: function (e) {
          return ao.area(e) < 0;
        },
        triangulateShape: function (e, t) {
          const n = [],
            i = [],
            r = [];
          oo(e), so(n, e);
          let a = e.length;
          t.forEach(oo);
          for (let e = 0; e < t.length; e++)
            i.push(a), (a += t[e].length), so(n, t[e]);
          const o = (function (e, t, n) {
            n = n || 2;
            const i = t && t.length,
              r = i ? t[0] * n : e.length;
            let a = Ia(e, 0, r, n, !0);
            const o = [];
            if (!a || a.next === a.prev) return o;
            let s, c, l, h, u, p, d;
            if (
              (i &&
                (a = (function (e, t, n, i) {
                  const r = [];
                  let a, o, s, c, l;
                  for (a = 0, o = t.length; a < o; a++)
                    (s = t[a] * i),
                      (c = a < o - 1 ? t[a + 1] * i : e.length),
                      (l = Ia(e, s, c, i, !1)),
                      l === l.next && (l.steiner = !0),
                      r.push(qa(l));
                  for (r.sort(Ua), a = 0; a < r.length; a++)
                    Ga(r[a], n), (n = Da(n, n.next));
                  return n;
                })(e, t, a, n)),
              e.length > 80 * n)
            ) {
              (s = l = e[0]), (c = h = e[1]);
              for (let t = n; t < r; t += n)
                (u = e[t]),
                  (p = e[t + 1]),
                  u < s && (s = u),
                  p < c && (c = p),
                  u > l && (l = u),
                  p > h && (h = p);
              (d = Math.max(l - s, h - c)), (d = 0 !== d ? 1 / d : 0);
            }
            return ja(a, o, n, s, c, d), o;
          })(n, i);
          for (let e = 0; e < o.length; e += 3) r.push(o.slice(e, e + 3));
          return r;
        },
      };
      function oo(e) {
        const t = e.length;
        t > 2 && e[t - 1].equals(e[0]) && e.pop();
      }
      function so(e, t) {
        for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y);
      }
      class co extends Ht {
        constructor(e, t) {
          super(),
            (this.type = "ExtrudeGeometry"),
            (this.parameters = { shapes: e, options: t }),
            (e = Array.isArray(e) ? e : [e]);
          const n = this,
            i = [],
            r = [];
          for (let t = 0, n = e.length; t < n; t++) a(e[t]);
          function a(e) {
            const a = [],
              o = void 0 !== t.curveSegments ? t.curveSegments : 12,
              s = void 0 !== t.steps ? t.steps : 1;
            let c = void 0 !== t.depth ? t.depth : 100,
              l = void 0 === t.bevelEnabled || t.bevelEnabled,
              h = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
              u = void 0 !== t.bevelSize ? t.bevelSize : h - 2,
              p = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
              d = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
            const f = t.extrudePath,
              m = void 0 !== t.UVGenerator ? t.UVGenerator : lo;
            void 0 !== t.amount &&
              (console.warn(
                "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
              ),
              (c = t.amount));
            let g,
              v,
              y,
              _,
              w,
              x = !1;
            f &&
              ((g = f.getSpacedPoints(s)),
              (x = !0),
              (l = !1),
              (v = f.computeFrenetFrames(s, !1)),
              (y = new W()),
              (_ = new W()),
              (w = new W())),
              l || ((d = 0), (h = 0), (u = 0), (p = 0));
            const b = e.extractPoints(o);
            let M = b.shape;
            const S = b.holes;
            if (!ao.isClockWise(M)) {
              M = M.reverse();
              for (let e = 0, t = S.length; e < t; e++) {
                const t = S[e];
                ao.isClockWise(t) && (S[e] = t.reverse());
              }
            }
            const T = ao.triangulateShape(M, S),
              E = M;
            for (let e = 0, t = S.length; e < t; e++) {
              const t = S[e];
              M = M.concat(t);
            }
            function A(e, t, n) {
              return (
                t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                t.clone().multiplyScalar(n).add(e)
              );
            }
            const L = M.length,
              P = T.length;
            function R(e, t, n) {
              let i, r, a;
              const o = e.x - t.x,
                s = e.y - t.y,
                c = n.x - e.x,
                l = n.y - e.y,
                h = o * o + s * s,
                u = o * l - s * c;
              if (Math.abs(u) > Number.EPSILON) {
                const u = Math.sqrt(h),
                  p = Math.sqrt(c * c + l * l),
                  d = t.x - s / u,
                  f = t.y + o / u,
                  m =
                    ((n.x - l / p - d) * l - (n.y + c / p - f) * c) /
                    (o * l - s * c);
                (i = d + o * m - e.x), (r = f + s * m - e.y);
                const g = i * i + r * r;
                if (g <= 2) return new N(i, r);
                a = Math.sqrt(g / 2);
              } else {
                let e = !1;
                o > Number.EPSILON
                  ? c > Number.EPSILON && (e = !0)
                  : o < -Number.EPSILON
                  ? c < -Number.EPSILON && (e = !0)
                  : Math.sign(s) === Math.sign(l) && (e = !0),
                  e
                    ? ((i = -s), (r = o), (a = Math.sqrt(h)))
                    : ((i = o), (r = s), (a = Math.sqrt(h / 2)));
              }
              return new N(i / a, r / a);
            }
            const k = [];
            for (
              let e = 0, t = E.length, n = t - 1, i = e + 1;
              e < t;
              e++, n++, i++
            )
              n === t && (n = 0),
                i === t && (i = 0),
                (k[e] = R(E[e], E[n], E[i]));
            const C = [];
            let O,
              I = k.concat();
            for (let e = 0, t = S.length; e < t; e++) {
              const t = S[e];
              O = [];
              for (
                let e = 0, n = t.length, i = n - 1, r = e + 1;
                e < n;
                e++, i++, r++
              )
                i === n && (i = 0),
                  r === n && (r = 0),
                  (O[e] = R(t[e], t[i], t[r]));
              C.push(O), (I = I.concat(O));
            }
            for (let e = 0; e < d; e++) {
              const t = e / d,
                n = h * Math.cos((t * Math.PI) / 2),
                i = u * Math.sin((t * Math.PI) / 2) + p;
              for (let e = 0, t = E.length; e < t; e++) {
                const t = A(E[e], k[e], i);
                F(t.x, t.y, -n);
              }
              for (let e = 0, t = S.length; e < t; e++) {
                const t = S[e];
                O = C[e];
                for (let e = 0, r = t.length; e < r; e++) {
                  const r = A(t[e], O[e], i);
                  F(r.x, r.y, -n);
                }
              }
            }
            const D = u + p;
            for (let e = 0; e < L; e++) {
              const t = l ? A(M[e], I[e], D) : M[e];
              x
                ? (_.copy(v.normals[0]).multiplyScalar(t.x),
                  y.copy(v.binormals[0]).multiplyScalar(t.y),
                  w.copy(g[0]).add(_).add(y),
                  F(w.x, w.y, w.z))
                : F(t.x, t.y, 0);
            }
            for (let e = 1; e <= s; e++)
              for (let t = 0; t < L; t++) {
                const n = l ? A(M[t], I[t], D) : M[t];
                x
                  ? (_.copy(v.normals[e]).multiplyScalar(n.x),
                    y.copy(v.binormals[e]).multiplyScalar(n.y),
                    w.copy(g[e]).add(_).add(y),
                    F(w.x, w.y, w.z))
                  : F(n.x, n.y, (c / s) * e);
              }
            for (let e = d - 1; e >= 0; e--) {
              const t = e / d,
                n = h * Math.cos((t * Math.PI) / 2),
                i = u * Math.sin((t * Math.PI) / 2) + p;
              for (let e = 0, t = E.length; e < t; e++) {
                const t = A(E[e], k[e], i);
                F(t.x, t.y, c + n);
              }
              for (let e = 0, t = S.length; e < t; e++) {
                const t = S[e];
                O = C[e];
                for (let e = 0, r = t.length; e < r; e++) {
                  const r = A(t[e], O[e], i);
                  x
                    ? F(r.x, r.y + g[s - 1].y, g[s - 1].x + n)
                    : F(r.x, r.y, c + n);
                }
              }
            }
            function j(e, t) {
              let n = e.length;
              for (; --n >= 0; ) {
                const i = n;
                let r = n - 1;
                r < 0 && (r = e.length - 1);
                for (let e = 0, n = s + 2 * d; e < n; e++) {
                  const n = L * e,
                    a = L * (e + 1);
                  B(t + i + n, t + r + n, t + r + a, t + i + a);
                }
              }
            }
            function F(e, t, n) {
              a.push(e), a.push(t), a.push(n);
            }
            function H(e, t, r) {
              z(e), z(t), z(r);
              const a = i.length / 3,
                o = m.generateTopUV(n, i, a - 3, a - 2, a - 1);
              U(o[0]), U(o[1]), U(o[2]);
            }
            function B(e, t, r, a) {
              z(e), z(t), z(a), z(t), z(r), z(a);
              const o = i.length / 3,
                s = m.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
              U(s[0]), U(s[1]), U(s[3]), U(s[1]), U(s[2]), U(s[3]);
            }
            function z(e) {
              i.push(a[3 * e + 0]), i.push(a[3 * e + 1]), i.push(a[3 * e + 2]);
            }
            function U(e) {
              r.push(e.x), r.push(e.y);
            }
            !(function () {
              const e = i.length / 3;
              if (l) {
                let e = 0,
                  t = L * e;
                for (let e = 0; e < P; e++) {
                  const n = T[e];
                  H(n[2] + t, n[1] + t, n[0] + t);
                }
                (e = s + 2 * d), (t = L * e);
                for (let e = 0; e < P; e++) {
                  const n = T[e];
                  H(n[0] + t, n[1] + t, n[2] + t);
                }
              } else {
                for (let e = 0; e < P; e++) {
                  const t = T[e];
                  H(t[2], t[1], t[0]);
                }
                for (let e = 0; e < P; e++) {
                  const t = T[e];
                  H(t[0] + L * s, t[1] + L * s, t[2] + L * s);
                }
              }
              n.addGroup(e, i.length / 3 - e, 0);
            })(),
              (function () {
                const e = i.length / 3;
                let t = 0;
                j(E, t), (t += E.length);
                for (let e = 0, n = S.length; e < n; e++) {
                  const n = S[e];
                  j(n, t), (t += n.length);
                }
                n.addGroup(e, i.length / 3 - e, 1);
              })();
          }
          this.setAttribute("position", new At(i, 3)),
            this.setAttribute("uv", new At(r, 2)),
            this.computeVertexNormals();
        }
        toJSON() {
          const e = Ht.prototype.toJSON.call(this);
          return (function (e, t, n) {
            if (((n.shapes = []), Array.isArray(e)))
              for (let t = 0, i = e.length; t < i; t++) {
                const i = e[t];
                n.shapes.push(i.uuid);
              }
            else n.shapes.push(e.uuid);
            return (
              void 0 !== t.extrudePath &&
                (n.options.extrudePath = t.extrudePath.toJSON()),
              n
            );
          })(this.parameters.shapes, this.parameters.options, e);
        }
      }
      const lo = {
        generateTopUV: function (e, t, n, i, r) {
          const a = t[3 * n],
            o = t[3 * n + 1],
            s = t[3 * i],
            c = t[3 * i + 1],
            l = t[3 * r],
            h = t[3 * r + 1];
          return [new N(a, o), new N(s, c), new N(l, h)];
        },
        generateSideWallUV: function (e, t, n, i, r, a) {
          const o = t[3 * n],
            s = t[3 * n + 1],
            c = t[3 * n + 2],
            l = t[3 * i],
            h = t[3 * i + 1],
            u = t[3 * i + 2],
            p = t[3 * r],
            d = t[3 * r + 1],
            f = t[3 * r + 2],
            m = t[3 * a],
            g = t[3 * a + 1],
            v = t[3 * a + 2];
          return Math.abs(s - h) < 0.01
            ? [
                new N(o, 1 - c),
                new N(l, 1 - u),
                new N(p, 1 - f),
                new N(m, 1 - v),
              ]
            : [
                new N(s, 1 - c),
                new N(h, 1 - u),
                new N(d, 1 - f),
                new N(g, 1 - v),
              ];
        },
      };
      function ho(e, t, n) {
        Ht.call(this),
          (this.type = "ParametricGeometry"),
          (this.parameters = { func: e, slices: t, stacks: n });
        const i = [],
          r = [],
          a = [],
          o = [],
          s = 1e-5,
          c = new W(),
          l = new W(),
          h = new W(),
          u = new W(),
          p = new W();
        e.length < 3 &&
          console.error(
            "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
          );
        const d = t + 1;
        for (let i = 0; i <= n; i++) {
          const d = i / n;
          for (let n = 0; n <= t; n++) {
            const i = n / t;
            e(i, d, l),
              r.push(l.x, l.y, l.z),
              i - s >= 0
                ? (e(i - s, d, h), u.subVectors(l, h))
                : (e(i + s, d, h), u.subVectors(h, l)),
              d - s >= 0
                ? (e(i, d - s, h), p.subVectors(l, h))
                : (e(i, d + s, h), p.subVectors(h, l)),
              c.crossVectors(u, p).normalize(),
              a.push(c.x, c.y, c.z),
              o.push(i, d);
          }
        }
        for (let e = 0; e < n; e++)
          for (let n = 0; n < t; n++) {
            const t = e * d + n,
              r = e * d + n + 1,
              a = (e + 1) * d + n + 1,
              o = (e + 1) * d + n;
            i.push(t, r, o), i.push(r, a, o);
          }
        this.setIndex(i),
          this.setAttribute("position", new At(r, 3)),
          this.setAttribute("normal", new At(a, 3)),
          this.setAttribute("uv", new At(o, 2));
      }
      (ho.prototype = Object.create(Ht.prototype)),
        (ho.prototype.constructor = ho);
      class uo extends Ht {
        constructor(e, t = 12) {
          super(),
            (this.type = "ShapeGeometry"),
            (this.parameters = { shapes: e, curveSegments: t });
          const n = [],
            i = [],
            r = [],
            a = [];
          let o = 0,
            s = 0;
          if (!1 === Array.isArray(e)) c(e);
          else
            for (let t = 0; t < e.length; t++)
              c(e[t]), this.addGroup(o, s, t), (o += s), (s = 0);
          function c(e) {
            const o = i.length / 3,
              c = e.extractPoints(t);
            let l = c.shape;
            const h = c.holes;
            !1 === ao.isClockWise(l) && (l = l.reverse());
            for (let e = 0, t = h.length; e < t; e++) {
              const t = h[e];
              !0 === ao.isClockWise(t) && (h[e] = t.reverse());
            }
            const u = ao.triangulateShape(l, h);
            for (let e = 0, t = h.length; e < t; e++) {
              const t = h[e];
              l = l.concat(t);
            }
            for (let e = 0, t = l.length; e < t; e++) {
              const t = l[e];
              i.push(t.x, t.y, 0), r.push(0, 0, 1), a.push(t.x, t.y);
            }
            for (let e = 0, t = u.length; e < t; e++) {
              const t = u[e],
                i = t[0] + o,
                r = t[1] + o,
                a = t[2] + o;
              n.push(i, r, a), (s += 3);
            }
          }
          this.setIndex(n),
            this.setAttribute("position", new At(i, 3)),
            this.setAttribute("normal", new At(r, 3)),
            this.setAttribute("uv", new At(a, 2));
        }
        toJSON() {
          const e = Ht.prototype.toJSON.call(this);
          return (function (e, t) {
            if (((t.shapes = []), Array.isArray(e)))
              for (let n = 0, i = e.length; n < i; n++) {
                const i = e[n];
                t.shapes.push(i.uuid);
              }
            else t.shapes.push(e.uuid);
            return t;
          })(this.parameters.shapes, e);
        }
      }
      function po(e) {
        ft.call(this),
          (this.type = "ShadowMaterial"),
          (this.color = new ut(0)),
          (this.transparent = !0),
          this.setValues(e);
      }
      function fo(e) {
        hn.call(this, e), (this.type = "RawShaderMaterial");
      }
      function mo(e) {
        ft.call(this),
          (this.defines = { STANDARD: "" }),
          (this.type = "MeshStandardMaterial"),
          (this.color = new ut(16777215)),
          (this.roughness = 1),
          (this.metalness = 0),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new ut(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new N(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.roughnessMap = null),
          (this.metalnessMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.envMapIntensity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          (this.vertexTangents = !1),
          this.setValues(e);
      }
      function go(e) {
        mo.call(this),
          (this.defines = { STANDARD: "", PHYSICAL: "" }),
          (this.type = "MeshPhysicalMaterial"),
          (this.clearcoat = 0),
          (this.clearcoatMap = null),
          (this.clearcoatRoughness = 0),
          (this.clearcoatRoughnessMap = null),
          (this.clearcoatNormalScale = new N(1, 1)),
          (this.clearcoatNormalMap = null),
          (this.reflectivity = 0.5),
          Object.defineProperty(this, "ior", {
            get: function () {
              return (
                (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity)
              );
            },
            set: function (e) {
              this.reflectivity = O.clamp((2.5 * (e - 1)) / (e + 1), 0, 1);
            },
          }),
          (this.sheen = null),
          (this.transmission = 0),
          (this.transmissionMap = null),
          this.setValues(e);
      }
      function vo(e) {
        ft.call(this),
          (this.type = "MeshPhongMaterial"),
          (this.color = new ut(16777215)),
          (this.specular = new ut(1118481)),
          (this.shininess = 30),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new ut(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new N(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = 0),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function yo(e) {
        ft.call(this),
          (this.defines = { TOON: "" }),
          (this.type = "MeshToonMaterial"),
          (this.color = new ut(16777215)),
          (this.map = null),
          (this.gradientMap = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new ut(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new N(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.alphaMap = null),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function _o(e) {
        ft.call(this),
          (this.type = "MeshNormalMaterial"),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new N(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function wo(e) {
        ft.call(this),
          (this.type = "MeshLambertMaterial"),
          (this.color = new ut(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new ut(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = 0),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function xo(e) {
        ft.call(this),
          (this.defines = { MATCAP: "" }),
          (this.type = "MeshMatcapMaterial"),
          (this.color = new ut(16777215)),
          (this.matcap = null),
          (this.map = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new N(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.alphaMap = null),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      function bo(e) {
        da.call(this),
          (this.type = "LineDashedMaterial"),
          (this.scale = 1),
          (this.dashSize = 3),
          (this.gapSize = 1),
          this.setValues(e);
      }
      (po.prototype = Object.create(ft.prototype)),
        (po.prototype.constructor = po),
        (po.prototype.isShadowMaterial = !0),
        (po.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e), this.color.copy(e.color), this
          );
        }),
        (fo.prototype = Object.create(hn.prototype)),
        (fo.prototype.constructor = fo),
        (fo.prototype.isRawShaderMaterial = !0),
        (mo.prototype = Object.create(ft.prototype)),
        (mo.prototype.constructor = mo),
        (mo.prototype.isMeshStandardMaterial = !0),
        (mo.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e),
            (this.defines = { STANDARD: "" }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.envMapIntensity = e.envMapIntensity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.vertexTangents = e.vertexTangents),
            this
          );
        }),
        (go.prototype = Object.create(mo.prototype)),
        (go.prototype.constructor = go),
        (go.prototype.isMeshPhysicalMaterial = !0),
        (go.prototype.copy = function (e) {
          return (
            mo.prototype.copy.call(this, e),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.reflectivity = e.reflectivity),
            e.sheen
              ? (this.sheen = (this.sheen || new ut()).copy(e.sheen))
              : (this.sheen = null),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            this
          );
        }),
        (vo.prototype = Object.create(ft.prototype)),
        (vo.prototype.constructor = vo),
        (vo.prototype.isMeshPhongMaterial = !0),
        (vo.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        (yo.prototype = Object.create(ft.prototype)),
        (yo.prototype.constructor = yo),
        (yo.prototype.isMeshToonMaterial = !0),
        (yo.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.gradientMap = e.gradientMap),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        (_o.prototype = Object.create(ft.prototype)),
        (_o.prototype.constructor = _o),
        (_o.prototype.isMeshNormalMaterial = !0),
        (_o.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        (wo.prototype = Object.create(ft.prototype)),
        (wo.prototype.constructor = wo),
        (wo.prototype.isMeshLambertMaterial = !0),
        (wo.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        (xo.prototype = Object.create(ft.prototype)),
        (xo.prototype.constructor = xo),
        (xo.prototype.isMeshMatcapMaterial = !0),
        (xo.prototype.copy = function (e) {
          return (
            ft.prototype.copy.call(this, e),
            (this.defines = { MATCAP: "" }),
            this.color.copy(e.color),
            (this.matcap = e.matcap),
            (this.map = e.map),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.skinning = e.skinning),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }),
        (bo.prototype = Object.create(da.prototype)),
        (bo.prototype.constructor = bo),
        (bo.prototype.isLineDashedMaterial = !0),
        (bo.prototype.copy = function (e) {
          return (
            da.prototype.copy.call(this, e),
            (this.scale = e.scale),
            (this.dashSize = e.dashSize),
            (this.gapSize = e.gapSize),
            this
          );
        });
      var Mo = Object.freeze({
        __proto__: null,
        ShadowMaterial: po,
        SpriteMaterial: Or,
        RawShaderMaterial: fo,
        ShaderMaterial: hn,
        PointsMaterial: Sa,
        MeshPhysicalMaterial: go,
        MeshStandardMaterial: mo,
        MeshPhongMaterial: vo,
        MeshToonMaterial: yo,
        MeshNormalMaterial: _o,
        MeshLambertMaterial: wo,
        MeshDepthMaterial: gr,
        MeshDistanceMaterial: vr,
        MeshBasicMaterial: mt,
        MeshMatcapMaterial: xo,
        LineDashedMaterial: bo,
        LineBasicMaterial: da,
        Material: ft,
      });
      const So = {
        arraySlice: function (e, t, n) {
          return So.isTypedArray(e)
            ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length))
            : e.slice(t, n);
        },
        convertArray: function (e, t, n) {
          return !e || (!n && e.constructor === t)
            ? e
            : "number" == typeof t.BYTES_PER_ELEMENT
            ? new t(e)
            : Array.prototype.slice.call(e);
        },
        isTypedArray: function (e) {
          return ArrayBuffer.isView(e) && !(e instanceof DataView);
        },
        getKeyframeOrder: function (e) {
          const t = e.length,
            n = new Array(t);
          for (let e = 0; e !== t; ++e) n[e] = e;
          return (
            n.sort(function (t, n) {
              return e[t] - e[n];
            }),
            n
          );
        },
        sortedArray: function (e, t, n) {
          const i = e.length,
            r = new e.constructor(i);
          for (let a = 0, o = 0; o !== i; ++a) {
            const i = n[a] * t;
            for (let n = 0; n !== t; ++n) r[o++] = e[i + n];
          }
          return r;
        },
        flattenJSON: function (e, t, n, i) {
          let r = 1,
            a = e[0];
          for (; void 0 !== a && void 0 === a[i]; ) a = e[r++];
          if (void 0 === a) return;
          let o = a[i];
          if (void 0 !== o)
            if (Array.isArray(o))
              do {
                (o = a[i]),
                  void 0 !== o && (t.push(a.time), n.push.apply(n, o)),
                  (a = e[r++]);
              } while (void 0 !== a);
            else if (void 0 !== o.toArray)
              do {
                (o = a[i]),
                  void 0 !== o && (t.push(a.time), o.toArray(n, n.length)),
                  (a = e[r++]);
              } while (void 0 !== a);
            else
              do {
                (o = a[i]),
                  void 0 !== o && (t.push(a.time), n.push(o)),
                  (a = e[r++]);
              } while (void 0 !== a);
        },
        subclip: function (e, t, n, i, r = 30) {
          const a = e.clone();
          a.name = t;
          const o = [];
          for (let e = 0; e < a.tracks.length; ++e) {
            const t = a.tracks[e],
              s = t.getValueSize(),
              c = [],
              l = [];
            for (let e = 0; e < t.times.length; ++e) {
              const a = t.times[e] * r;
              if (!(a < n || a >= i)) {
                c.push(t.times[e]);
                for (let n = 0; n < s; ++n) l.push(t.values[e * s + n]);
              }
            }
            0 !== c.length &&
              ((t.times = So.convertArray(c, t.times.constructor)),
              (t.values = So.convertArray(l, t.values.constructor)),
              o.push(t));
          }
          a.tracks = o;
          let s = 1 / 0;
          for (let e = 0; e < a.tracks.length; ++e)
            s > a.tracks[e].times[0] && (s = a.tracks[e].times[0]);
          for (let e = 0; e < a.tracks.length; ++e) a.tracks[e].shift(-1 * s);
          return a.resetDuration(), a;
        },
        makeClipAdditive: function (e, t = 0, n = e, i = 30) {
          i <= 0 && (i = 30);
          const r = n.tracks.length,
            a = t / i;
          for (let t = 0; t < r; ++t) {
            const i = n.tracks[t],
              r = i.ValueTypeName;
            if ("bool" === r || "string" === r) continue;
            const o = e.tracks.find(function (e) {
              return e.name === i.name && e.ValueTypeName === r;
            });
            if (void 0 === o) continue;
            let s = 0;
            const c = i.getValueSize();
            i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (s = c / 3);
            let l = 0;
            const h = o.getValueSize();
            o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (l = h / 3);
            const u = i.times.length - 1;
            let p;
            if (a <= i.times[0]) {
              const e = s,
                t = c - s;
              p = So.arraySlice(i.values, e, t);
            } else if (a >= i.times[u]) {
              const e = u * c + s,
                t = e + c - s;
              p = So.arraySlice(i.values, e, t);
            } else {
              const e = i.createInterpolant(),
                t = s,
                n = c - s;
              e.evaluate(a), (p = So.arraySlice(e.resultBuffer, t, n));
            }
            "quaternion" === r &&
              new G().fromArray(p).normalize().conjugate().toArray(p);
            const d = o.times.length;
            for (let e = 0; e < d; ++e) {
              const t = e * h + l;
              if ("quaternion" === r)
                G.multiplyQuaternionsFlat(o.values, t, p, 0, o.values, t);
              else {
                const e = h - 2 * l;
                for (let n = 0; n < e; ++n) o.values[t + n] -= p[n];
              }
            }
          }
          return (e.blendMode = 2501), e;
        },
      };
      function To(e, t, n, i) {
        (this.parameterPositions = e),
          (this._cachedIndex = 0),
          (this.resultBuffer = void 0 !== i ? i : new t.constructor(n)),
          (this.sampleValues = t),
          (this.valueSize = n);
      }
      function Eo(e, t, n, i) {
        To.call(this, e, t, n, i),
          (this._weightPrev = -0),
          (this._offsetPrev = -0),
          (this._weightNext = -0),
          (this._offsetNext = -0);
      }
      function Ao(e, t, n, i) {
        To.call(this, e, t, n, i);
      }
      function Lo(e, t, n, i) {
        To.call(this, e, t, n, i);
      }
      function Po(e, t, n, i) {
        if (void 0 === e)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length)
          throw new Error(
            "THREE.KeyframeTrack: no keyframes in track named " + e
          );
        (this.name = e),
          (this.times = So.convertArray(t, this.TimeBufferType)),
          (this.values = So.convertArray(n, this.ValueBufferType)),
          this.setInterpolation(i || this.DefaultInterpolation);
      }
      function Ro(e, t, n) {
        Po.call(this, e, t, n);
      }
      function ko(e, t, n, i) {
        Po.call(this, e, t, n, i);
      }
      function Co(e, t, n, i) {
        Po.call(this, e, t, n, i);
      }
      function Oo(e, t, n, i) {
        To.call(this, e, t, n, i);
      }
      function No(e, t, n, i) {
        Po.call(this, e, t, n, i);
      }
      function Io(e, t, n, i) {
        Po.call(this, e, t, n, i);
      }
      function Do(e, t, n, i) {
        Po.call(this, e, t, n, i);
      }
      function jo(e, t = -1, n, i = 2500) {
        (this.name = e),
          (this.tracks = n),
          (this.duration = t),
          (this.blendMode = i),
          (this.uuid = O.generateUUID()),
          this.duration < 0 && this.resetDuration();
      }
      function Fo(e) {
        if (void 0 === e.type)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        const t = (function (e) {
          switch (e.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return Co;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return Do;
            case "color":
              return ko;
            case "quaternion":
              return No;
            case "bool":
            case "boolean":
              return Ro;
            case "string":
              return Io;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
        })(e.type);
        if (void 0 === e.times) {
          const t = [],
            n = [];
          So.flattenJSON(e.keys, t, n, "value"), (e.times = t), (e.values = n);
        }
        return void 0 !== t.parse
          ? t.parse(e)
          : new t(e.name, e.times, e.values, e.interpolation);
      }
      Object.assign(To.prototype, {
        evaluate: function (e) {
          const t = this.parameterPositions;
          let n = this._cachedIndex,
            i = t[n],
            r = t[n - 1];
          e: {
            t: {
              let a;
              n: {
                i: if (!(e < i)) {
                  for (let a = n + 2; ; ) {
                    if (void 0 === i) {
                      if (e < r) break i;
                      return (
                        (n = t.length),
                        (this._cachedIndex = n),
                        this.afterEnd_(n - 1, e, r)
                      );
                    }
                    if (n === a) break;
                    if (((r = i), (i = t[++n]), e < i)) break t;
                  }
                  a = t.length;
                  break n;
                }
                if (e >= r) break e;
                {
                  const o = t[1];
                  e < o && ((n = 2), (r = o));
                  for (let a = n - 2; ; ) {
                    if (void 0 === r)
                      return (
                        (this._cachedIndex = 0), this.beforeStart_(0, e, i)
                      );
                    if (n === a) break;
                    if (((i = r), (r = t[--n - 1]), e >= r)) break t;
                  }
                  (a = n), (n = 0);
                }
              }
              for (; n < a; ) {
                const i = (n + a) >>> 1;
                e < t[i] ? (a = i) : (n = i + 1);
              }
              if (((i = t[n]), (r = t[n - 1]), void 0 === r))
                return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
              if (void 0 === i)
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, r, e)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, r, i);
          }
          return this.interpolate_(n, r, e, i);
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function () {
          return this.settings || this.DefaultSettings_;
        },
        copySampleValue_: function (e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i;
          for (let e = 0; e !== i; ++e) t[e] = n[r + e];
          return t;
        },
        interpolate_: function () {
          throw new Error("call to abstract method");
        },
        intervalChanged_: function () {},
      }),
        Object.assign(To.prototype, {
          beforeStart_: To.prototype.copySampleValue_,
          afterEnd_: To.prototype.copySampleValue_,
        }),
        (Eo.prototype = Object.assign(Object.create(To.prototype), {
          constructor: Eo,
          DefaultSettings_: { endingStart: x, endingEnd: x },
          intervalChanged_: function (e, t, n) {
            const i = this.parameterPositions;
            let r = e - 2,
              a = e + 1,
              o = i[r],
              s = i[a];
            if (void 0 === o)
              switch (this.getSettings_().endingStart) {
                case b:
                  (r = e), (o = 2 * t - n);
                  break;
                case M:
                  (r = i.length - 2), (o = t + i[r] - i[r + 1]);
                  break;
                default:
                  (r = e), (o = n);
              }
            if (void 0 === s)
              switch (this.getSettings_().endingEnd) {
                case b:
                  (a = e), (s = 2 * n - t);
                  break;
                case M:
                  (a = 1), (s = n + i[1] - i[0]);
                  break;
                default:
                  (a = e - 1), (s = t);
              }
            const c = 0.5 * (n - t),
              l = this.valueSize;
            (this._weightPrev = c / (t - o)),
              (this._weightNext = c / (s - n)),
              (this._offsetPrev = r * l),
              (this._offsetNext = a * l);
          },
          interpolate_: function (e, t, n, i) {
            const r = this.resultBuffer,
              a = this.sampleValues,
              o = this.valueSize,
              s = e * o,
              c = s - o,
              l = this._offsetPrev,
              h = this._offsetNext,
              u = this._weightPrev,
              p = this._weightNext,
              d = (n - t) / (i - t),
              f = d * d,
              m = f * d,
              g = -u * m + 2 * u * f - u * d,
              v = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * d + 1,
              y = (-1 - p) * m + (1.5 + p) * f + 0.5 * d,
              _ = p * m - p * f;
            for (let e = 0; e !== o; ++e)
              r[e] = g * a[l + e] + v * a[c + e] + y * a[s + e] + _ * a[h + e];
            return r;
          },
        })),
        (Ao.prototype = Object.assign(Object.create(To.prototype), {
          constructor: Ao,
          interpolate_: function (e, t, n, i) {
            const r = this.resultBuffer,
              a = this.sampleValues,
              o = this.valueSize,
              s = e * o,
              c = s - o,
              l = (n - t) / (i - t),
              h = 1 - l;
            for (let e = 0; e !== o; ++e) r[e] = a[c + e] * h + a[s + e] * l;
            return r;
          },
        })),
        (Lo.prototype = Object.assign(Object.create(To.prototype), {
          constructor: Lo,
          interpolate_: function (e) {
            return this.copySampleValue_(e - 1);
          },
        })),
        Object.assign(Po, {
          toJSON: function (e) {
            const t = e.constructor;
            let n;
            if (void 0 !== t.toJSON) n = t.toJSON(e);
            else {
              n = {
                name: e.name,
                times: So.convertArray(e.times, Array),
                values: So.convertArray(e.values, Array),
              };
              const t = e.getInterpolation();
              t !== e.DefaultInterpolation && (n.interpolation = t);
            }
            return (n.type = e.ValueTypeName), n;
          },
        }),
        Object.assign(Po.prototype, {
          constructor: Po,
          TimeBufferType: Float32Array,
          ValueBufferType: Float32Array,
          DefaultInterpolation: _,
          InterpolantFactoryMethodDiscrete: function (e) {
            return new Lo(this.times, this.values, this.getValueSize(), e);
          },
          InterpolantFactoryMethodLinear: function (e) {
            return new Ao(this.times, this.values, this.getValueSize(), e);
          },
          InterpolantFactoryMethodSmooth: function (e) {
            return new Eo(this.times, this.values, this.getValueSize(), e);
          },
          setInterpolation: function (e) {
            let t;
            switch (e) {
              case y:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
              case _:
                t = this.InterpolantFactoryMethodLinear;
                break;
              case w:
                t = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === t) {
              const t =
                "unsupported interpolation for " +
                this.ValueTypeName +
                " keyframe track named " +
                this.name;
              if (void 0 === this.createInterpolant) {
                if (e === this.DefaultInterpolation) throw new Error(t);
                this.setInterpolation(this.DefaultInterpolation);
              }
              return console.warn("THREE.KeyframeTrack:", t), this;
            }
            return (this.createInterpolant = t), this;
          },
          getInterpolation: function () {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return y;
              case this.InterpolantFactoryMethodLinear:
                return _;
              case this.InterpolantFactoryMethodSmooth:
                return w;
            }
          },
          getValueSize: function () {
            return this.values.length / this.times.length;
          },
          shift: function (e) {
            if (0 !== e) {
              const t = this.times;
              for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
            }
            return this;
          },
          scale: function (e) {
            if (1 !== e) {
              const t = this.times;
              for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
            }
            return this;
          },
          trim: function (e, t) {
            const n = this.times,
              i = n.length;
            let r = 0,
              a = i - 1;
            for (; r !== i && n[r] < e; ) ++r;
            for (; -1 !== a && n[a] > t; ) --a;
            if ((++a, 0 !== r || a !== i)) {
              r >= a && ((a = Math.max(a, 1)), (r = a - 1));
              const e = this.getValueSize();
              (this.times = So.arraySlice(n, r, a)),
                (this.values = So.arraySlice(this.values, r * e, a * e));
            }
            return this;
          },
          validate: function () {
            let e = !0;
            const t = this.getValueSize();
            t - Math.floor(t) != 0 &&
              (console.error(
                "THREE.KeyframeTrack: Invalid value size in track.",
                this
              ),
              (e = !1));
            const n = this.times,
              i = this.values,
              r = n.length;
            0 === r &&
              (console.error("THREE.KeyframeTrack: Track is empty.", this),
              (e = !1));
            let a = null;
            for (let t = 0; t !== r; t++) {
              const i = n[t];
              if ("number" == typeof i && isNaN(i)) {
                console.error(
                  "THREE.KeyframeTrack: Time is not a valid number.",
                  this,
                  t,
                  i
                ),
                  (e = !1);
                break;
              }
              if (null !== a && a > i) {
                console.error(
                  "THREE.KeyframeTrack: Out of order keys.",
                  this,
                  t,
                  i,
                  a
                ),
                  (e = !1);
                break;
              }
              a = i;
            }
            if (void 0 !== i && So.isTypedArray(i))
              for (let t = 0, n = i.length; t !== n; ++t) {
                const n = i[t];
                if (isNaN(n)) {
                  console.error(
                    "THREE.KeyframeTrack: Value is not a valid number.",
                    this,
                    t,
                    n
                  ),
                    (e = !1);
                  break;
                }
              }
            return e;
          },
          optimize: function () {
            const e = So.arraySlice(this.times),
              t = So.arraySlice(this.values),
              n = this.getValueSize(),
              i = this.getInterpolation() === w,
              r = e.length - 1;
            let a = 1;
            for (let o = 1; o < r; ++o) {
              let r = !1;
              const s = e[o];
              if (s !== e[o + 1] && (1 !== o || s !== e[0]))
                if (i) r = !0;
                else {
                  const e = o * n,
                    i = e - n,
                    a = e + n;
                  for (let o = 0; o !== n; ++o) {
                    const n = t[e + o];
                    if (n !== t[i + o] || n !== t[a + o]) {
                      r = !0;
                      break;
                    }
                  }
                }
              if (r) {
                if (o !== a) {
                  e[a] = e[o];
                  const i = o * n,
                    r = a * n;
                  for (let e = 0; e !== n; ++e) t[r + e] = t[i + e];
                }
                ++a;
              }
            }
            if (r > 0) {
              e[a] = e[r];
              for (let e = r * n, i = a * n, o = 0; o !== n; ++o)
                t[i + o] = t[e + o];
              ++a;
            }
            return (
              a !== e.length
                ? ((this.times = So.arraySlice(e, 0, a)),
                  (this.values = So.arraySlice(t, 0, a * n)))
                : ((this.times = e), (this.values = t)),
              this
            );
          },
          clone: function () {
            const e = So.arraySlice(this.times, 0),
              t = So.arraySlice(this.values, 0),
              n = new (0, this.constructor)(this.name, e, t);
            return (n.createInterpolant = this.createInterpolant), n;
          },
        }),
        (Ro.prototype = Object.assign(Object.create(Po.prototype), {
          constructor: Ro,
          ValueTypeName: "bool",
          ValueBufferType: Array,
          DefaultInterpolation: y,
          InterpolantFactoryMethodLinear: void 0,
          InterpolantFactoryMethodSmooth: void 0,
        })),
        (ko.prototype = Object.assign(Object.create(Po.prototype), {
          constructor: ko,
          ValueTypeName: "color",
        })),
        (Co.prototype = Object.assign(Object.create(Po.prototype), {
          constructor: Co,
          ValueTypeName: "number",
        })),
        (Oo.prototype = Object.assign(Object.create(To.prototype), {
          constructor: Oo,
          interpolate_: function (e, t, n, i) {
            const r = this.resultBuffer,
              a = this.sampleValues,
              o = this.valueSize,
              s = (n - t) / (i - t);
            let c = e * o;
            for (let e = c + o; c !== e; c += 4)
              G.slerpFlat(r, 0, a, c - o, a, c, s);
            return r;
          },
        })),
        (No.prototype = Object.assign(Object.create(Po.prototype), {
          constructor: No,
          ValueTypeName: "quaternion",
          DefaultInterpolation: _,
          InterpolantFactoryMethodLinear: function (e) {
            return new Oo(this.times, this.values, this.getValueSize(), e);
          },
          InterpolantFactoryMethodSmooth: void 0,
        })),
        (Io.prototype = Object.assign(Object.create(Po.prototype), {
          constructor: Io,
          ValueTypeName: "string",
          ValueBufferType: Array,
          DefaultInterpolation: y,
          InterpolantFactoryMethodLinear: void 0,
          InterpolantFactoryMethodSmooth: void 0,
        })),
        (Do.prototype = Object.assign(Object.create(Po.prototype), {
          constructor: Do,
          ValueTypeName: "vector",
        })),
        Object.assign(jo, {
          parse: function (e) {
            const t = [],
              n = e.tracks,
              i = 1 / (e.fps || 1);
            for (let e = 0, r = n.length; e !== r; ++e)
              t.push(Fo(n[e]).scale(i));
            const r = new jo(e.name, e.duration, t, e.blendMode);
            return (r.uuid = e.uuid), r;
          },
          toJSON: function (e) {
            const t = [],
              n = e.tracks,
              i = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode,
              };
            for (let e = 0, i = n.length; e !== i; ++e) t.push(Po.toJSON(n[e]));
            return i;
          },
          CreateFromMorphTargetSequence: function (e, t, n, i) {
            const r = t.length,
              a = [];
            for (let e = 0; e < r; e++) {
              let o = [],
                s = [];
              o.push((e + r - 1) % r, e, (e + 1) % r), s.push(0, 1, 0);
              const c = So.getKeyframeOrder(o);
              (o = So.sortedArray(o, 1, c)),
                (s = So.sortedArray(s, 1, c)),
                i || 0 !== o[0] || (o.push(r), s.push(s[0])),
                a.push(
                  new Co(
                    ".morphTargetInfluences[" + t[e].name + "]",
                    o,
                    s
                  ).scale(1 / n)
                );
            }
            return new jo(e, -1, a);
          },
          findByName: function (e, t) {
            let n = e;
            if (!Array.isArray(e)) {
              const t = e;
              n = (t.geometry && t.geometry.animations) || t.animations;
            }
            for (let e = 0; e < n.length; e++) if (n[e].name === t) return n[e];
            return null;
          },
          CreateClipsFromMorphTargetSequences: function (e, t, n) {
            const i = {},
              r = /^([\w-]*?)([\d]+)$/;
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t],
                a = n.name.match(r);
              if (a && a.length > 1) {
                const e = a[1];
                let t = i[e];
                t || (i[e] = t = []), t.push(n);
              }
            }
            const a = [];
            for (const e in i)
              a.push(jo.CreateFromMorphTargetSequence(e, i[e], t, n));
            return a;
          },
          parseAnimation: function (e, t) {
            if (!e)
              return (
                console.error(
                  "THREE.AnimationClip: No animation in JSONLoader data."
                ),
                null
              );
            const n = function (e, t, n, i, r) {
                if (0 !== n.length) {
                  const a = [],
                    o = [];
                  So.flattenJSON(n, a, o, i),
                    0 !== a.length && r.push(new e(t, a, o));
                }
              },
              i = [],
              r = e.name || "default",
              a = e.fps || 30,
              o = e.blendMode;
            let s = e.length || -1;
            const c = e.hierarchy || [];
            for (let e = 0; e < c.length; e++) {
              const r = c[e].keys;
              if (r && 0 !== r.length)
                if (r[0].morphTargets) {
                  const e = {};
                  let t;
                  for (t = 0; t < r.length; t++)
                    if (r[t].morphTargets)
                      for (let n = 0; n < r[t].morphTargets.length; n++)
                        e[r[t].morphTargets[n]] = -1;
                  for (const n in e) {
                    const e = [],
                      a = [];
                    for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                      const i = r[t];
                      e.push(i.time), a.push(i.morphTarget === n ? 1 : 0);
                    }
                    i.push(new Co(".morphTargetInfluence[" + n + "]", e, a));
                  }
                  s = e.length * (a || 1);
                } else {
                  const a = ".bones[" + t[e].name + "]";
                  n(Do, a + ".position", r, "pos", i),
                    n(No, a + ".quaternion", r, "rot", i),
                    n(Do, a + ".scale", r, "scl", i);
                }
            }
            return 0 === i.length ? null : new jo(r, s, i, o);
          },
        }),
        Object.assign(jo.prototype, {
          resetDuration: function () {
            let e = 0;
            for (let t = 0, n = this.tracks.length; t !== n; ++t) {
              const n = this.tracks[t];
              e = Math.max(e, n.times[n.times.length - 1]);
            }
            return (this.duration = e), this;
          },
          trim: function () {
            for (let e = 0; e < this.tracks.length; e++)
              this.tracks[e].trim(0, this.duration);
            return this;
          },
          validate: function () {
            let e = !0;
            for (let t = 0; t < this.tracks.length; t++)
              e = e && this.tracks[t].validate();
            return e;
          },
          optimize: function () {
            for (let e = 0; e < this.tracks.length; e++)
              this.tracks[e].optimize();
            return this;
          },
          clone: function () {
            const e = [];
            for (let t = 0; t < this.tracks.length; t++)
              e.push(this.tracks[t].clone());
            return new jo(this.name, this.duration, e, this.blendMode);
          },
          toJSON: function () {
            return jo.toJSON(this);
          },
        });
      const Ho = {
        enabled: !1,
        files: {},
        add: function (e, t) {
          !1 !== this.enabled && (this.files[e] = t);
        },
        get: function (e) {
          if (!1 !== this.enabled) return this.files[e];
        },
        remove: function (e) {
          delete this.files[e];
        },
        clear: function () {
          this.files = {};
        },
      };
      const Bo = new (function (e, t, n) {
        const i = this;
        let r,
          a = !1,
          o = 0,
          s = 0;
        const c = [];
        (this.onStart = void 0),
          (this.onLoad = e),
          (this.onProgress = t),
          (this.onError = n),
          (this.itemStart = function (e) {
            s++,
              !1 === a && void 0 !== i.onStart && i.onStart(e, o, s),
              (a = !0);
          }),
          (this.itemEnd = function (e) {
            o++,
              void 0 !== i.onProgress && i.onProgress(e, o, s),
              o === s && ((a = !1), void 0 !== i.onLoad && i.onLoad());
          }),
          (this.itemError = function (e) {
            void 0 !== i.onError && i.onError(e);
          }),
          (this.resolveURL = function (e) {
            return r ? r(e) : e;
          }),
          (this.setURLModifier = function (e) {
            return (r = e), this;
          }),
          (this.addHandler = function (e, t) {
            return c.push(e, t), this;
          }),
          (this.removeHandler = function (e) {
            const t = c.indexOf(e);
            return -1 !== t && c.splice(t, 2), this;
          }),
          (this.getHandler = function (e) {
            for (let t = 0, n = c.length; t < n; t += 2) {
              const n = c[t],
                i = c[t + 1];
              if ((n.global && (n.lastIndex = 0), n.test(e))) return i;
            }
            return null;
          });
      })();
      function zo(e) {
        (this.manager = void 0 !== e ? e : Bo),
          (this.crossOrigin = "anonymous"),
          (this.withCredentials = !1),
          (this.path = ""),
          (this.resourcePath = ""),
          (this.requestHeader = {});
      }
      Object.assign(zo.prototype, {
        load: function () {},
        loadAsync: function (e, t) {
          const n = this;
          return new Promise(function (i, r) {
            n.load(e, i, t, r);
          });
        },
        parse: function () {},
        setCrossOrigin: function (e) {
          return (this.crossOrigin = e), this;
        },
        setWithCredentials: function (e) {
          return (this.withCredentials = e), this;
        },
        setPath: function (e) {
          return (this.path = e), this;
        },
        setResourcePath: function (e) {
          return (this.resourcePath = e), this;
        },
        setRequestHeader: function (e) {
          return (this.requestHeader = e), this;
        },
      });
      const Uo = {};
      function Go(e) {
        zo.call(this, e);
      }
      function Wo(e) {
        zo.call(this, e);
      }
      function Vo(e) {
        zo.call(this, e);
      }
      function qo(e) {
        zo.call(this, e);
      }
      function Xo(e) {
        zo.call(this, e);
      }
      function Yo(e) {
        zo.call(this, e);
      }
      function Jo(e) {
        zo.call(this, e);
      }
      function Zo() {
        (this.type = "Curve"), (this.arcLengthDivisions = 200);
      }
      function Qo(e, t, n, i, r, a, o, s) {
        Zo.call(this),
          (this.type = "EllipseCurve"),
          (this.aX = e || 0),
          (this.aY = t || 0),
          (this.xRadius = n || 1),
          (this.yRadius = i || 1),
          (this.aStartAngle = r || 0),
          (this.aEndAngle = a || 2 * Math.PI),
          (this.aClockwise = o || !1),
          (this.aRotation = s || 0);
      }
      function Ko(e, t, n, i, r, a) {
        Qo.call(this, e, t, n, n, i, r, a), (this.type = "ArcCurve");
      }
      function $o() {
        let e = 0,
          t = 0,
          n = 0,
          i = 0;
        function r(r, a, o, s) {
          (e = r),
            (t = o),
            (n = -3 * r + 3 * a - 2 * o - s),
            (i = 2 * r - 2 * a + o + s);
        }
        return {
          initCatmullRom: function (e, t, n, i, a) {
            r(t, n, a * (n - e), a * (i - t));
          },
          initNonuniformCatmullRom: function (e, t, n, i, a, o, s) {
            let c = (t - e) / a - (n - e) / (a + o) + (n - t) / o,
              l = (n - t) / o - (i - t) / (o + s) + (i - n) / s;
            (c *= o), (l *= o), r(t, n, c, l);
          },
          calc: function (r) {
            const a = r * r;
            return e + t * r + n * a + i * (a * r);
          },
        };
      }
      (Go.prototype = Object.assign(Object.create(zo.prototype), {
        constructor: Go,
        load: function (e, t, n, i) {
          void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            a = Ho.get(e);
          if (void 0 !== a)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(a), r.manager.itemEnd(e);
              }, 0),
              a
            );
          if (void 0 !== Uo[e])
            return void Uo[e].push({ onLoad: t, onProgress: n, onError: i });
          const o = e.match(/^data:(.*?)(;base64)?,(.*)$/);
          let s;
          if (o) {
            const n = o[1],
              a = !!o[2];
            let s = o[3];
            (s = decodeURIComponent(s)), a && (s = atob(s));
            try {
              let i;
              const a = (this.responseType || "").toLowerCase();
              switch (a) {
                case "arraybuffer":
                case "blob":
                  const e = new Uint8Array(s.length);
                  for (let t = 0; t < s.length; t++) e[t] = s.charCodeAt(t);
                  i =
                    "blob" === a ? new Blob([e.buffer], { type: n }) : e.buffer;
                  break;
                case "document":
                  const t = new DOMParser();
                  i = t.parseFromString(s, n);
                  break;
                case "json":
                  i = JSON.parse(s);
                  break;
                default:
                  i = s;
              }
              setTimeout(function () {
                t && t(i), r.manager.itemEnd(e);
              }, 0);
            } catch (t) {
              setTimeout(function () {
                i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
              }, 0);
            }
          } else {
            (Uo[e] = []),
              Uo[e].push({ onLoad: t, onProgress: n, onError: i }),
              (s = new XMLHttpRequest()),
              s.open("GET", e, !0),
              s.addEventListener(
                "load",
                function (t) {
                  const n = this.response,
                    i = Uo[e];
                  if (
                    (delete Uo[e], 200 === this.status || 0 === this.status)
                  ) {
                    0 === this.status &&
                      console.warn("THREE.FileLoader: HTTP Status 0 received."),
                      Ho.add(e, n);
                    for (let e = 0, t = i.length; e < t; e++) {
                      const t = i[e];
                      t.onLoad && t.onLoad(n);
                    }
                    r.manager.itemEnd(e);
                  } else {
                    for (let e = 0, n = i.length; e < n; e++) {
                      const n = i[e];
                      n.onError && n.onError(t);
                    }
                    r.manager.itemError(e), r.manager.itemEnd(e);
                  }
                },
                !1
              ),
              s.addEventListener(
                "progress",
                function (t) {
                  const n = Uo[e];
                  for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    i.onProgress && i.onProgress(t);
                  }
                },
                !1
              ),
              s.addEventListener(
                "error",
                function (t) {
                  const n = Uo[e];
                  delete Uo[e];
                  for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    i.onError && i.onError(t);
                  }
                  r.manager.itemError(e), r.manager.itemEnd(e);
                },
                !1
              ),
              s.addEventListener(
                "abort",
                function (t) {
                  const n = Uo[e];
                  delete Uo[e];
                  for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    i.onError && i.onError(t);
                  }
                  r.manager.itemError(e), r.manager.itemEnd(e);
                },
                !1
              ),
              void 0 !== this.responseType &&
                (s.responseType = this.responseType),
              void 0 !== this.withCredentials &&
                (s.withCredentials = this.withCredentials),
              s.overrideMimeType &&
                s.overrideMimeType(
                  void 0 !== this.mimeType ? this.mimeType : "text/plain"
                );
            for (const e in this.requestHeader)
              s.setRequestHeader(e, this.requestHeader[e]);
            s.send(null);
          }
          return r.manager.itemStart(e), s;
        },
        setResponseType: function (e) {
          return (this.responseType = e), this;
        },
        setMimeType: function (e) {
          return (this.mimeType = e), this;
        },
      })),
        (Wo.prototype = Object.assign(Object.create(zo.prototype), {
          constructor: Wo,
          load: function (e, t, n, i) {
            const r = this,
              a = new Go(r.manager);
            a.setPath(r.path),
              a.setRequestHeader(r.requestHeader),
              a.setWithCredentials(r.withCredentials),
              a.load(
                e,
                function (n) {
                  try {
                    t(r.parse(JSON.parse(n)));
                  } catch (t) {
                    i ? i(t) : console.error(t), r.manager.itemError(e);
                  }
                },
                n,
                i
              );
          },
          parse: function (e) {
            const t = [];
            for (let n = 0; n < e.length; n++) {
              const i = jo.parse(e[n]);
              t.push(i);
            }
            return t;
          },
        })),
        (Vo.prototype = Object.assign(Object.create(zo.prototype), {
          constructor: Vo,
          load: function (e, t, n, i) {
            const r = this,
              a = [],
              o = new Ca(),
              c = new Go(this.manager);
            c.setPath(this.path),
              c.setResponseType("arraybuffer"),
              c.setRequestHeader(this.requestHeader),
              c.setWithCredentials(r.withCredentials);
            let l = 0;
            function h(h) {
              c.load(
                e[h],
                function (e) {
                  const n = r.parse(e, !0);
                  (a[h] = {
                    width: n.width,
                    height: n.height,
                    format: n.format,
                    mipmaps: n.mipmaps,
                  }),
                    (l += 1),
                    6 === l &&
                      (1 === n.mipmapCount && (o.minFilter = s),
                      (o.image = a),
                      (o.format = n.format),
                      (o.needsUpdate = !0),
                      t && t(o));
                },
                n,
                i
              );
            }
            if (Array.isArray(e))
              for (let t = 0, n = e.length; t < n; ++t) h(t);
            else
              c.load(
                e,
                function (e) {
                  const n = r.parse(e, !0);
                  if (n.isCubemap) {
                    const e = n.mipmaps.length / n.mipmapCount;
                    for (let t = 0; t < e; t++) {
                      a[t] = { mipmaps: [] };
                      for (let e = 0; e < n.mipmapCount; e++)
                        a[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]),
                          (a[t].format = n.format),
                          (a[t].width = n.width),
                          (a[t].height = n.height);
                    }
                    o.image = a;
                  } else
                    (o.image.width = n.width),
                      (o.image.height = n.height),
                      (o.mipmaps = n.mipmaps);
                  1 === n.mipmapCount && (o.minFilter = s),
                    (o.format = n.format),
                    (o.needsUpdate = !0),
                    t && t(o);
                },
                n,
                i
              );
            return o;
          },
        })),
        (qo.prototype = Object.assign(Object.create(zo.prototype), {
          constructor: qo,
          load: function (e, t, n, i) {
            void 0 !== this.path && (e = this.path + e),
              (e = this.manager.resolveURL(e));
            const r = this,
              a = Ho.get(e);
            if (void 0 !== a)
              return (
                r.manager.itemStart(e),
                setTimeout(function () {
                  t && t(a), r.manager.itemEnd(e);
                }, 0),
                a
              );
            const o = document.createElementNS(
              "http://www.w3.org/1999/xhtml",
              "img"
            );
            function s() {
              o.removeEventListener("load", s, !1),
                o.removeEventListener("error", c, !1),
                Ho.add(e, this),
                t && t(this),
                r.manager.itemEnd(e);
            }
            function c(t) {
              o.removeEventListener("load", s, !1),
                o.removeEventListener("error", c, !1),
                i && i(t),
                r.manager.itemError(e),
                r.manager.itemEnd(e);
            }
            return (
              o.addEventListener("load", s, !1),
              o.addEventListener("error", c, !1),
              "data:" !== e.substr(0, 5) &&
                void 0 !== this.crossOrigin &&
                (o.crossOrigin = this.crossOrigin),
              r.manager.itemStart(e),
              (o.src = e),
              o
            );
          },
        })),
        (Xo.prototype = Object.assign(Object.create(zo.prototype), {
          constructor: Xo,
          load: function (e, t, n, i) {
            const r = new mn(),
              a = new qo(this.manager);
            a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
            let o = 0;
            function s(n) {
              a.load(
                e[n],
                function (e) {
                  (r.images[n] = e),
                    o++,
                    6 === o && ((r.needsUpdate = !0), t && t(r));
                },
                void 0,
                i
              );
            }
            for (let t = 0; t < e.length; ++t) s(t);
            return r;
          },
        })),
        (Yo.prototype = Object.assign(Object.create(zo.prototype), {
          constructor: Yo,
          load: function (e, t, i, r) {
            const a = this,
              o = new vn(),
              l = new Go(this.manager);
            return (
              l.setResponseType("arraybuffer"),
              l.setRequestHeader(this.requestHeader),
              l.setPath(this.path),
              l.setWithCredentials(a.withCredentials),
              l.load(
                e,
                function (e) {
                  const i = a.parse(e);
                  i &&
                    (void 0 !== i.image
                      ? (o.image = i.image)
                      : void 0 !== i.data &&
                        ((o.image.width = i.width),
                        (o.image.height = i.height),
                        (o.image.data = i.data)),
                    (o.wrapS = void 0 !== i.wrapS ? i.wrapS : n),
                    (o.wrapT = void 0 !== i.wrapT ? i.wrapT : n),
                    (o.magFilter = void 0 !== i.magFilter ? i.magFilter : s),
                    (o.minFilter = void 0 !== i.minFilter ? i.minFilter : s),
                    (o.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1),
                    void 0 !== i.encoding && (o.encoding = i.encoding),
                    void 0 !== i.flipY && (o.flipY = i.flipY),
                    void 0 !== i.format && (o.format = i.format),
                    void 0 !== i.type && (o.type = i.type),
                    void 0 !== i.mipmaps &&
                      ((o.mipmaps = i.mipmaps), (o.minFilter = c)),
                    1 === i.mipmapCount && (o.minFilter = s),
                    (o.needsUpdate = !0),
                    t && t(o, i));
                },
                i,
                r
              ),
              o
            );
          },
        })),
        (Jo.prototype = Object.assign(Object.create(zo.prototype), {
          constructor: Jo,
          load: function (e, t, n, i) {
            const r = new H(),
              a = new qo(this.manager);
            return (
              a.setCrossOrigin(this.crossOrigin),
              a.setPath(this.path),
              a.load(
                e,
                function (n) {
                  r.image = n;
                  const i =
                    e.search(/\.jpe?g($|\?)/i) > 0 ||
                    0 === e.search(/^data\:image\/jpeg/);
                  (r.format = i ? f : m),
                    (r.needsUpdate = !0),
                    void 0 !== t && t(r);
                },
                n,
                i
              ),
              r
            );
          },
        })),
        Object.assign(Zo.prototype, {
          getPoint: function () {
            return (
              console.warn("THREE.Curve: .getPoint() not implemented."), null
            );
          },
          getPointAt: function (e, t) {
            const n = this.getUtoTmapping(e);
            return this.getPoint(n, t);
          },
          getPoints: function (e = 5) {
            const t = [];
            for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return t;
          },
          getSpacedPoints: function (e = 5) {
            const t = [];
            for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
            return t;
          },
          getLength: function () {
            const e = this.getLengths();
            return e[e.length - 1];
          },
          getLengths: function (e) {
            if (
              (void 0 === e && (e = this.arcLengthDivisions),
              this.cacheArcLengths &&
                this.cacheArcLengths.length === e + 1 &&
                !this.needsUpdate)
            )
              return this.cacheArcLengths;
            this.needsUpdate = !1;
            const t = [];
            let n,
              i = this.getPoint(0),
              r = 0;
            t.push(0);
            for (let a = 1; a <= e; a++)
              (n = this.getPoint(a / e)),
                (r += n.distanceTo(i)),
                t.push(r),
                (i = n);
            return (this.cacheArcLengths = t), t;
          },
          updateArcLengths: function () {
            (this.needsUpdate = !0), this.getLengths();
          },
          getUtoTmapping: function (e, t) {
            const n = this.getLengths();
            let i = 0;
            const r = n.length;
            let a;
            a = t || e * n[r - 1];
            let o,
              s = 0,
              c = r - 1;
            for (; s <= c; )
              if (((i = Math.floor(s + (c - s) / 2)), (o = n[i] - a), o < 0))
                s = i + 1;
              else {
                if (!(o > 0)) {
                  c = i;
                  break;
                }
                c = i - 1;
              }
            if (((i = c), n[i] === a)) return i / (r - 1);
            const l = n[i];
            return (i + (a - l) / (n[i + 1] - l)) / (r - 1);
          },
          getTangent: function (e, t) {
            const n = 1e-4;
            let i = e - n,
              r = e + n;
            i < 0 && (i = 0), r > 1 && (r = 1);
            const a = this.getPoint(i),
              o = this.getPoint(r),
              s = t || (a.isVector2 ? new N() : new W());
            return s.copy(o).sub(a).normalize(), s;
          },
          getTangentAt: function (e, t) {
            const n = this.getUtoTmapping(e);
            return this.getTangent(n, t);
          },
          computeFrenetFrames: function (e, t) {
            const n = new W(),
              i = [],
              r = [],
              a = [],
              o = new W(),
              s = new ye();
            for (let t = 0; t <= e; t++) {
              const n = t / e;
              (i[t] = this.getTangentAt(n, new W())), i[t].normalize();
            }
            (r[0] = new W()), (a[0] = new W());
            let c = Number.MAX_VALUE;
            const l = Math.abs(i[0].x),
              h = Math.abs(i[0].y),
              u = Math.abs(i[0].z);
            l <= c && ((c = l), n.set(1, 0, 0)),
              h <= c && ((c = h), n.set(0, 1, 0)),
              u <= c && n.set(0, 0, 1),
              o.crossVectors(i[0], n).normalize(),
              r[0].crossVectors(i[0], o),
              a[0].crossVectors(i[0], r[0]);
            for (let t = 1; t <= e; t++) {
              if (
                ((r[t] = r[t - 1].clone()),
                (a[t] = a[t - 1].clone()),
                o.crossVectors(i[t - 1], i[t]),
                o.length() > Number.EPSILON)
              ) {
                o.normalize();
                const e = Math.acos(O.clamp(i[t - 1].dot(i[t]), -1, 1));
                r[t].applyMatrix4(s.makeRotationAxis(o, e));
              }
              a[t].crossVectors(i[t], r[t]);
            }
            if (!0 === t) {
              let t = Math.acos(O.clamp(r[0].dot(r[e]), -1, 1));
              (t /= e), i[0].dot(o.crossVectors(r[0], r[e])) > 0 && (t = -t);
              for (let n = 1; n <= e; n++)
                r[n].applyMatrix4(s.makeRotationAxis(i[n], t * n)),
                  a[n].crossVectors(i[n], r[n]);
            }
            return { tangents: i, normals: r, binormals: a };
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (e) {
            return (this.arcLengthDivisions = e.arcLengthDivisions), this;
          },
          toJSON: function () {
            const e = {
              metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON",
              },
            };
            return (
              (e.arcLengthDivisions = this.arcLengthDivisions),
              (e.type = this.type),
              e
            );
          },
          fromJSON: function (e) {
            return (this.arcLengthDivisions = e.arcLengthDivisions), this;
          },
        }),
        (Qo.prototype = Object.create(Zo.prototype)),
        (Qo.prototype.constructor = Qo),
        (Qo.prototype.isEllipseCurve = !0),
        (Qo.prototype.getPoint = function (e, t) {
          const n = t || new N(),
            i = 2 * Math.PI;
          let r = this.aEndAngle - this.aStartAngle;
          const a = Math.abs(r) < Number.EPSILON;
          for (; r < 0; ) r += i;
          for (; r > i; ) r -= i;
          r < Number.EPSILON && (r = a ? 0 : i),
            !0 !== this.aClockwise || a || (r === i ? (r = -i) : (r -= i));
          const o = this.aStartAngle + e * r;
          let s = this.aX + this.xRadius * Math.cos(o),
            c = this.aY + this.yRadius * Math.sin(o);
          if (0 !== this.aRotation) {
            const e = Math.cos(this.aRotation),
              t = Math.sin(this.aRotation),
              n = s - this.aX,
              i = c - this.aY;
            (s = n * e - i * t + this.aX), (c = n * t + i * e + this.aY);
          }
          return n.set(s, c);
        }),
        (Qo.prototype.copy = function (e) {
          return (
            Zo.prototype.copy.call(this, e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }),
        (Qo.prototype.toJSON = function () {
          const e = Zo.prototype.toJSON.call(this);
          return (
            (e.aX = this.aX),
            (e.aY = this.aY),
            (e.xRadius = this.xRadius),
            (e.yRadius = this.yRadius),
            (e.aStartAngle = this.aStartAngle),
            (e.aEndAngle = this.aEndAngle),
            (e.aClockwise = this.aClockwise),
            (e.aRotation = this.aRotation),
            e
          );
        }),
        (Qo.prototype.fromJSON = function (e) {
          return (
            Zo.prototype.fromJSON.call(this, e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }),
        (Ko.prototype = Object.create(Qo.prototype)),
        (Ko.prototype.constructor = Ko),
        (Ko.prototype.isArcCurve = !0);
      const es = new W(),
        ts = new $o(),
        ns = new $o(),
        is = new $o();
      function rs(e = [], t = !1, n = "centripetal", i = 0.5) {
        Zo.call(this),
          (this.type = "CatmullRomCurve3"),
          (this.points = e),
          (this.closed = t),
          (this.curveType = n),
          (this.tension = i);
      }
      function as(e, t, n, i, r) {
        const a = 0.5 * (i - t),
          o = 0.5 * (r - n),
          s = e * e;
        return (
          (2 * n - 2 * i + a + o) * (e * s) +
          (-3 * n + 3 * i - 2 * a - o) * s +
          a * e +
          n
        );
      }
      function os(e, t, n, i) {
        return (
          (function (e, t) {
            const n = 1 - e;
            return n * n * t;
          })(e, t) +
          (function (e, t) {
            return 2 * (1 - e) * e * t;
          })(e, n) +
          (function (e, t) {
            return e * e * t;
          })(e, i)
        );
      }
      function ss(e, t, n, i, r) {
        return (
          (function (e, t) {
            const n = 1 - e;
            return n * n * n * t;
          })(e, t) +
          (function (e, t) {
            const n = 1 - e;
            return 3 * n * n * e * t;
          })(e, n) +
          (function (e, t) {
            return 3 * (1 - e) * e * e * t;
          })(e, i) +
          (function (e, t) {
            return e * e * e * t;
          })(e, r)
        );
      }
      function cs(e = new N(), t = new N(), n = new N(), i = new N()) {
        Zo.call(this),
          (this.type = "CubicBezierCurve"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n),
          (this.v3 = i);
      }
      function ls(e = new W(), t = new W(), n = new W(), i = new W()) {
        Zo.call(this),
          (this.type = "CubicBezierCurve3"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n),
          (this.v3 = i);
      }
      function hs(e = new N(), t = new N()) {
        Zo.call(this), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
      }
      function us(e = new W(), t = new W()) {
        Zo.call(this), (this.type = "LineCurve3"), (this.v1 = e), (this.v2 = t);
      }
      function ps(e = new N(), t = new N(), n = new N()) {
        Zo.call(this),
          (this.type = "QuadraticBezierCurve"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n);
      }
      function ds(e = new W(), t = new W(), n = new W()) {
        Zo.call(this),
          (this.type = "QuadraticBezierCurve3"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n);
      }
      function fs(e = []) {
        Zo.call(this), (this.type = "SplineCurve"), (this.points = e);
      }
      (rs.prototype = Object.create(Zo.prototype)),
        (rs.prototype.constructor = rs),
        (rs.prototype.isCatmullRomCurve3 = !0),
        (rs.prototype.getPoint = function (e, t = new W()) {
          const n = t,
            i = this.points,
            r = i.length,
            a = (r - (this.closed ? 0 : 1)) * e;
          let o,
            s,
            c = Math.floor(a),
            l = a - c;
          this.closed
            ? (c += c > 0 ? 0 : (Math.floor(Math.abs(c) / r) + 1) * r)
            : 0 === l && c === r - 1 && ((c = r - 2), (l = 1)),
            this.closed || c > 0
              ? (o = i[(c - 1) % r])
              : (es.subVectors(i[0], i[1]).add(i[0]), (o = es));
          const h = i[c % r],
            u = i[(c + 1) % r];
          if (
            (this.closed || c + 2 < r
              ? (s = i[(c + 2) % r])
              : (es.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (s = es)),
            "centripetal" === this.curveType || "chordal" === this.curveType)
          ) {
            const e = "chordal" === this.curveType ? 0.5 : 0.25;
            let t = Math.pow(o.distanceToSquared(h), e),
              n = Math.pow(h.distanceToSquared(u), e),
              i = Math.pow(u.distanceToSquared(s), e);
            n < 1e-4 && (n = 1),
              t < 1e-4 && (t = n),
              i < 1e-4 && (i = n),
              ts.initNonuniformCatmullRom(o.x, h.x, u.x, s.x, t, n, i),
              ns.initNonuniformCatmullRom(o.y, h.y, u.y, s.y, t, n, i),
              is.initNonuniformCatmullRom(o.z, h.z, u.z, s.z, t, n, i);
          } else
            "catmullrom" === this.curveType &&
              (ts.initCatmullRom(o.x, h.x, u.x, s.x, this.tension),
              ns.initCatmullRom(o.y, h.y, u.y, s.y, this.tension),
              is.initCatmullRom(o.z, h.z, u.z, s.z, this.tension));
          return n.set(ts.calc(l), ns.calc(l), is.calc(l)), n;
        }),
        (rs.prototype.copy = function (e) {
          Zo.prototype.copy.call(this, e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const n = e.points[t];
            this.points.push(n.clone());
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }),
        (rs.prototype.toJSON = function () {
          const e = Zo.prototype.toJSON.call(this);
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const n = this.points[t];
            e.points.push(n.toArray());
          }
          return (
            (e.closed = this.closed),
            (e.curveType = this.curveType),
            (e.tension = this.tension),
            e
          );
        }),
        (rs.prototype.fromJSON = function (e) {
          Zo.prototype.fromJSON.call(this, e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const n = e.points[t];
            this.points.push(new W().fromArray(n));
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }),
        (cs.prototype = Object.create(Zo.prototype)),
        (cs.prototype.constructor = cs),
        (cs.prototype.isCubicBezierCurve = !0),
        (cs.prototype.getPoint = function (e, t = new N()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            a = this.v2,
            o = this.v3;
          return n.set(ss(e, i.x, r.x, a.x, o.x), ss(e, i.y, r.y, a.y, o.y)), n;
        }),
        (cs.prototype.copy = function (e) {
          return (
            Zo.prototype.copy.call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }),
        (cs.prototype.toJSON = function () {
          const e = Zo.prototype.toJSON.call(this);
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }),
        (cs.prototype.fromJSON = function (e) {
          return (
            Zo.prototype.fromJSON.call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }),
        (ls.prototype = Object.create(Zo.prototype)),
        (ls.prototype.constructor = ls),
        (ls.prototype.isCubicBezierCurve3 = !0),
        (ls.prototype.getPoint = function (e, t = new W()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            a = this.v2,
            o = this.v3;
          return (
            n.set(
              ss(e, i.x, r.x, a.x, o.x),
              ss(e, i.y, r.y, a.y, o.y),
              ss(e, i.z, r.z, a.z, o.z)
            ),
            n
          );
        }),
        (ls.prototype.copy = function (e) {
          return (
            Zo.prototype.copy.call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }),
        (ls.prototype.toJSON = function () {
          const e = Zo.prototype.toJSON.call(this);
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }),
        (ls.prototype.fromJSON = function (e) {
          return (
            Zo.prototype.fromJSON.call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }),
        (hs.prototype = Object.create(Zo.prototype)),
        (hs.prototype.constructor = hs),
        (hs.prototype.isLineCurve = !0),
        (hs.prototype.getPoint = function (e, t = new N()) {
          const n = t;
          return (
            1 === e
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }),
        (hs.prototype.getPointAt = function (e, t) {
          return this.getPoint(e, t);
        }),
        (hs.prototype.getTangent = function (e, t) {
          const n = t || new N();
          return n.copy(this.v2).sub(this.v1).normalize(), n;
        }),
        (hs.prototype.copy = function (e) {
          return (
            Zo.prototype.copy.call(this, e),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }),
        (hs.prototype.toJSON = function () {
          const e = Zo.prototype.toJSON.call(this);
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }),
        (hs.prototype.fromJSON = function (e) {
          return (
            Zo.prototype.fromJSON.call(this, e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }),
        (us.prototype = Object.create(Zo.prototype)),
        (us.prototype.constructor = us),
        (us.prototype.isLineCurve3 = !0),
        (us.prototype.getPoint = function (e, t = new W()) {
          const n = t;
          return (
            1 === e
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }),
        (us.prototype.getPointAt = function (e, t) {
          return this.getPoint(e, t);
        }),
        (us.prototype.copy = function (e) {
          return (
            Zo.prototype.copy.call(this, e),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }),
        (us.prototype.toJSON = function () {
          const e = Zo.prototype.toJSON.call(this);
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }),
        (us.prototype.fromJSON = function (e) {
          return (
            Zo.prototype.fromJSON.call(this, e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }),
        (ps.prototype = Object.create(Zo.prototype)),
        (ps.prototype.constructor = ps),
        (ps.prototype.isQuadraticBezierCurve = !0),
        (ps.prototype.getPoint = function (e, t = new N()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            a = this.v2;
          return n.set(os(e, i.x, r.x, a.x), os(e, i.y, r.y, a.y)), n;
        }),
        (ps.prototype.copy = function (e) {
          return (
            Zo.prototype.copy.call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }),
        (ps.prototype.toJSON = function () {
          const e = Zo.prototype.toJSON.call(this);
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }),
        (ps.prototype.fromJSON = function (e) {
          return (
            Zo.prototype.fromJSON.call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }),
        (ds.prototype = Object.create(Zo.prototype)),
        (ds.prototype.constructor = ds),
        (ds.prototype.isQuadraticBezierCurve3 = !0),
        (ds.prototype.getPoint = function (e, t = new W()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            a = this.v2;
          return (
            n.set(
              os(e, i.x, r.x, a.x),
              os(e, i.y, r.y, a.y),
              os(e, i.z, r.z, a.z)
            ),
            n
          );
        }),
        (ds.prototype.copy = function (e) {
          return (
            Zo.prototype.copy.call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }),
        (ds.prototype.toJSON = function () {
          const e = Zo.prototype.toJSON.call(this);
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }),
        (ds.prototype.fromJSON = function (e) {
          return (
            Zo.prototype.fromJSON.call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }),
        (fs.prototype = Object.create(Zo.prototype)),
        (fs.prototype.constructor = fs),
        (fs.prototype.isSplineCurve = !0),
        (fs.prototype.getPoint = function (e, t = new N()) {
          const n = t,
            i = this.points,
            r = (i.length - 1) * e,
            a = Math.floor(r),
            o = r - a,
            s = i[0 === a ? a : a - 1],
            c = i[a],
            l = i[a > i.length - 2 ? i.length - 1 : a + 1],
            h = i[a > i.length - 3 ? i.length - 1 : a + 2];
          return n.set(as(o, s.x, c.x, l.x, h.x), as(o, s.y, c.y, l.y, h.y)), n;
        }),
        (fs.prototype.copy = function (e) {
          Zo.prototype.copy.call(this, e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const n = e.points[t];
            this.points.push(n.clone());
          }
          return this;
        }),
        (fs.prototype.toJSON = function () {
          const e = Zo.prototype.toJSON.call(this);
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const n = this.points[t];
            e.points.push(n.toArray());
          }
          return e;
        }),
        (fs.prototype.fromJSON = function (e) {
          Zo.prototype.fromJSON.call(this, e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const n = e.points[t];
            this.points.push(new N().fromArray(n));
          }
          return this;
        });
      var ms = Object.freeze({
        __proto__: null,
        ArcCurve: Ko,
        CatmullRomCurve3: rs,
        CubicBezierCurve: cs,
        CubicBezierCurve3: ls,
        EllipseCurve: Qo,
        LineCurve: hs,
        LineCurve3: us,
        QuadraticBezierCurve: ps,
        QuadraticBezierCurve3: ds,
        SplineCurve: fs,
      });
      function gs() {
        Zo.call(this),
          (this.type = "CurvePath"),
          (this.curves = []),
          (this.autoClose = !1);
      }
      function vs(e) {
        gs.call(this),
          (this.type = "Path"),
          (this.currentPoint = new N()),
          e && this.setFromPoints(e);
      }
      function ys(e) {
        vs.call(this, e),
          (this.uuid = O.generateUUID()),
          (this.type = "Shape"),
          (this.holes = []);
      }
      function _s(e, t = 1) {
        Ge.call(this),
          (this.type = "Light"),
          (this.color = new ut(e)),
          (this.intensity = t);
      }
      function ws(e, t, n) {
        _s.call(this, e, n),
          (this.type = "HemisphereLight"),
          this.position.copy(Ge.DefaultUp),
          this.updateMatrix(),
          (this.groundColor = new ut(t));
      }
      function xs(e) {
        (this.camera = e),
          (this.bias = 0),
          (this.normalBias = 0),
          (this.radius = 1),
          (this.mapSize = new N(512, 512)),
          (this.map = null),
          (this.mapPass = null),
          (this.matrix = new ye()),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this._frustum = new wn()),
          (this._frameExtents = new N(1, 1)),
          (this._viewportCount = 1),
          (this._viewports = [new z(0, 0, 1, 1)]);
      }
      function bs() {
        xs.call(this, new pn(50, 1, 0.5, 500)), (this.focus = 1);
      }
      function Ms(e, t, n, i, r, a) {
        _s.call(this, e, t),
          (this.type = "SpotLight"),
          this.position.copy(Ge.DefaultUp),
          this.updateMatrix(),
          (this.target = new Ge()),
          Object.defineProperty(this, "power", {
            get: function () {
              return this.intensity * Math.PI;
            },
            set: function (e) {
              this.intensity = e / Math.PI;
            },
          }),
          (this.distance = void 0 !== n ? n : 0),
          (this.angle = void 0 !== i ? i : Math.PI / 3),
          (this.penumbra = void 0 !== r ? r : 0),
          (this.decay = void 0 !== a ? a : 1),
          (this.shadow = new bs());
      }
      function Ss() {
        xs.call(this, new pn(90, 1, 0.5, 500)),
          (this._frameExtents = new N(4, 2)),
          (this._viewportCount = 6),
          (this._viewports = [
            new z(2, 1, 1, 1),
            new z(0, 1, 1, 1),
            new z(3, 1, 1, 1),
            new z(1, 1, 1, 1),
            new z(3, 0, 1, 1),
            new z(1, 0, 1, 1),
          ]),
          (this._cubeDirections = [
            new W(1, 0, 0),
            new W(-1, 0, 0),
            new W(0, 0, 1),
            new W(0, 0, -1),
            new W(0, 1, 0),
            new W(0, -1, 0),
          ]),
          (this._cubeUps = [
            new W(0, 1, 0),
            new W(0, 1, 0),
            new W(0, 1, 0),
            new W(0, 1, 0),
            new W(0, 0, 1),
            new W(0, 0, -1),
          ]);
      }
      function Ts(e, t, n, i) {
        _s.call(this, e, t),
          (this.type = "PointLight"),
          Object.defineProperty(this, "power", {
            get: function () {
              return 4 * this.intensity * Math.PI;
            },
            set: function (e) {
              this.intensity = e / (4 * Math.PI);
            },
          }),
          (this.distance = void 0 !== n ? n : 0),
          (this.decay = void 0 !== i ? i : 1),
          (this.shadow = new Ss());
      }
      function Es(e = -1, t = 1, n = 1, i = -1, r = 0.1, a = 2e3) {
        un.call(this),
          (this.type = "OrthographicCamera"),
          (this.zoom = 1),
          (this.view = null),
          (this.left = e),
          (this.right = t),
          (this.top = n),
          (this.bottom = i),
          (this.near = r),
          (this.far = a),
          this.updateProjectionMatrix();
      }
      function As() {
        xs.call(this, new Es(-5, 5, 5, -5, 0.5, 500));
      }
      function Ls(e, t) {
        _s.call(this, e, t),
          (this.type = "DirectionalLight"),
          this.position.copy(Ge.DefaultUp),
          this.updateMatrix(),
          (this.target = new Ge()),
          (this.shadow = new As());
      }
      function Ps(e, t) {
        _s.call(this, e, t), (this.type = "AmbientLight");
      }
      function Rs(e, t, n, i) {
        _s.call(this, e, t),
          (this.type = "RectAreaLight"),
          (this.width = void 0 !== n ? n : 10),
          (this.height = void 0 !== i ? i : 10);
      }
      (gs.prototype = Object.assign(Object.create(Zo.prototype), {
        constructor: gs,
        add: function (e) {
          this.curves.push(e);
        },
        closePath: function () {
          const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
          e.equals(t) || this.curves.push(new hs(t, e));
        },
        getPoint: function (e) {
          const t = e * this.getLength(),
            n = this.getCurveLengths();
          let i = 0;
          for (; i < n.length; ) {
            if (n[i] >= t) {
              const e = n[i] - t,
                r = this.curves[i],
                a = r.getLength(),
                o = 0 === a ? 0 : 1 - e / a;
              return r.getPointAt(o);
            }
            i++;
          }
          return null;
        },
        getLength: function () {
          const e = this.getCurveLengths();
          return e[e.length - 1];
        },
        updateArcLengths: function () {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        },
        getCurveLengths: function () {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          const e = [];
          let t = 0;
          for (let n = 0, i = this.curves.length; n < i; n++)
            (t += this.curves[n].getLength()), e.push(t);
          return (this.cacheLengths = e), e;
        },
        getSpacedPoints: function (e = 40) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return this.autoClose && t.push(t[0]), t;
        },
        getPoints: function (e = 12) {
          const t = [];
          let n;
          for (let i = 0, r = this.curves; i < r.length; i++) {
            const a = r[i],
              o =
                a && a.isEllipseCurve
                  ? 2 * e
                  : a && (a.isLineCurve || a.isLineCurve3)
                  ? 1
                  : a && a.isSplineCurve
                  ? e * a.points.length
                  : e,
              s = a.getPoints(o);
            for (let e = 0; e < s.length; e++) {
              const i = s[e];
              (n && n.equals(i)) || (t.push(i), (n = i));
            }
          }
          return (
            this.autoClose &&
              t.length > 1 &&
              !t[t.length - 1].equals(t[0]) &&
              t.push(t[0]),
            t
          );
        },
        copy: function (e) {
          Zo.prototype.copy.call(this, e), (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const n = e.curves[t];
            this.curves.push(n.clone());
          }
          return (this.autoClose = e.autoClose), this;
        },
        toJSON: function () {
          const e = Zo.prototype.toJSON.call(this);
          (e.autoClose = this.autoClose), (e.curves = []);
          for (let t = 0, n = this.curves.length; t < n; t++) {
            const n = this.curves[t];
            e.curves.push(n.toJSON());
          }
          return e;
        },
        fromJSON: function (e) {
          Zo.prototype.fromJSON.call(this, e),
            (this.autoClose = e.autoClose),
            (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const n = e.curves[t];
            this.curves.push(new ms[n.type]().fromJSON(n));
          }
          return this;
        },
      })),
        (vs.prototype = Object.assign(Object.create(gs.prototype), {
          constructor: vs,
          setFromPoints: function (e) {
            this.moveTo(e[0].x, e[0].y);
            for (let t = 1, n = e.length; t < n; t++)
              this.lineTo(e[t].x, e[t].y);
            return this;
          },
          moveTo: function (e, t) {
            return this.currentPoint.set(e, t), this;
          },
          lineTo: function (e, t) {
            const n = new hs(this.currentPoint.clone(), new N(e, t));
            return this.curves.push(n), this.currentPoint.set(e, t), this;
          },
          quadraticCurveTo: function (e, t, n, i) {
            const r = new ps(
              this.currentPoint.clone(),
              new N(e, t),
              new N(n, i)
            );
            return this.curves.push(r), this.currentPoint.set(n, i), this;
          },
          bezierCurveTo: function (e, t, n, i, r, a) {
            const o = new cs(
              this.currentPoint.clone(),
              new N(e, t),
              new N(n, i),
              new N(r, a)
            );
            return this.curves.push(o), this.currentPoint.set(r, a), this;
          },
          splineThru: function (e) {
            const t = new fs([this.currentPoint.clone()].concat(e));
            return (
              this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this
            );
          },
          arc: function (e, t, n, i, r, a) {
            const o = this.currentPoint.x,
              s = this.currentPoint.y;
            return this.absarc(e + o, t + s, n, i, r, a), this;
          },
          absarc: function (e, t, n, i, r, a) {
            return this.absellipse(e, t, n, n, i, r, a), this;
          },
          ellipse: function (e, t, n, i, r, a, o, s) {
            const c = this.currentPoint.x,
              l = this.currentPoint.y;
            return this.absellipse(e + c, t + l, n, i, r, a, o, s), this;
          },
          absellipse: function (e, t, n, i, r, a, o, s) {
            const c = new Qo(e, t, n, i, r, a, o, s);
            if (this.curves.length > 0) {
              const e = c.getPoint(0);
              e.equals(this.currentPoint) || this.lineTo(e.x, e.y);
            }
            this.curves.push(c);
            const l = c.getPoint(1);
            return this.currentPoint.copy(l), this;
          },
          copy: function (e) {
            return (
              gs.prototype.copy.call(this, e),
              this.currentPoint.copy(e.currentPoint),
              this
            );
          },
          toJSON: function () {
            const e = gs.prototype.toJSON.call(this);
            return (e.currentPoint = this.currentPoint.toArray()), e;
          },
          fromJSON: function (e) {
            return (
              gs.prototype.fromJSON.call(this, e),
              this.currentPoint.fromArray(e.currentPoint),
              this
            );
          },
        })),
        (ys.prototype = Object.assign(Object.create(vs.prototype), {
          constructor: ys,
          getPointsHoles: function (e) {
            const t = [];
            for (let n = 0, i = this.holes.length; n < i; n++)
              t[n] = this.holes[n].getPoints(e);
            return t;
          },
          extractPoints: function (e) {
            return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
          },
          copy: function (e) {
            vs.prototype.copy.call(this, e), (this.holes = []);
            for (let t = 0, n = e.holes.length; t < n; t++) {
              const n = e.holes[t];
              this.holes.push(n.clone());
            }
            return this;
          },
          toJSON: function () {
            const e = vs.prototype.toJSON.call(this);
            (e.uuid = this.uuid), (e.holes = []);
            for (let t = 0, n = this.holes.length; t < n; t++) {
              const n = this.holes[t];
              e.holes.push(n.toJSON());
            }
            return e;
          },
          fromJSON: function (e) {
            vs.prototype.fromJSON.call(this, e),
              (this.uuid = e.uuid),
              (this.holes = []);
            for (let t = 0, n = e.holes.length; t < n; t++) {
              const n = e.holes[t];
              this.holes.push(new vs().fromJSON(n));
            }
            return this;
          },
        })),
        (_s.prototype = Object.assign(Object.create(Ge.prototype), {
          constructor: _s,
          isLight: !0,
          copy: function (e) {
            return (
              Ge.prototype.copy.call(this, e),
              this.color.copy(e.color),
              (this.intensity = e.intensity),
              this
            );
          },
          toJSON: function (e) {
            const t = Ge.prototype.toJSON.call(this, e);
            return (
              (t.object.color = this.color.getHex()),
              (t.object.intensity = this.intensity),
              void 0 !== this.groundColor &&
                (t.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (t.object.distance = this.distance),
              void 0 !== this.angle && (t.object.angle = this.angle),
              void 0 !== this.decay && (t.object.decay = this.decay),
              void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
              void 0 !== this.shadow &&
                (t.object.shadow = this.shadow.toJSON()),
              t
            );
          },
        })),
        (ws.prototype = Object.assign(Object.create(_s.prototype), {
          constructor: ws,
          isHemisphereLight: !0,
          copy: function (e) {
            return (
              _s.prototype.copy.call(this, e),
              this.groundColor.copy(e.groundColor),
              this
            );
          },
        })),
        Object.assign(xs.prototype, {
          _projScreenMatrix: new ye(),
          _lightPositionWorld: new W(),
          _lookTarget: new W(),
          getViewportCount: function () {
            return this._viewportCount;
          },
          getFrustum: function () {
            return this._frustum;
          },
          updateMatrices: function (e) {
            const t = this.camera,
              n = this.matrix,
              i = this._projScreenMatrix,
              r = this._lookTarget,
              a = this._lightPositionWorld;
            a.setFromMatrixPosition(e.matrixWorld),
              t.position.copy(a),
              r.setFromMatrixPosition(e.target.matrixWorld),
              t.lookAt(r),
              t.updateMatrixWorld(),
              i.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(i),
              n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
              n.multiply(t.projectionMatrix),
              n.multiply(t.matrixWorldInverse);
          },
          getViewport: function (e) {
            return this._viewports[e];
          },
          getFrameExtents: function () {
            return this._frameExtents;
          },
          copy: function (e) {
            return (
              (this.camera = e.camera.clone()),
              (this.bias = e.bias),
              (this.radius = e.radius),
              this.mapSize.copy(e.mapSize),
              this
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          toJSON: function () {
            const e = {};
            return (
              0 !== this.bias && (e.bias = this.bias),
              0 !== this.normalBias && (e.normalBias = this.normalBias),
              1 !== this.radius && (e.radius = this.radius),
              (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                (e.mapSize = this.mapSize.toArray()),
              (e.camera = this.camera.toJSON(!1).object),
              delete e.camera.matrix,
              e
            );
          },
        }),
        (bs.prototype = Object.assign(Object.create(xs.prototype), {
          constructor: bs,
          isSpotLightShadow: !0,
          updateMatrices: function (e) {
            const t = this.camera,
              n = 2 * O.RAD2DEG * e.angle * this.focus,
              i = this.mapSize.width / this.mapSize.height,
              r = e.distance || t.far;
            (n === t.fov && i === t.aspect && r === t.far) ||
              ((t.fov = n),
              (t.aspect = i),
              (t.far = r),
              t.updateProjectionMatrix()),
              xs.prototype.updateMatrices.call(this, e);
          },
        })),
        (Ms.prototype = Object.assign(Object.create(_s.prototype), {
          constructor: Ms,
          isSpotLight: !0,
          copy: function (e) {
            return (
              _s.prototype.copy.call(this, e),
              (this.distance = e.distance),
              (this.angle = e.angle),
              (this.penumbra = e.penumbra),
              (this.decay = e.decay),
              (this.target = e.target.clone()),
              (this.shadow = e.shadow.clone()),
              this
            );
          },
        })),
        (Ss.prototype = Object.assign(Object.create(xs.prototype), {
          constructor: Ss,
          isPointLightShadow: !0,
          updateMatrices: function (e, t = 0) {
            const n = this.camera,
              i = this.matrix,
              r = this._lightPositionWorld,
              a = this._lookTarget,
              o = this._projScreenMatrix;
            r.setFromMatrixPosition(e.matrixWorld),
              n.position.copy(r),
              a.copy(n.position),
              a.add(this._cubeDirections[t]),
              n.up.copy(this._cubeUps[t]),
              n.lookAt(a),
              n.updateMatrixWorld(),
              i.makeTranslation(-r.x, -r.y, -r.z),
              o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(o);
          },
        })),
        (Ts.prototype = Object.assign(Object.create(_s.prototype), {
          constructor: Ts,
          isPointLight: !0,
          copy: function (e) {
            return (
              _s.prototype.copy.call(this, e),
              (this.distance = e.distance),
              (this.decay = e.decay),
              (this.shadow = e.shadow.clone()),
              this
            );
          },
        })),
        (Es.prototype = Object.assign(Object.create(un.prototype), {
          constructor: Es,
          isOrthographicCamera: !0,
          copy: function (e, t) {
            return (
              un.prototype.copy.call(this, e, t),
              (this.left = e.left),
              (this.right = e.right),
              (this.top = e.top),
              (this.bottom = e.bottom),
              (this.near = e.near),
              (this.far = e.far),
              (this.zoom = e.zoom),
              (this.view = null === e.view ? null : Object.assign({}, e.view)),
              this
            );
          },
          setViewOffset: function (e, t, n, i, r, a) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = e),
              (this.view.fullHeight = t),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = a),
              this.updateProjectionMatrix();
          },
          clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          },
          updateProjectionMatrix: function () {
            const e = (this.right - this.left) / (2 * this.zoom),
              t = (this.top - this.bottom) / (2 * this.zoom),
              n = (this.right + this.left) / 2,
              i = (this.top + this.bottom) / 2;
            let r = n - e,
              a = n + e,
              o = i + t,
              s = i - t;
            if (null !== this.view && this.view.enabled) {
              const e =
                  (this.right - this.left) / this.view.fullWidth / this.zoom,
                t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              (r += e * this.view.offsetX),
                (a = r + e * this.view.width),
                (o -= t * this.view.offsetY),
                (s = o - t * this.view.height);
            }
            this.projectionMatrix.makeOrthographic(
              r,
              a,
              o,
              s,
              this.near,
              this.far
            ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          },
          toJSON: function (e) {
            const t = Ge.prototype.toJSON.call(this, e);
            return (
              (t.object.zoom = this.zoom),
              (t.object.left = this.left),
              (t.object.right = this.right),
              (t.object.top = this.top),
              (t.object.bottom = this.bottom),
              (t.object.near = this.near),
              (t.object.far = this.far),
              null !== this.view &&
                (t.object.view = Object.assign({}, this.view)),
              t
            );
          },
        })),
        (As.prototype = Object.assign(Object.create(xs.prototype), {
          constructor: As,
          isDirectionalLightShadow: !0,
          updateMatrices: function (e) {
            xs.prototype.updateMatrices.call(this, e);
          },
        })),
        (Ls.prototype = Object.assign(Object.create(_s.prototype), {
          constructor: Ls,
          isDirectionalLight: !0,
          copy: function (e) {
            return (
              _s.prototype.copy.call(this, e),
              (this.target = e.target.clone()),
              (this.shadow = e.shadow.clone()),
              this
            );
          },
        })),
        (Ps.prototype = Object.assign(Object.create(_s.prototype), {
          constructor: Ps,
          isAmbientLight: !0,
        })),
        (Rs.prototype = Object.assign(Object.create(_s.prototype), {
          constructor: Rs,
          isRectAreaLight: !0,
          copy: function (e) {
            return (
              _s.prototype.copy.call(this, e),
              (this.width = e.width),
              (this.height = e.height),
              this
            );
          },
          toJSON: function (e) {
            const t = _s.prototype.toJSON.call(this, e);
            return (
              (t.object.width = this.width), (t.object.height = this.height), t
            );
          },
        }));
      class ks {
        constructor() {
          Object.defineProperty(this, "isSphericalHarmonics3", { value: !0 }),
            (this.coefficients = []);
          for (let e = 0; e < 9; e++) this.coefficients.push(new W());
        }
        set(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
          return this;
        }
        zero() {
          for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
          return this;
        }
        getAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            a = this.coefficients;
          return (
            t.copy(a[0]).multiplyScalar(0.282095),
            t.addScaledVector(a[1], 0.488603 * i),
            t.addScaledVector(a[2], 0.488603 * r),
            t.addScaledVector(a[3], 0.488603 * n),
            t.addScaledVector(a[4], n * i * 1.092548),
            t.addScaledVector(a[5], i * r * 1.092548),
            t.addScaledVector(a[6], 0.315392 * (3 * r * r - 1)),
            t.addScaledVector(a[7], n * r * 1.092548),
            t.addScaledVector(a[8], 0.546274 * (n * n - i * i)),
            t
          );
        }
        getIrradianceAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            a = this.coefficients;
          return (
            t.copy(a[0]).multiplyScalar(0.886227),
            t.addScaledVector(a[1], 1.023328 * i),
            t.addScaledVector(a[2], 1.023328 * r),
            t.addScaledVector(a[3], 1.023328 * n),
            t.addScaledVector(a[4], 0.858086 * n * i),
            t.addScaledVector(a[5], 0.858086 * i * r),
            t.addScaledVector(a[6], 0.743125 * r * r - 0.247708),
            t.addScaledVector(a[7], 0.858086 * n * r),
            t.addScaledVector(a[8], 0.429043 * (n * n - i * i)),
            t
          );
        }
        add(e) {
          for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
          return this;
        }
        addScaledSH(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(e.coefficients[n], t);
          return this;
        }
        scale(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
          return this;
        }
        lerp(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(e.coefficients[n], t);
          return this;
        }
        equals(e) {
          for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
          return !0;
        }
        copy(e) {
          return this.set(e.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(e, t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].fromArray(e, t + 3 * i);
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].toArray(e, t + 3 * i);
          return e;
        }
        static getBasisAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z;
          (t[0] = 0.282095),
            (t[1] = 0.488603 * i),
            (t[2] = 0.488603 * r),
            (t[3] = 0.488603 * n),
            (t[4] = 1.092548 * n * i),
            (t[5] = 1.092548 * i * r),
            (t[6] = 0.315392 * (3 * r * r - 1)),
            (t[7] = 1.092548 * n * r),
            (t[8] = 0.546274 * (n * n - i * i));
        }
      }
      function Cs(e, t) {
        _s.call(this, void 0, t),
          (this.type = "LightProbe"),
          (this.sh = void 0 !== e ? e : new ks());
      }
      function Os(e) {
        zo.call(this, e), (this.textures = {});
      }
      (Cs.prototype = Object.assign(Object.create(_s.prototype), {
        constructor: Cs,
        isLightProbe: !0,
        copy: function (e) {
          return _s.prototype.copy.call(this, e), this.sh.copy(e.sh), this;
        },
        fromJSON: function (e) {
          return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
        },
        toJSON: function (e) {
          const t = _s.prototype.toJSON.call(this, e);
          return (t.object.sh = this.sh.toArray()), t;
        },
      })),
        (Os.prototype = Object.assign(Object.create(zo.prototype), {
          constructor: Os,
          load: function (e, t, n, i) {
            const r = this,
              a = new Go(r.manager);
            a.setPath(r.path),
              a.setRequestHeader(r.requestHeader),
              a.setWithCredentials(r.withCredentials),
              a.load(
                e,
                function (n) {
                  try {
                    t(r.parse(JSON.parse(n)));
                  } catch (t) {
                    i ? i(t) : console.error(t), r.manager.itemError(e);
                  }
                },
                n,
                i
              );
          },
          parse: function (e) {
            const t = this.textures;
            function n(e) {
              return (
                void 0 === t[e] &&
                  console.warn("THREE.MaterialLoader: Undefined texture", e),
                t[e]
              );
            }
            const i = new Mo[e.type]();
            if (
              (void 0 !== e.uuid && (i.uuid = e.uuid),
              void 0 !== e.name && (i.name = e.name),
              void 0 !== e.color &&
                void 0 !== i.color &&
                i.color.setHex(e.color),
              void 0 !== e.roughness && (i.roughness = e.roughness),
              void 0 !== e.metalness && (i.metalness = e.metalness),
              void 0 !== e.sheen && (i.sheen = new ut().setHex(e.sheen)),
              void 0 !== e.emissive &&
                void 0 !== i.emissive &&
                i.emissive.setHex(e.emissive),
              void 0 !== e.specular &&
                void 0 !== i.specular &&
                i.specular.setHex(e.specular),
              void 0 !== e.shininess && (i.shininess = e.shininess),
              void 0 !== e.clearcoat && (i.clearcoat = e.clearcoat),
              void 0 !== e.clearcoatRoughness &&
                (i.clearcoatRoughness = e.clearcoatRoughness),
              void 0 !== e.fog && (i.fog = e.fog),
              void 0 !== e.flatShading && (i.flatShading = e.flatShading),
              void 0 !== e.blending && (i.blending = e.blending),
              void 0 !== e.combine && (i.combine = e.combine),
              void 0 !== e.side && (i.side = e.side),
              void 0 !== e.opacity && (i.opacity = e.opacity),
              void 0 !== e.transparent && (i.transparent = e.transparent),
              void 0 !== e.alphaTest && (i.alphaTest = e.alphaTest),
              void 0 !== e.depthTest && (i.depthTest = e.depthTest),
              void 0 !== e.depthWrite && (i.depthWrite = e.depthWrite),
              void 0 !== e.colorWrite && (i.colorWrite = e.colorWrite),
              void 0 !== e.stencilWrite && (i.stencilWrite = e.stencilWrite),
              void 0 !== e.stencilWriteMask &&
                (i.stencilWriteMask = e.stencilWriteMask),
              void 0 !== e.stencilFunc && (i.stencilFunc = e.stencilFunc),
              void 0 !== e.stencilRef && (i.stencilRef = e.stencilRef),
              void 0 !== e.stencilFuncMask &&
                (i.stencilFuncMask = e.stencilFuncMask),
              void 0 !== e.stencilFail && (i.stencilFail = e.stencilFail),
              void 0 !== e.stencilZFail && (i.stencilZFail = e.stencilZFail),
              void 0 !== e.stencilZPass && (i.stencilZPass = e.stencilZPass),
              void 0 !== e.wireframe && (i.wireframe = e.wireframe),
              void 0 !== e.wireframeLinewidth &&
                (i.wireframeLinewidth = e.wireframeLinewidth),
              void 0 !== e.wireframeLinecap &&
                (i.wireframeLinecap = e.wireframeLinecap),
              void 0 !== e.wireframeLinejoin &&
                (i.wireframeLinejoin = e.wireframeLinejoin),
              void 0 !== e.rotation && (i.rotation = e.rotation),
              1 !== e.linewidth && (i.linewidth = e.linewidth),
              void 0 !== e.dashSize && (i.dashSize = e.dashSize),
              void 0 !== e.gapSize && (i.gapSize = e.gapSize),
              void 0 !== e.scale && (i.scale = e.scale),
              void 0 !== e.polygonOffset && (i.polygonOffset = e.polygonOffset),
              void 0 !== e.polygonOffsetFactor &&
                (i.polygonOffsetFactor = e.polygonOffsetFactor),
              void 0 !== e.polygonOffsetUnits &&
                (i.polygonOffsetUnits = e.polygonOffsetUnits),
              void 0 !== e.skinning && (i.skinning = e.skinning),
              void 0 !== e.morphTargets && (i.morphTargets = e.morphTargets),
              void 0 !== e.morphNormals && (i.morphNormals = e.morphNormals),
              void 0 !== e.dithering && (i.dithering = e.dithering),
              void 0 !== e.vertexTangents &&
                (i.vertexTangents = e.vertexTangents),
              void 0 !== e.visible && (i.visible = e.visible),
              void 0 !== e.toneMapped && (i.toneMapped = e.toneMapped),
              void 0 !== e.userData && (i.userData = e.userData),
              void 0 !== e.vertexColors &&
                ("number" == typeof e.vertexColors
                  ? (i.vertexColors = e.vertexColors > 0)
                  : (i.vertexColors = e.vertexColors)),
              void 0 !== e.uniforms)
            )
              for (const t in e.uniforms) {
                const r = e.uniforms[t];
                switch (((i.uniforms[t] = {}), r.type)) {
                  case "t":
                    i.uniforms[t].value = n(r.value);
                    break;
                  case "c":
                    i.uniforms[t].value = new ut().setHex(r.value);
                    break;
                  case "v2":
                    i.uniforms[t].value = new N().fromArray(r.value);
                    break;
                  case "v3":
                    i.uniforms[t].value = new W().fromArray(r.value);
                    break;
                  case "v4":
                    i.uniforms[t].value = new z().fromArray(r.value);
                    break;
                  case "m3":
                    i.uniforms[t].value = new I().fromArray(r.value);
                    break;
                  case "m4":
                    i.uniforms[t].value = new ye().fromArray(r.value);
                    break;
                  default:
                    i.uniforms[t].value = r.value;
                }
              }
            if (
              (void 0 !== e.defines && (i.defines = e.defines),
              void 0 !== e.vertexShader && (i.vertexShader = e.vertexShader),
              void 0 !== e.fragmentShader &&
                (i.fragmentShader = e.fragmentShader),
              void 0 !== e.extensions)
            )
              for (const t in e.extensions) i.extensions[t] = e.extensions[t];
            if (
              (void 0 !== e.shading && (i.flatShading = 1 === e.shading),
              void 0 !== e.size && (i.size = e.size),
              void 0 !== e.sizeAttenuation &&
                (i.sizeAttenuation = e.sizeAttenuation),
              void 0 !== e.map && (i.map = n(e.map)),
              void 0 !== e.matcap && (i.matcap = n(e.matcap)),
              void 0 !== e.alphaMap && (i.alphaMap = n(e.alphaMap)),
              void 0 !== e.bumpMap && (i.bumpMap = n(e.bumpMap)),
              void 0 !== e.bumpScale && (i.bumpScale = e.bumpScale),
              void 0 !== e.normalMap && (i.normalMap = n(e.normalMap)),
              void 0 !== e.normalMapType && (i.normalMapType = e.normalMapType),
              void 0 !== e.normalScale)
            ) {
              let t = e.normalScale;
              !1 === Array.isArray(t) && (t = [t, t]),
                (i.normalScale = new N().fromArray(t));
            }
            return (
              void 0 !== e.displacementMap &&
                (i.displacementMap = n(e.displacementMap)),
              void 0 !== e.displacementScale &&
                (i.displacementScale = e.displacementScale),
              void 0 !== e.displacementBias &&
                (i.displacementBias = e.displacementBias),
              void 0 !== e.roughnessMap && (i.roughnessMap = n(e.roughnessMap)),
              void 0 !== e.metalnessMap && (i.metalnessMap = n(e.metalnessMap)),
              void 0 !== e.emissiveMap && (i.emissiveMap = n(e.emissiveMap)),
              void 0 !== e.emissiveIntensity &&
                (i.emissiveIntensity = e.emissiveIntensity),
              void 0 !== e.specularMap && (i.specularMap = n(e.specularMap)),
              void 0 !== e.envMap && (i.envMap = n(e.envMap)),
              void 0 !== e.envMapIntensity &&
                (i.envMapIntensity = e.envMapIntensity),
              void 0 !== e.reflectivity && (i.reflectivity = e.reflectivity),
              void 0 !== e.refractionRatio &&
                (i.refractionRatio = e.refractionRatio),
              void 0 !== e.lightMap && (i.lightMap = n(e.lightMap)),
              void 0 !== e.lightMapIntensity &&
                (i.lightMapIntensity = e.lightMapIntensity),
              void 0 !== e.aoMap && (i.aoMap = n(e.aoMap)),
              void 0 !== e.aoMapIntensity &&
                (i.aoMapIntensity = e.aoMapIntensity),
              void 0 !== e.gradientMap && (i.gradientMap = n(e.gradientMap)),
              void 0 !== e.clearcoatMap && (i.clearcoatMap = n(e.clearcoatMap)),
              void 0 !== e.clearcoatRoughnessMap &&
                (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
              void 0 !== e.clearcoatNormalMap &&
                (i.clearcoatNormalMap = n(e.clearcoatNormalMap)),
              void 0 !== e.clearcoatNormalScale &&
                (i.clearcoatNormalScale = new N().fromArray(
                  e.clearcoatNormalScale
                )),
              void 0 !== e.transmission && (i.transmission = e.transmission),
              void 0 !== e.transmissionMap &&
                (i.transmissionMap = n(e.transmissionMap)),
              i
            );
          },
          setTextures: function (e) {
            return (this.textures = e), this;
          },
        }));
      const Ns = function (e) {
          if ("undefined" != typeof TextDecoder)
            return new TextDecoder().decode(e);
          let t = "";
          for (let n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
          try {
            return decodeURIComponent(escape(t));
          } catch (e) {
            return t;
          }
        },
        Is = function (e) {
          const t = e.lastIndexOf("/");
          return -1 === t ? "./" : e.substr(0, t + 1);
        };
      function Ds() {
        Ht.call(this),
          (this.type = "InstancedBufferGeometry"),
          (this.instanceCount = 1 / 0);
      }
      function js(e, t, n, i) {
        "number" == typeof n &&
          ((i = n),
          (n = !1),
          console.error(
            "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
          )),
          yt.call(this, e, t, n),
          (this.meshPerAttribute = i || 1);
      }
      function Fs(e) {
        zo.call(this, e);
      }
      function Hs(e) {
        "undefined" == typeof createImageBitmap &&
          console.warn(
            "THREE.ImageBitmapLoader: createImageBitmap() not supported."
          ),
          "undefined" == typeof fetch &&
            console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
          zo.call(this, e),
          (this.options = { premultiplyAlpha: "none" });
      }
      function Bs() {
        (this.type = "ShapePath"),
          (this.color = new ut()),
          (this.subPaths = []),
          (this.currentPath = null);
      }
      (Ds.prototype = Object.assign(Object.create(Ht.prototype), {
        constructor: Ds,
        isInstancedBufferGeometry: !0,
        copy: function (e) {
          return (
            Ht.prototype.copy.call(this, e),
            (this.instanceCount = e.instanceCount),
            this
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        toJSON: function () {
          const e = Ht.prototype.toJSON.call(this);
          return (
            (e.instanceCount = this.instanceCount),
            (e.isInstancedBufferGeometry = !0),
            e
          );
        },
      })),
        (js.prototype = Object.assign(Object.create(yt.prototype), {
          constructor: js,
          isInstancedBufferAttribute: !0,
          copy: function (e) {
            return (
              yt.prototype.copy.call(this, e),
              (this.meshPerAttribute = e.meshPerAttribute),
              this
            );
          },
          toJSON: function () {
            const e = yt.prototype.toJSON.call(this);
            return (
              (e.meshPerAttribute = this.meshPerAttribute),
              (e.isInstancedBufferAttribute = !0),
              e
            );
          },
        })),
        (Fs.prototype = Object.assign(Object.create(zo.prototype), {
          constructor: Fs,
          load: function (e, t, n, i) {
            const r = this,
              a = new Go(r.manager);
            a.setPath(r.path),
              a.setRequestHeader(r.requestHeader),
              a.setWithCredentials(r.withCredentials),
              a.load(
                e,
                function (n) {
                  try {
                    t(r.parse(JSON.parse(n)));
                  } catch (t) {
                    i ? i(t) : console.error(t), r.manager.itemError(e);
                  }
                },
                n,
                i
              );
          },
          parse: function (e) {
            const t = {},
              n = {};
            function i(e, i) {
              if (void 0 !== t[i]) return t[i];
              const r = e.interleavedBuffers[i],
                a = (function (e, t) {
                  if (void 0 !== n[t]) return n[t];
                  const i = e.arrayBuffers[t],
                    r = new Uint32Array(i).buffer;
                  return (n[t] = r), r;
                })(e, r.buffer),
                o = new Rr(kt(r.type, a), r.stride);
              return (o.uuid = r.uuid), (t[i] = o), o;
            }
            const r = e.isInstancedBufferGeometry ? new Ds() : new Ht(),
              a = e.data.index;
            if (void 0 !== a) {
              const e = kt(a.type, a.array);
              r.setIndex(new yt(e, 1));
            }
            const o = e.data.attributes;
            for (const t in o) {
              const n = o[t];
              let a;
              if (n.isInterleavedBufferAttribute)
                a = new Cr(
                  i(e.data, n.data),
                  n.itemSize,
                  n.offset,
                  n.normalized
                );
              else {
                const e = kt(n.type, n.array);
                a = new (n.isInstancedBufferAttribute ? js : yt)(
                  e,
                  n.itemSize,
                  n.normalized
                );
              }
              void 0 !== n.name && (a.name = n.name), r.setAttribute(t, a);
            }
            const s = e.data.morphAttributes;
            if (s)
              for (const t in s) {
                const n = s[t],
                  a = [];
                for (let t = 0, r = n.length; t < r; t++) {
                  const r = n[t];
                  let o;
                  (o = r.isInterleavedBufferAttribute
                    ? new Cr(
                        i(e.data, r.data),
                        r.itemSize,
                        r.offset,
                        r.normalized
                      )
                    : new yt(kt(r.type, r.array), r.itemSize, r.normalized)),
                    void 0 !== r.name && (o.name = r.name),
                    a.push(o);
                }
                r.morphAttributes[t] = a;
              }
            e.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
            const c = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (void 0 !== c)
              for (let e = 0, t = c.length; e !== t; ++e) {
                const t = c[e];
                r.addGroup(t.start, t.count, t.materialIndex);
              }
            const l = e.data.boundingSphere;
            if (void 0 !== l) {
              const e = new W();
              void 0 !== l.center && e.fromArray(l.center),
                (r.boundingSphere = new le(e, l.radius));
            }
            return (
              e.name && (r.name = e.name),
              e.userData && (r.userData = e.userData),
              r
            );
          },
        })),
        (Hs.prototype = Object.assign(Object.create(zo.prototype), {
          constructor: Hs,
          isImageBitmapLoader: !0,
          setOptions: function (e) {
            return (this.options = e), this;
          },
          load: function (e, t, n, i) {
            void 0 === e && (e = ""),
              void 0 !== this.path && (e = this.path + e),
              (e = this.manager.resolveURL(e));
            const r = this,
              a = Ho.get(e);
            if (void 0 !== a)
              return (
                r.manager.itemStart(e),
                setTimeout(function () {
                  t && t(a), r.manager.itemEnd(e);
                }, 0),
                a
              );
            const o = {};
            (o.credentials =
              "anonymous" === this.crossOrigin ? "same-origin" : "include"),
              fetch(e, o)
                .then(function (e) {
                  return e.blob();
                })
                .then(function (e) {
                  return createImageBitmap(e, r.options);
                })
                .then(function (n) {
                  Ho.add(e, n), t && t(n), r.manager.itemEnd(e);
                })
                .catch(function (t) {
                  i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
                }),
              r.manager.itemStart(e);
          },
        })),
        Object.assign(Bs.prototype, {
          moveTo: function (e, t) {
            return (
              (this.currentPath = new vs()),
              this.subPaths.push(this.currentPath),
              this.currentPath.moveTo(e, t),
              this
            );
          },
          lineTo: function (e, t) {
            return this.currentPath.lineTo(e, t), this;
          },
          quadraticCurveTo: function (e, t, n, i) {
            return this.currentPath.quadraticCurveTo(e, t, n, i), this;
          },
          bezierCurveTo: function (e, t, n, i, r, a) {
            return this.currentPath.bezierCurveTo(e, t, n, i, r, a), this;
          },
          splineThru: function (e) {
            return this.currentPath.splineThru(e), this;
          },
          toShapes: function (e, t) {
            function n(e) {
              const t = [];
              for (let n = 0, i = e.length; n < i; n++) {
                const i = e[n],
                  r = new ys();
                (r.curves = i.curves), t.push(r);
              }
              return t;
            }
            function i(e, t) {
              const n = t.length;
              let i = !1;
              for (let r = n - 1, a = 0; a < n; r = a++) {
                let n = t[r],
                  o = t[a],
                  s = o.x - n.x,
                  c = o.y - n.y;
                if (Math.abs(c) > Number.EPSILON) {
                  if (
                    (c < 0 && ((n = t[a]), (s = -s), (o = t[r]), (c = -c)),
                    e.y < n.y || e.y > o.y)
                  )
                    continue;
                  if (e.y === n.y) {
                    if (e.x === n.x) return !0;
                  } else {
                    const t = c * (e.x - n.x) - s * (e.y - n.y);
                    if (0 === t) return !0;
                    if (t < 0) continue;
                    i = !i;
                  }
                } else {
                  if (e.y !== n.y) continue;
                  if ((o.x <= e.x && e.x <= n.x) || (n.x <= e.x && e.x <= o.x))
                    return !0;
                }
              }
              return i;
            }
            const r = ao.isClockWise,
              a = this.subPaths;
            if (0 === a.length) return [];
            if (!0 === t) return n(a);
            let o, s, c;
            const l = [];
            if (1 === a.length)
              return (
                (s = a[0]), (c = new ys()), (c.curves = s.curves), l.push(c), l
              );
            let h = !r(a[0].getPoints());
            h = e ? !h : h;
            const u = [],
              p = [];
            let d,
              f,
              m = [],
              g = 0;
            (p[g] = void 0), (m[g] = []);
            for (let t = 0, n = a.length; t < n; t++)
              (s = a[t]),
                (d = s.getPoints()),
                (o = r(d)),
                (o = e ? !o : o),
                o
                  ? (!h && p[g] && g++,
                    (p[g] = { s: new ys(), p: d }),
                    (p[g].s.curves = s.curves),
                    h && g++,
                    (m[g] = []))
                  : m[g].push({ h: s, p: d[0] });
            if (!p[0]) return n(a);
            if (p.length > 1) {
              let e = !1;
              const t = [];
              for (let e = 0, t = p.length; e < t; e++) u[e] = [];
              for (let n = 0, r = p.length; n < r; n++) {
                const r = m[n];
                for (let a = 0; a < r.length; a++) {
                  const o = r[a];
                  let s = !0;
                  for (let r = 0; r < p.length; r++)
                    i(o.p, p[r].p) &&
                      (n !== r && t.push({ froms: n, tos: r, hole: a }),
                      s ? ((s = !1), u[r].push(o)) : (e = !0));
                  s && u[n].push(o);
                }
              }
              t.length > 0 && (e || (m = u));
            }
            for (let e = 0, t = p.length; e < t; e++) {
              (c = p[e].s), l.push(c), (f = m[e]);
              for (let e = 0, t = f.length; e < t; e++) c.holes.push(f[e].h);
            }
            return l;
          },
        });
      class zs {
        constructor(e) {
          Object.defineProperty(this, "isFont", { value: !0 }),
            (this.type = "Font"),
            (this.data = e);
        }
        generateShapes(e, t = 100) {
          const n = [],
            i = (function (e, t, n) {
              const i = Array.from ? Array.from(e) : String(e).split(""),
                r = t / n.resolution,
                a =
                  (n.boundingBox.yMax -
                    n.boundingBox.yMin +
                    n.underlineThickness) *
                  r,
                o = [];
              let s = 0,
                c = 0;
              for (let e = 0; e < i.length; e++) {
                const t = i[e];
                if ("\n" === t) (s = 0), (c -= a);
                else {
                  const e = Us(t, r, s, c, n);
                  (s += e.offsetX), o.push(e.path);
                }
              }
              return o;
            })(e, t, this.data);
          for (let e = 0, t = i.length; e < t; e++)
            Array.prototype.push.apply(n, i[e].toShapes());
          return n;
        }
      }
      function Us(e, t, n, i, r) {
        const a = r.glyphs[e] || r.glyphs["?"];
        if (!a)
          return void console.error(
            'THREE.Font: character "' +
              e +
              '" does not exists in font family ' +
              r.familyName +
              "."
          );
        const o = new Bs();
        let s, c, l, h, u, p, d, f;
        if (a.o) {
          const e = a._cachedOutline || (a._cachedOutline = a.o.split(" "));
          for (let r = 0, a = e.length; r < a; )
            switch (e[r++]) {
              case "m":
                (s = e[r++] * t + n), (c = e[r++] * t + i), o.moveTo(s, c);
                break;
              case "l":
                (s = e[r++] * t + n), (c = e[r++] * t + i), o.lineTo(s, c);
                break;
              case "q":
                (l = e[r++] * t + n),
                  (h = e[r++] * t + i),
                  (u = e[r++] * t + n),
                  (p = e[r++] * t + i),
                  o.quadraticCurveTo(u, p, l, h);
                break;
              case "b":
                (l = e[r++] * t + n),
                  (h = e[r++] * t + i),
                  (u = e[r++] * t + n),
                  (p = e[r++] * t + i),
                  (d = e[r++] * t + n),
                  (f = e[r++] * t + i),
                  o.bezierCurveTo(u, p, d, f, l, h);
            }
        }
        return { offsetX: a.ha * t, path: o };
      }
      function Gs(e) {
        zo.call(this, e);
      }
      let Ws;
      Gs.prototype = Object.assign(Object.create(zo.prototype), {
        constructor: Gs,
        load: function (e, t, n, i) {
          const r = this,
            a = new Go(this.manager);
          a.setPath(this.path),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(r.withCredentials),
            a.load(
              e,
              function (e) {
                let n;
                try {
                  n = JSON.parse(e);
                } catch (t) {
                  console.warn(
                    "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                  ),
                    (n = JSON.parse(e.substring(65, e.length - 2)));
                }
                const i = r.parse(n);
                t && t(i);
              },
              n,
              i
            );
        },
        parse: function (e) {
          return new zs(e);
        },
      });
      function Vs(e) {
        zo.call(this, e);
      }
      function qs(e, t, n) {
        Cs.call(this, void 0, n);
        const i = new ut().set(e),
          r = new ut().set(t),
          a = new W(i.r, i.g, i.b),
          o = new W(r.r, r.g, r.b),
          s = Math.sqrt(Math.PI),
          c = s * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s),
          this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(c);
      }
      function Xs(e, t) {
        Cs.call(this, void 0, t);
        const n = new ut().set(e);
        this.sh.coefficients[0]
          .set(n.r, n.g, n.b)
          .multiplyScalar(2 * Math.sqrt(Math.PI));
      }
      (Vs.prototype = Object.assign(Object.create(zo.prototype), {
        constructor: Vs,
        load: function (e, t, n, i) {
          const r = this,
            a = new Go(r.manager);
          a.setResponseType("arraybuffer"),
            a.setPath(r.path),
            a.setRequestHeader(r.requestHeader),
            a.setWithCredentials(r.withCredentials),
            a.load(
              e,
              function (n) {
                try {
                  const e = n.slice(0);
                  (void 0 === Ws &&
                    (Ws = new (window.AudioContext ||
                      window.webkitAudioContext)()),
                  Ws).decodeAudioData(e, function (e) {
                    t(e);
                  });
                } catch (t) {
                  i ? i(t) : console.error(t), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        },
      })),
        (qs.prototype = Object.assign(Object.create(Cs.prototype), {
          constructor: qs,
          isHemisphereLightProbe: !0,
          copy: function (e) {
            return Cs.prototype.copy.call(this, e), this;
          },
          toJSON: function (e) {
            return Cs.prototype.toJSON.call(this, e);
          },
        })),
        (Xs.prototype = Object.assign(Object.create(Cs.prototype), {
          constructor: Xs,
          isAmbientLightProbe: !0,
          copy: function (e) {
            return Cs.prototype.copy.call(this, e), this;
          },
          toJSON: function (e) {
            return Cs.prototype.toJSON.call(this, e);
          },
        }));
      const Ys = new ye(),
        Js = new ye();
      Object.assign(
        function () {
          (this.type = "StereoCamera"),
            (this.aspect = 1),
            (this.eyeSep = 0.064),
            (this.cameraL = new pn()),
            this.cameraL.layers.enable(1),
            (this.cameraL.matrixAutoUpdate = !1),
            (this.cameraR = new pn()),
            this.cameraR.layers.enable(2),
            (this.cameraR.matrixAutoUpdate = !1),
            (this._cache = {
              focus: null,
              fov: null,
              aspect: null,
              near: null,
              far: null,
              zoom: null,
              eyeSep: null,
            });
        }.prototype,
        {
          update: function (e) {
            const t = this._cache;
            if (
              t.focus !== e.focus ||
              t.fov !== e.fov ||
              t.aspect !== e.aspect * this.aspect ||
              t.near !== e.near ||
              t.far !== e.far ||
              t.zoom !== e.zoom ||
              t.eyeSep !== this.eyeSep
            ) {
              (t.focus = e.focus),
                (t.fov = e.fov),
                (t.aspect = e.aspect * this.aspect),
                (t.near = e.near),
                (t.far = e.far),
                (t.zoom = e.zoom),
                (t.eyeSep = this.eyeSep);
              const n = e.projectionMatrix.clone(),
                i = t.eyeSep / 2,
                r = (i * t.near) / t.focus,
                a = (t.near * Math.tan(O.DEG2RAD * t.fov * 0.5)) / t.zoom;
              let o, s;
              (Js.elements[12] = -i),
                (Ys.elements[12] = i),
                (o = -a * t.aspect + r),
                (s = a * t.aspect + r),
                (n.elements[0] = (2 * t.near) / (s - o)),
                (n.elements[8] = (s + o) / (s - o)),
                this.cameraL.projectionMatrix.copy(n),
                (o = -a * t.aspect - r),
                (s = a * t.aspect - r),
                (n.elements[0] = (2 * t.near) / (s - o)),
                (n.elements[8] = (s + o) / (s - o)),
                this.cameraR.projectionMatrix.copy(n);
            }
            this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Js),
              this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Ys);
          },
        }
      );
      class Zs {
        constructor(e) {
          (this.autoStart = void 0 === e || e),
            (this.startTime = 0),
            (this.oldTime = 0),
            (this.elapsedTime = 0),
            (this.running = !1);
        }
        start() {
          (this.startTime = Qs()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        }
        stop() {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let e = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const t = Qs();
            (e = (t - this.oldTime) / 1e3),
              (this.oldTime = t),
              (this.elapsedTime += e);
          }
          return e;
        }
      }
      function Qs() {
        return ("undefined" == typeof performance ? Date : performance).now();
      }
      function Ks(e, t, n) {
        let i, r, a;
        switch (((this.binding = e), (this.valueSize = n), t)) {
          case "quaternion":
            (i = this._slerp),
              (r = this._slerpAdditive),
              (a = this._setAdditiveIdentityQuaternion),
              (this.buffer = new Float64Array(6 * n)),
              (this._workIndex = 5);
            break;
          case "string":
          case "bool":
            (i = this._select),
              (r = this._select),
              (a = this._setAdditiveIdentityOther),
              (this.buffer = new Array(5 * n));
            break;
          default:
            (i = this._lerp),
              (r = this._lerpAdditive),
              (a = this._setAdditiveIdentityNumeric),
              (this.buffer = new Float64Array(5 * n));
        }
        (this._mixBufferRegion = i),
          (this._mixBufferRegionAdditive = r),
          (this._setIdentity = a),
          (this._origIndex = 3),
          (this._addIndex = 4),
          (this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0),
          (this.useCount = 0),
          (this.referenceCount = 0);
      }
      Object.assign(Ks.prototype, {
        accumulate: function (e, t) {
          const n = this.buffer,
            i = this.valueSize,
            r = e * i + i;
          let a = this.cumulativeWeight;
          if (0 === a) {
            for (let e = 0; e !== i; ++e) n[r + e] = n[e];
            a = t;
          } else {
            a += t;
            const e = t / a;
            this._mixBufferRegion(n, r, 0, e, i);
          }
          this.cumulativeWeight = a;
        },
        accumulateAdditive: function (e) {
          const t = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex;
          0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(t, i, 0, e, n),
            (this.cumulativeWeightAdditive += e);
        },
        apply: function (e) {
          const t = this.valueSize,
            n = this.buffer,
            i = e * t + t,
            r = this.cumulativeWeight,
            a = this.cumulativeWeightAdditive,
            o = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            r < 1)
          ) {
            const e = t * this._origIndex;
            this._mixBufferRegion(n, i, e, 1 - r, t);
          }
          a > 0 &&
            this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
          for (let e = t, r = t + t; e !== r; ++e)
            if (n[e] !== n[e + t]) {
              o.setValue(n, i);
              break;
            }
        },
        saveOriginalState: function () {
          const e = this.binding,
            t = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex;
          e.getValue(t, i);
          for (let e = n, r = i; e !== r; ++e) t[e] = t[i + (e % n)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        },
        restoreOriginalState: function () {
          const e = 3 * this.valueSize;
          this.binding.setValue(this.buffer, e);
        },
        _setAdditiveIdentityNumeric: function () {
          const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
          for (let n = e; n < t; n++) this.buffer[n] = 0;
        },
        _setAdditiveIdentityQuaternion: function () {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        },
        _setAdditiveIdentityOther: function () {
          const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
          for (let n = 0; n < this.valueSize; n++)
            this.buffer[t + n] = this.buffer[e + n];
        },
        _select: function (e, t, n, i, r) {
          if (i >= 0.5) for (let i = 0; i !== r; ++i) e[t + i] = e[n + i];
        },
        _slerp: function (e, t, n, i) {
          G.slerpFlat(e, t, e, t, e, n, i);
        },
        _slerpAdditive: function (e, t, n, i, r) {
          const a = this._workIndex * r;
          G.multiplyQuaternionsFlat(e, a, e, t, e, n),
            G.slerpFlat(e, t, e, t, e, a, i);
        },
        _lerp: function (e, t, n, i, r) {
          const a = 1 - i;
          for (let o = 0; o !== r; ++o) {
            const r = t + o;
            e[r] = e[r] * a + e[n + o] * i;
          }
        },
        _lerpAdditive: function (e, t, n, i, r) {
          for (let a = 0; a !== r; ++a) {
            const r = t + a;
            e[r] = e[r] + e[n + a] * i;
          }
        },
      });
      const $s = new RegExp("[\\[\\]\\.:\\/]", "g"),
        ec = "[^\\[\\]\\.:\\/]",
        tc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        nc = /((?:WC+[\/:])*)/.source.replace("WC", ec),
        ic = /(WCOD+)?/.source.replace("WCOD", tc),
        rc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ec),
        ac = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ec),
        oc = new RegExp("^" + nc + ic + rc + ac + "$"),
        sc = ["material", "materials", "bones"];
      function cc(e, t, n) {
        const i = n || lc.parseTrackName(t);
        (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
      }
      function lc(e, t, n) {
        (this.path = t),
          (this.parsedPath = n || lc.parseTrackName(t)),
          (this.node = lc.findNode(e, this.parsedPath.nodeName) || e),
          (this.rootNode = e);
      }
      Object.assign(cc.prototype, {
        getValue: function (e, t) {
          this.bind();
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          void 0 !== i && i.getValue(e, t);
        },
        setValue: function (e, t) {
          const n = this._bindings;
          for (
            let i = this._targetGroup.nCachedObjects_, r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(e, t);
        },
        bind: function () {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].bind();
        },
        unbind: function () {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].unbind();
        },
      }),
        Object.assign(lc, {
          Composite: cc,
          create: function (e, t, n) {
            return e && e.isAnimationObjectGroup
              ? new lc.Composite(e, t, n)
              : new lc(e, t, n);
          },
          sanitizeNodeName: function (e) {
            return e.replace(/\s/g, "_").replace($s, "");
          },
          parseTrackName: function (e) {
            const t = oc.exec(e);
            if (!t)
              throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            const n = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6],
              },
              i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
              const e = n.nodeName.substring(i + 1);
              -1 !== sc.indexOf(e) &&
                ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = e));
            }
            if (null === n.propertyName || 0 === n.propertyName.length)
              throw new Error(
                "PropertyBinding: can not parse propertyName from trackName: " +
                  e
              );
            return n;
          },
          findNode: function (e, t) {
            if (
              !t ||
              "" === t ||
              "." === t ||
              -1 === t ||
              t === e.name ||
              t === e.uuid
            )
              return e;
            if (e.skeleton) {
              const n = e.skeleton.getBoneByName(t);
              if (void 0 !== n) return n;
            }
            if (e.children) {
              const n = function (e) {
                  for (let i = 0; i < e.length; i++) {
                    const r = e[i];
                    if (r.name === t || r.uuid === t) return r;
                    const a = n(r.children);
                    if (a) return a;
                  }
                  return null;
                },
                i = n(e.children);
              if (i) return i;
            }
            return null;
          },
        }),
        Object.assign(lc.prototype, {
          _getValue_unavailable: function () {},
          _setValue_unavailable: function () {},
          BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3,
          },
          Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
          GetterByBindingType: [
            function (e, t) {
              e[t] = this.node[this.propertyName];
            },
            function (e, t) {
              const n = this.resolvedProperty;
              for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
            },
            function (e, t) {
              e[t] = this.resolvedProperty[this.propertyIndex];
            },
            function (e, t) {
              this.resolvedProperty.toArray(e, t);
            },
          ],
          SetterByBindingTypeAndVersioning: [
            [
              function (e, t) {
                this.targetObject[this.propertyName] = e[t];
              },
              function (e, t) {
                (this.targetObject[this.propertyName] = e[t]),
                  (this.targetObject.needsUpdate = !0);
              },
              function (e, t) {
                (this.targetObject[this.propertyName] = e[t]),
                  (this.targetObject.matrixWorldNeedsUpdate = !0);
              },
            ],
            [
              function (e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
              },
              function (e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                this.targetObject.needsUpdate = !0;
              },
              function (e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0;
              },
            ],
            [
              function (e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t];
              },
              function (e, t) {
                (this.resolvedProperty[this.propertyIndex] = e[t]),
                  (this.targetObject.needsUpdate = !0);
              },
              function (e, t) {
                (this.resolvedProperty[this.propertyIndex] = e[t]),
                  (this.targetObject.matrixWorldNeedsUpdate = !0);
              },
            ],
            [
              function (e, t) {
                this.resolvedProperty.fromArray(e, t);
              },
              function (e, t) {
                this.resolvedProperty.fromArray(e, t),
                  (this.targetObject.needsUpdate = !0);
              },
              function (e, t) {
                this.resolvedProperty.fromArray(e, t),
                  (this.targetObject.matrixWorldNeedsUpdate = !0);
              },
            ],
          ],
          getValue: function (e, t) {
            this.bind(), this.getValue(e, t);
          },
          setValue: function (e, t) {
            this.bind(), this.setValue(e, t);
          },
          bind: function () {
            let e = this.node;
            const t = this.parsedPath,
              n = t.objectName,
              i = t.propertyName;
            let r = t.propertyIndex;
            if (
              (e ||
                ((e = lc.findNode(this.rootNode, t.nodeName) || this.rootNode),
                (this.node = e)),
              (this.getValue = this._getValue_unavailable),
              (this.setValue = this._setValue_unavailable),
              !e)
            )
              return void console.error(
                "THREE.PropertyBinding: Trying to update node for track: " +
                  this.path +
                  " but it wasn't found."
              );
            if (n) {
              let i = t.objectIndex;
              switch (n) {
                case "materials":
                  if (!e.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!e.material.materials)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this
                    );
                  e = e.material.materials;
                  break;
                case "bones":
                  if (!e.skeleton)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this
                    );
                  e = e.skeleton.bones;
                  for (let t = 0; t < e.length; t++)
                    if (e[t].name === i) {
                      i = t;
                      break;
                    }
                  break;
                default:
                  if (void 0 === e[n])
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this
                    );
                  e = e[n];
              }
              if (void 0 !== i) {
                if (void 0 === e[i])
                  return void console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    e
                  );
                e = e[i];
              }
            }
            const a = e[i];
            if (void 0 === a) {
              const n = t.nodeName;
              return void console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                  n +
                  "." +
                  i +
                  " but it wasn't found.",
                e
              );
            }
            let o = this.Versioning.None;
            (this.targetObject = e),
              void 0 !== e.needsUpdate
                ? (o = this.Versioning.NeedsUpdate)
                : void 0 !== e.matrixWorldNeedsUpdate &&
                  (o = this.Versioning.MatrixWorldNeedsUpdate);
            let s = this.BindingType.Direct;
            if (void 0 !== r) {
              if ("morphTargetInfluences" === i) {
                if (!e.geometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                    this
                  );
                if (!e.geometry.isBufferGeometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                    this
                  );
                if (!e.geometry.morphAttributes)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                void 0 !== e.morphTargetDictionary[r] &&
                  (r = e.morphTargetDictionary[r]);
              }
              (s = this.BindingType.ArrayElement),
                (this.resolvedProperty = a),
                (this.propertyIndex = r);
            } else
              void 0 !== a.fromArray && void 0 !== a.toArray
                ? ((s = this.BindingType.HasFromToArray),
                  (this.resolvedProperty = a))
                : Array.isArray(a)
                ? ((s = this.BindingType.EntireArray),
                  (this.resolvedProperty = a))
                : (this.propertyName = i);
            (this.getValue = this.GetterByBindingType[s]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[s][o]);
          },
          unbind: function () {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          },
        }),
        Object.assign(lc.prototype, {
          _getValue_unbound: lc.prototype.getValue,
          _setValue_unbound: lc.prototype.setValue,
        }),
        Object.assign(
          function () {
            (this.uuid = O.generateUUID()),
              (this._objects = Array.prototype.slice.call(arguments)),
              (this.nCachedObjects_ = 0);
            const e = {};
            this._indicesByUUID = e;
            for (let t = 0, n = arguments.length; t !== n; ++t)
              e[arguments[t].uuid] = t;
            (this._paths = []),
              (this._parsedPaths = []),
              (this._bindings = []),
              (this._bindingsIndicesByPath = {});
            const t = this;
            this.stats = {
              objects: {
                get total() {
                  return t._objects.length;
                },
                get inUse() {
                  return this.total - t.nCachedObjects_;
                },
              },
              get bindingsPerObject() {
                return t._bindings.length;
              },
            };
          }.prototype,
          {
            isAnimationObjectGroup: !0,
            add: function () {
              const e = this._objects,
                t = this._indicesByUUID,
                n = this._paths,
                i = this._parsedPaths,
                r = this._bindings,
                a = r.length;
              let o,
                s = e.length,
                c = this.nCachedObjects_;
              for (let l = 0, h = arguments.length; l !== h; ++l) {
                const h = arguments[l],
                  u = h.uuid;
                let p = t[u];
                if (void 0 === p) {
                  (p = s++), (t[u] = p), e.push(h);
                  for (let e = 0, t = a; e !== t; ++e)
                    r[e].push(new lc(h, n[e], i[e]));
                } else if (p < c) {
                  o = e[p];
                  const s = --c,
                    l = e[s];
                  (t[l.uuid] = p), (e[p] = l), (t[u] = s), (e[s] = h);
                  for (let e = 0, t = a; e !== t; ++e) {
                    const t = r[e],
                      a = t[s];
                    let o = t[p];
                    (t[p] = a),
                      void 0 === o && (o = new lc(h, n[e], i[e])),
                      (t[s] = o);
                  }
                } else
                  e[p] !== o &&
                    console.error(
                      "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                    );
              }
              this.nCachedObjects_ = c;
            },
            remove: function () {
              const e = this._objects,
                t = this._indicesByUUID,
                n = this._bindings,
                i = n.length;
              let r = this.nCachedObjects_;
              for (let a = 0, o = arguments.length; a !== o; ++a) {
                const o = arguments[a],
                  s = o.uuid,
                  c = t[s];
                if (void 0 !== c && c >= r) {
                  const a = r++,
                    l = e[a];
                  (t[l.uuid] = c), (e[c] = l), (t[s] = a), (e[a] = o);
                  for (let e = 0, t = i; e !== t; ++e) {
                    const t = n[e],
                      i = t[a],
                      r = t[c];
                    (t[c] = i), (t[a] = r);
                  }
                }
              }
              this.nCachedObjects_ = r;
            },
            uncache: function () {
              const e = this._objects,
                t = this._indicesByUUID,
                n = this._bindings,
                i = n.length;
              let r = this.nCachedObjects_,
                a = e.length;
              for (let o = 0, s = arguments.length; o !== s; ++o) {
                const s = arguments[o].uuid,
                  c = t[s];
                if (void 0 !== c)
                  if ((delete t[s], c < r)) {
                    const o = --r,
                      s = e[o],
                      l = --a,
                      h = e[l];
                    (t[s.uuid] = c),
                      (e[c] = s),
                      (t[h.uuid] = o),
                      (e[o] = h),
                      e.pop();
                    for (let e = 0, t = i; e !== t; ++e) {
                      const t = n[e],
                        i = t[o],
                        r = t[l];
                      (t[c] = i), (t[o] = r), t.pop();
                    }
                  } else {
                    const r = --a,
                      o = e[r];
                    r > 0 && (t[o.uuid] = c), (e[c] = o), e.pop();
                    for (let e = 0, t = i; e !== t; ++e) {
                      const t = n[e];
                      (t[c] = t[r]), t.pop();
                    }
                  }
              }
              this.nCachedObjects_ = r;
            },
            subscribe_: function (e, t) {
              const n = this._bindingsIndicesByPath;
              let i = n[e];
              const r = this._bindings;
              if (void 0 !== i) return r[i];
              const a = this._paths,
                o = this._parsedPaths,
                s = this._objects,
                c = s.length,
                l = this.nCachedObjects_,
                h = new Array(c);
              (i = r.length), (n[e] = i), a.push(e), o.push(t), r.push(h);
              for (let n = l, i = s.length; n !== i; ++n) {
                const i = s[n];
                h[n] = new lc(i, e, t);
              }
              return h;
            },
            unsubscribe_: function (e) {
              const t = this._bindingsIndicesByPath,
                n = t[e];
              if (void 0 !== n) {
                const i = this._paths,
                  r = this._parsedPaths,
                  a = this._bindings,
                  o = a.length - 1,
                  s = a[o];
                (t[e[o]] = n),
                  (a[n] = s),
                  a.pop(),
                  (r[n] = r[o]),
                  r.pop(),
                  (i[n] = i[o]),
                  i.pop();
              }
            },
          }
        );
      class hc {
        constructor(e, t, n = null, i = t.blendMode) {
          (this._mixer = e),
            (this._clip = t),
            (this._localRoot = n),
            (this.blendMode = i);
          const r = t.tracks,
            a = r.length,
            o = new Array(a),
            s = { endingStart: x, endingEnd: x };
          for (let e = 0; e !== a; ++e) {
            const t = r[e].createInterpolant(null);
            (o[e] = t), (t.settings = s);
          }
          (this._interpolantSettings = s),
            (this._interpolants = o),
            (this._propertyBindings = new Array(a)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = 2201),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(e) {
          return (this._startTime = e), this;
        }
        setLoop(e, t) {
          return (this.loop = e), (this.repetitions = t), this;
        }
        setEffectiveWeight(e) {
          return (
            (this.weight = e),
            (this._effectiveWeight = this.enabled ? e : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(e) {
          return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
          return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, n) {
          if ((e.fadeOut(t), this.fadeIn(t), n)) {
            const n = this._clip.duration,
              i = e._clip.duration,
              r = i / n,
              a = n / i;
            e.warp(1, r, t), this.warp(a, 1, t);
          }
          return this;
        }
        crossFadeTo(e, t, n) {
          return e.crossFadeFrom(this, t, n);
        }
        stopFading() {
          const e = this._weightInterpolant;
          return (
            null !== e &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        setEffectiveTimeScale(e) {
          return (
            (this.timeScale = e),
            (this._effectiveTimeScale = this.paused ? 0 : e),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(e) {
          return (this.timeScale = this._clip.duration / e), this.stopWarping();
        }
        syncWith(e) {
          return (
            (this.time = e.time),
            (this.timeScale = e.timeScale),
            this.stopWarping()
          );
        }
        halt(e) {
          return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, n) {
          const i = this._mixer,
            r = i.time,
            a = this.timeScale;
          let o = this._timeScaleInterpolant;
          null === o &&
            ((o = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = o));
          const s = o.parameterPositions,
            c = o.sampleValues;
          return (
            (s[0] = r), (s[1] = r + n), (c[0] = e / a), (c[1] = t / a), this
          );
        }
        stopWarping() {
          const e = this._timeScaleInterpolant;
          return (
            null !== e &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(e, t, n, i) {
          if (!this.enabled) return void this._updateWeight(e);
          const r = this._startTime;
          if (null !== r) {
            const i = (e - r) * n;
            if (i < 0 || 0 === n) return;
            (this._startTime = null), (t = n * i);
          }
          t *= this._updateTimeScale(e);
          const a = this._updateTime(t),
            o = this._updateWeight(e);
          if (o > 0) {
            const e = this._interpolants,
              t = this._propertyBindings;
            switch (this.blendMode) {
              case 2501:
                for (let n = 0, i = e.length; n !== i; ++n)
                  e[n].evaluate(a), t[n].accumulateAdditive(o);
                break;
              case 2500:
              default:
                for (let n = 0, r = e.length; n !== r; ++n)
                  e[n].evaluate(a), t[n].accumulate(i, o);
            }
          }
        }
        _updateWeight(e) {
          let t = 0;
          if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (null !== n) {
              const i = n.evaluate(e)[0];
              (t *= i),
                e > n.parameterPositions[1] &&
                  (this.stopFading(), 0 === i && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = t), t;
        }
        _updateTimeScale(e) {
          let t = 0;
          if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            null !== n &&
              ((t *= n.evaluate(e)[0]),
              e > n.parameterPositions[1] &&
                (this.stopWarping(),
                0 === t ? (this.paused = !0) : (this.timeScale = t)));
          }
          return (this._effectiveTimeScale = t), t;
        }
        _updateTime(e) {
          const t = this._clip.duration,
            n = this.loop;
          let i = this.time + e,
            r = this._loopCount;
          const a = 2202 === n;
          if (0 === e) return -1 === r ? i : a && 1 == (1 & r) ? t - i : i;
          if (2200 === n) {
            -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            e: {
              if (i >= t) i = t;
              else {
                if (!(i < 0)) {
                  this.time = i;
                  break e;
                }
                i = 0;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (-1 === r &&
                (e >= 0
                  ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, a))
                  : this._setEndings(0 === this.repetitions, !0, a)),
              i >= t || i < 0)
            ) {
              const n = Math.floor(i / t);
              (i -= t * n), (r += Math.abs(n));
              const o = this.repetitions - r;
              if (o <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (i = e > 0 ? t : 0),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1,
                  });
              else {
                if (1 === o) {
                  const t = e < 0;
                  this._setEndings(t, !t, a);
                } else this._setEndings(!1, !1, a);
                (this._loopCount = r),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: n,
                  });
              }
            } else this.time = i;
            if (a && 1 == (1 & r)) return t - i;
          }
          return i;
        }
        _setEndings(e, t, n) {
          const i = this._interpolantSettings;
          n
            ? ((i.endingStart = b), (i.endingEnd = b))
            : ((i.endingStart = e ? (this.zeroSlopeAtStart ? b : x) : M),
              (i.endingEnd = t ? (this.zeroSlopeAtEnd ? b : x) : M));
        }
        _scheduleFading(e, t, n) {
          const i = this._mixer,
            r = i.time;
          let a = this._weightInterpolant;
          null === a &&
            ((a = i._lendControlInterpolant()), (this._weightInterpolant = a));
          const o = a.parameterPositions,
            s = a.sampleValues;
          return (o[0] = r), (s[0] = t), (o[1] = r + e), (s[1] = n), this;
        }
      }
      function uc(e) {
        (this._root = e),
          this._initMemoryManager(),
          (this._accuIndex = 0),
          (this.time = 0),
          (this.timeScale = 1);
      }
      uc.prototype = Object.assign(Object.create(R.prototype), {
        constructor: uc,
        _bindAction: function (e, t) {
          const n = e._localRoot || this._root,
            i = e._clip.tracks,
            r = i.length,
            a = e._propertyBindings,
            o = e._interpolants,
            s = n.uuid,
            c = this._bindingsByRootAndName;
          let l = c[s];
          void 0 === l && ((l = {}), (c[s] = l));
          for (let e = 0; e !== r; ++e) {
            const r = i[e],
              c = r.name;
            let h = l[c];
            if (void 0 !== h) a[e] = h;
            else {
              if (((h = a[e]), void 0 !== h)) {
                null === h._cacheIndex &&
                  (++h.referenceCount, this._addInactiveBinding(h, s, c));
                continue;
              }
              const i = t && t._propertyBindings[e].binding.parsedPath;
              (h = new Ks(
                lc.create(n, c, i),
                r.ValueTypeName,
                r.getValueSize()
              )),
                ++h.referenceCount,
                this._addInactiveBinding(h, s, c),
                (a[e] = h);
            }
            o[e].resultBuffer = h.buffer;
          }
        },
        _activateAction: function (e) {
          if (!this._isActiveAction(e)) {
            if (null === e._cacheIndex) {
              const t = (e._localRoot || this._root).uuid,
                n = e._clip.uuid,
                i = this._actionsByClip[n];
              this._bindAction(e, i && i.knownActions[0]),
                this._addInactiveAction(e, n, t);
            }
            const t = e._propertyBindings;
            for (let e = 0, n = t.length; e !== n; ++e) {
              const n = t[e];
              0 == n.useCount++ &&
                (this._lendBinding(n), n.saveOriginalState());
            }
            this._lendAction(e);
          }
        },
        _deactivateAction: function (e) {
          if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let e = 0, n = t.length; e !== n; ++e) {
              const n = t[e];
              0 == --n.useCount &&
                (n.restoreOriginalState(), this._takeBackBinding(n));
            }
            this._takeBackAction(e);
          }
        },
        _initMemoryManager: function () {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const e = this;
          this.stats = {
            actions: {
              get total() {
                return e._actions.length;
              },
              get inUse() {
                return e._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return e._bindings.length;
              },
              get inUse() {
                return e._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return e._controlInterpolants.length;
              },
              get inUse() {
                return e._nActiveControlInterpolants;
              },
            },
          };
        },
        _isActiveAction: function (e) {
          const t = e._cacheIndex;
          return null !== t && t < this._nActiveActions;
        },
        _addInactiveAction: function (e, t, n) {
          const i = this._actions,
            r = this._actionsByClip;
          let a = r[t];
          if (void 0 === a)
            (a = { knownActions: [e], actionByRoot: {} }),
              (e._byClipCacheIndex = 0),
              (r[t] = a);
          else {
            const t = a.knownActions;
            (e._byClipCacheIndex = t.length), t.push(e);
          }
          (e._cacheIndex = i.length), i.push(e), (a.actionByRoot[n] = e);
        },
        _removeInactiveAction: function (e) {
          const t = this._actions,
            n = t[t.length - 1],
            i = e._cacheIndex;
          (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
          const r = e._clip.uuid,
            a = this._actionsByClip,
            o = a[r],
            s = o.knownActions,
            c = s[s.length - 1],
            l = e._byClipCacheIndex;
          (c._byClipCacheIndex = l),
            (s[l] = c),
            s.pop(),
            (e._byClipCacheIndex = null),
            delete o.actionByRoot[(e._localRoot || this._root).uuid],
            0 === s.length && delete a[r],
            this._removeInactiveBindingsForAction(e);
        },
        _removeInactiveBindingsForAction: function (e) {
          const t = e._propertyBindings;
          for (let e = 0, n = t.length; e !== n; ++e) {
            const n = t[e];
            0 == --n.referenceCount && this._removeInactiveBinding(n);
          }
        },
        _lendAction: function (e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = this._nActiveActions++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        },
        _takeBackAction: function (e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = --this._nActiveActions,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        },
        _addInactiveBinding: function (e, t, n) {
          const i = this._bindingsByRootAndName,
            r = this._bindings;
          let a = i[t];
          void 0 === a && ((a = {}), (i[t] = a)),
            (a[n] = e),
            (e._cacheIndex = r.length),
            r.push(e);
        },
        _removeInactiveBinding: function (e) {
          const t = this._bindings,
            n = e.binding,
            i = n.rootNode.uuid,
            r = n.path,
            a = this._bindingsByRootAndName,
            o = a[i],
            s = t[t.length - 1],
            c = e._cacheIndex;
          (s._cacheIndex = c),
            (t[c] = s),
            t.pop(),
            delete o[r],
            0 === Object.keys(o).length && delete a[i];
        },
        _lendBinding: function (e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = this._nActiveBindings++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        },
        _takeBackBinding: function (e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = --this._nActiveBindings,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        },
        _lendControlInterpolant: function () {
          const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
          let n = e[t];
          return (
            void 0 === n &&
              ((n = new Ao(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )),
              (n.__cacheIndex = t),
              (e[t] = n)),
            n
          );
        },
        _takeBackControlInterpolant: function (e) {
          const t = this._controlInterpolants,
            n = e.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = t[i];
          (e.__cacheIndex = i), (t[i] = e), (r.__cacheIndex = n), (t[n] = r);
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function (e, t, n) {
          const i = t || this._root,
            r = i.uuid;
          let a = "string" == typeof e ? jo.findByName(i, e) : e;
          const o = null !== a ? a.uuid : e,
            s = this._actionsByClip[o];
          let c = null;
          if (
            (void 0 === n && (n = null !== a ? a.blendMode : 2500),
            void 0 !== s)
          ) {
            const e = s.actionByRoot[r];
            if (void 0 !== e && e.blendMode === n) return e;
            (c = s.knownActions[0]), null === a && (a = c._clip);
          }
          if (null === a) return null;
          const l = new hc(this, a, t, n);
          return this._bindAction(l, c), this._addInactiveAction(l, o, r), l;
        },
        existingAction: function (e, t) {
          const n = t || this._root,
            i = n.uuid,
            r = "string" == typeof e ? jo.findByName(n, e) : e,
            a = r ? r.uuid : e,
            o = this._actionsByClip[a];
          return (void 0 !== o && o.actionByRoot[i]) || null;
        },
        stopAllAction: function () {
          const e = this._actions;
          for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
          return this;
        },
        update: function (e) {
          e *= this.timeScale;
          const t = this._actions,
            n = this._nActiveActions,
            i = (this.time += e),
            r = Math.sign(e),
            a = (this._accuIndex ^= 1);
          for (let o = 0; o !== n; ++o) t[o]._update(i, e, r, a);
          const o = this._bindings,
            s = this._nActiveBindings;
          for (let e = 0; e !== s; ++e) o[e].apply(a);
          return this;
        },
        setTime: function (e) {
          this.time = 0;
          for (let e = 0; e < this._actions.length; e++)
            this._actions[e].time = 0;
          return this.update(e);
        },
        getRoot: function () {
          return this._root;
        },
        uncacheClip: function (e) {
          const t = this._actions,
            n = e.uuid,
            i = this._actionsByClip,
            r = i[n];
          if (void 0 !== r) {
            const e = r.knownActions;
            for (let n = 0, i = e.length; n !== i; ++n) {
              const i = e[n];
              this._deactivateAction(i);
              const r = i._cacheIndex,
                a = t[t.length - 1];
              (i._cacheIndex = null),
                (i._byClipCacheIndex = null),
                (a._cacheIndex = r),
                (t[r] = a),
                t.pop(),
                this._removeInactiveBindingsForAction(i);
            }
            delete i[n];
          }
        },
        uncacheRoot: function (e) {
          const t = e.uuid,
            n = this._actionsByClip;
          for (const e in n) {
            const i = n[e].actionByRoot[t];
            void 0 !== i &&
              (this._deactivateAction(i), this._removeInactiveAction(i));
          }
          const i = this._bindingsByRootAndName[t];
          if (void 0 !== i)
            for (const e in i) {
              const t = i[e];
              t.restoreOriginalState(), this._removeInactiveBinding(t);
            }
        },
        uncacheAction: function (e, t) {
          const n = this.existingAction(e, t);
          null !== n &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        },
      });
      class pc {
        constructor(e) {
          "string" == typeof e &&
            (console.warn("THREE.Uniform: Type parameter is no longer needed."),
            (e = arguments[1])),
            (this.value = e);
        }
        clone() {
          return new pc(
            void 0 === this.value.clone ? this.value : this.value.clone()
          );
        }
      }
      function dc(e, t, n) {
        Rr.call(this, e, t), (this.meshPerAttribute = n || 1);
      }
      function fc(e, t, n, i, r) {
        (this.buffer = e),
          (this.type = t),
          (this.itemSize = n),
          (this.elementSize = i),
          (this.count = r),
          (this.version = 0);
      }
      function mc(e, t, n, i) {
        (this.ray = new ve(e, t)),
          (this.near = n || 0),
          (this.far = i || 1 / 0),
          (this.camera = null),
          (this.layers = new Pe()),
          (this.params = {
            Mesh: {},
            Line: { threshold: 1 },
            LOD: {},
            Points: { threshold: 1 },
            Sprite: {},
          }),
          Object.defineProperties(this.params, {
            PointCloud: {
              get: function () {
                return (
                  console.warn(
                    "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
                  ),
                  this.Points
                );
              },
            },
          });
      }
      function gc(e, t) {
        return e.distance - t.distance;
      }
      function vc(e, t, n, i) {
        if ((e.layers.test(t.layers) && e.raycast(t, n), !0 === i)) {
          const i = e.children;
          for (let e = 0, r = i.length; e < r; e++) vc(i[e], t, n, !0);
        }
      }
      (dc.prototype = Object.assign(Object.create(Rr.prototype), {
        constructor: dc,
        isInstancedInterleavedBuffer: !0,
        copy: function (e) {
          return (
            Rr.prototype.copy.call(this, e),
            (this.meshPerAttribute = e.meshPerAttribute),
            this
          );
        },
        clone: function (e) {
          const t = Rr.prototype.clone.call(this, e);
          return (t.meshPerAttribute = this.meshPerAttribute), t;
        },
        toJSON: function (e) {
          const t = Rr.prototype.toJSON.call(this, e);
          return (
            (t.isInstancedInterleavedBuffer = !0),
            (t.meshPerAttribute = this.meshPerAttribute),
            t
          );
        },
      })),
        Object.defineProperty(fc.prototype, "needsUpdate", {
          set: function (e) {
            !0 === e && this.version++;
          },
        }),
        Object.assign(fc.prototype, {
          isGLBufferAttribute: !0,
          setBuffer: function (e) {
            return (this.buffer = e), this;
          },
          setType: function (e, t) {
            return (this.type = e), (this.elementSize = t), this;
          },
          setItemSize: function (e) {
            return (this.itemSize = e), this;
          },
          setCount: function (e) {
            return (this.count = e), this;
          },
        }),
        Object.assign(mc.prototype, {
          set: function (e, t) {
            this.ray.set(e, t);
          },
          setFromCamera: function (e, t) {
            t && t.isPerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                this.ray.direction
                  .set(e.x, e.y, 0.5)
                  .unproject(t)
                  .sub(this.ray.origin)
                  .normalize(),
                (this.camera = t))
              : t && t.isOrthographicCamera
              ? (this.ray.origin
                  .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
                  .unproject(t),
                this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(t.matrixWorld),
                (this.camera = t))
              : console.error(
                  "THREE.Raycaster: Unsupported camera type: " + t.type
                );
          },
          intersectObject: function (e, t, n) {
            const i = n || [];
            return vc(e, this, i, t), i.sort(gc), i;
          },
          intersectObjects: function (e, t, n) {
            const i = n || [];
            if (!1 === Array.isArray(e))
              return (
                console.warn(
                  "THREE.Raycaster.intersectObjects: objects is not an Array."
                ),
                i
              );
            for (let n = 0, r = e.length; n < r; n++) vc(e[n], this, i, t);
            return i.sort(gc), i;
          },
        });
      const yc = new N(),
        _c = new W(),
        wc = new W();
      function xc(e) {
        Ge.call(this),
          (this.material = e),
          (this.render = function () {}),
          (this.hasPositions = !1),
          (this.hasNormals = !1),
          (this.hasColors = !1),
          (this.hasUvs = !1),
          (this.positionArray = null),
          (this.normalArray = null),
          (this.colorArray = null),
          (this.uvArray = null),
          (this.count = 0);
      }
      (xc.prototype = Object.create(Ge.prototype)),
        (xc.prototype.constructor = xc),
        (xc.prototype.isImmediateRenderObject = !0);
      const bc = new W(),
        Mc = new ye(),
        Sc = new ye();
      function Tc(e) {
        const t = [];
        e && e.isBone && t.push(e);
        for (let n = 0; n < e.children.length; n++)
          t.push.apply(t, Tc(e.children[n]));
        return t;
      }
      const Ec = new Float32Array(1),
        Ac =
          (new Int32Array(Ec.buffer),
          Math.pow(2, 8),
          [0.125, 0.215, 0.35, 0.446, 0.526, 0.582]),
        Lc = 5 + Ac.length,
        Pc = new mt({ side: 1, depthWrite: !1, depthTest: !1 }),
        {
          _lodPlanes: Rc,
          _sizeLods: kc,
          _sigmas: Cc,
        } = (new rn(new on(), Pc), Oc());
      function Oc() {
        const e = [],
          t = [],
          n = [];
        let i = 8;
        for (let r = 0; r < Lc; r++) {
          const a = Math.pow(2, i);
          t.push(a);
          let o = 1 / a;
          r > 4 ? (o = Ac[r - 8 + 4 - 1]) : 0 == r && (o = 0), n.push(o);
          const s = 1 / (a - 1),
            c = -s / 2,
            l = 1 + s / 2,
            h = [c, c, l, c, l, l, c, c, l, l, c, l],
            u = 6,
            p = 6,
            d = 3,
            f = 2,
            m = 1,
            g = new Float32Array(d * p * u),
            v = new Float32Array(f * p * u),
            y = new Float32Array(m * p * u);
          for (let e = 0; e < u; e++) {
            const t = ((e % 3) * 2) / 3 - 1,
              n = e > 2 ? 0 : -1,
              i = [
                t,
                n,
                0,
                t + 2 / 3,
                n,
                0,
                t + 2 / 3,
                n + 1,
                0,
                t,
                n,
                0,
                t + 2 / 3,
                n + 1,
                0,
                t,
                n + 1,
                0,
              ];
            g.set(i, d * p * e), v.set(h, f * p * e);
            const r = [e, e, e, e, e, e];
            y.set(r, m * p * e);
          }
          const _ = new Ht();
          _.setAttribute("position", new yt(g, d)),
            _.setAttribute("uv", new yt(v, f)),
            _.setAttribute("faceIndex", new yt(y, m)),
            e.push(_),
            i > 4 && i--;
        }
        return { _lodPlanes: e, _sizeLods: t, _sigmas: n };
      }
      function Nc(e) {
        console.warn(
          "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
        ),
          rs.call(this, e),
          (this.type = "catmullrom");
      }
      Math.sqrt(5),
        (Zo.create = function (e, t) {
          return (
            console.log("THREE.Curve.create() has been deprecated"),
            (e.prototype = Object.create(Zo.prototype)),
            (e.prototype.constructor = e),
            (e.prototype.getPoint = t),
            e
          );
        }),
        Object.assign(vs.prototype, {
          fromPoints: function (e) {
            return (
              console.warn(
                "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
              ),
              this.setFromPoints(e)
            );
          },
        }),
        Object.create(rs.prototype),
        Object.create(rs.prototype),
        (Nc.prototype = Object.create(rs.prototype)),
        Object.assign(Nc.prototype, {
          initFromArray: function () {
            console.error("THREE.Spline: .initFromArray() has been removed.");
          },
          getControlPointsArray: function () {
            console.error(
              "THREE.Spline: .getControlPointsArray() has been removed."
            );
          },
          reparametrizeByArcLength: function () {
            console.error(
              "THREE.Spline: .reparametrizeByArcLength() has been removed."
            );
          },
        }),
        (class extends ba {
          constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
            (n = new ut(n)), (i = new ut(i));
            const r = t / 2,
              a = e / t,
              o = e / 2,
              s = [],
              c = [];
            for (let e = 0, l = 0, h = -o; e <= t; e++, h += a) {
              s.push(-o, 0, h, o, 0, h), s.push(h, 0, -o, h, 0, o);
              const t = e === r ? n : i;
              t.toArray(c, l),
                (l += 3),
                t.toArray(c, l),
                (l += 3),
                t.toArray(c, l),
                (l += 3),
                t.toArray(c, l),
                (l += 3);
            }
            const l = new Ht();
            l.setAttribute("position", new At(s, 3)),
              l.setAttribute("color", new At(c, 3)),
              super(l, new da({ vertexColors: !0, toneMapped: !1 })),
              (this.type = "GridHelper");
          }
        }.prototype.setColors = function () {
          console.error(
            "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
          );
        }),
        (class extends ba {
          constructor(e) {
            const t = Tc(e),
              n = new Ht(),
              i = [],
              r = [],
              a = new ut(0, 0, 1),
              o = new ut(0, 1, 0);
            for (let e = 0; e < t.length; e++) {
              const n = t[e];
              n.parent &&
                n.parent.isBone &&
                (i.push(0, 0, 0),
                i.push(0, 0, 0),
                r.push(a.r, a.g, a.b),
                r.push(o.r, o.g, o.b));
            }
            n.setAttribute("position", new At(i, 3)),
              n.setAttribute("color", new At(r, 3)),
              super(
                n,
                new da({
                  vertexColors: !0,
                  depthTest: !1,
                  depthWrite: !1,
                  toneMapped: !1,
                  transparent: !0,
                })
              ),
              (this.type = "SkeletonHelper"),
              (this.isSkeletonHelper = !0),
              (this.root = e),
              (this.bones = t),
              (this.matrix = e.matrixWorld),
              (this.matrixAutoUpdate = !1);
          }
          updateMatrixWorld(e) {
            const t = this.bones,
              n = this.geometry,
              i = n.getAttribute("position");
            Sc.copy(this.root.matrixWorld).invert();
            for (let e = 0, n = 0; e < t.length; e++) {
              const r = t[e];
              r.parent &&
                r.parent.isBone &&
                (Mc.multiplyMatrices(Sc, r.matrixWorld),
                bc.setFromMatrixPosition(Mc),
                i.setXYZ(n, bc.x, bc.y, bc.z),
                Mc.multiplyMatrices(Sc, r.parent.matrixWorld),
                bc.setFromMatrixPosition(Mc),
                i.setXYZ(n + 1, bc.x, bc.y, bc.z),
                (n += 2));
            }
            (n.getAttribute("position").needsUpdate = !0),
              super.updateMatrixWorld(e);
          }
        }.prototype.update = function () {
          console.error(
            "THREE.SkeletonHelper: update() no longer needs to be called."
          );
        }),
        Object.assign(zo.prototype, {
          extractUrlBase: function (e) {
            return (
              console.warn(
                "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
              ),
              Is(e)
            );
          },
        }),
        (zo.Handlers = {
          add: function () {
            console.error(
              "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
            );
          },
          get: function () {
            console.error(
              "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
            );
          },
        }),
        Object.assign(
          class {
            constructor(e, t) {
              Object.defineProperty(this, "isBox2", { value: !0 }),
                (this.min = void 0 !== e ? e : new N(1 / 0, 1 / 0)),
                (this.max = void 0 !== t ? t : new N(-1 / 0, -1 / 0));
            }
            set(e, t) {
              return this.min.copy(e), this.max.copy(t), this;
            }
            setFromPoints(e) {
              this.makeEmpty();
              for (let t = 0, n = e.length; t < n; t++)
                this.expandByPoint(e[t]);
              return this;
            }
            setFromCenterAndSize(e, t) {
              const n = yc.copy(t).multiplyScalar(0.5);
              return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
            }
            clone() {
              return new this.constructor().copy(this);
            }
            copy(e) {
              return this.min.copy(e.min), this.max.copy(e.max), this;
            }
            makeEmpty() {
              return (
                (this.min.x = this.min.y = 1 / 0),
                (this.max.x = this.max.y = -1 / 0),
                this
              );
            }
            isEmpty() {
              return this.max.x < this.min.x || this.max.y < this.min.y;
            }
            getCenter(e) {
              return (
                void 0 === e &&
                  (console.warn(
                    "THREE.Box2: .getCenter() target is now required"
                  ),
                  (e = new N())),
                this.isEmpty()
                  ? e.set(0, 0)
                  : e.addVectors(this.min, this.max).multiplyScalar(0.5)
              );
            }
            getSize(e) {
              return (
                void 0 === e &&
                  (console.warn(
                    "THREE.Box2: .getSize() target is now required"
                  ),
                  (e = new N())),
                this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
              );
            }
            expandByPoint(e) {
              return this.min.min(e), this.max.max(e), this;
            }
            expandByVector(e) {
              return this.min.sub(e), this.max.add(e), this;
            }
            expandByScalar(e) {
              return this.min.addScalar(-e), this.max.addScalar(e), this;
            }
            containsPoint(e) {
              return !(
                e.x < this.min.x ||
                e.x > this.max.x ||
                e.y < this.min.y ||
                e.y > this.max.y
              );
            }
            containsBox(e) {
              return (
                this.min.x <= e.min.x &&
                e.max.x <= this.max.x &&
                this.min.y <= e.min.y &&
                e.max.y <= this.max.y
              );
            }
            getParameter(e, t) {
              return (
                void 0 === t &&
                  (console.warn(
                    "THREE.Box2: .getParameter() target is now required"
                  ),
                  (t = new N())),
                t.set(
                  (e.x - this.min.x) / (this.max.x - this.min.x),
                  (e.y - this.min.y) / (this.max.y - this.min.y)
                )
              );
            }
            intersectsBox(e) {
              return !(
                e.max.x < this.min.x ||
                e.min.x > this.max.x ||
                e.max.y < this.min.y ||
                e.min.y > this.max.y
              );
            }
            clampPoint(e, t) {
              return (
                void 0 === t &&
                  (console.warn(
                    "THREE.Box2: .clampPoint() target is now required"
                  ),
                  (t = new N())),
                t.copy(e).clamp(this.min, this.max)
              );
            }
            distanceToPoint(e) {
              return yc.copy(e).clamp(this.min, this.max).sub(e).length();
            }
            intersect(e) {
              return this.min.max(e.min), this.max.min(e.max), this;
            }
            union(e) {
              return this.min.min(e.min), this.max.max(e.max), this;
            }
            translate(e) {
              return this.min.add(e), this.max.add(e), this;
            }
            equals(e) {
              return e.min.equals(this.min) && e.max.equals(this.max);
            }
          }.prototype,
          {
            center: function (e) {
              return (
                console.warn(
                  "THREE.Box2: .center() has been renamed to .getCenter()."
                ),
                this.getCenter(e)
              );
            },
            empty: function () {
              return (
                console.warn(
                  "THREE.Box2: .empty() has been renamed to .isEmpty()."
                ),
                this.isEmpty()
              );
            },
            isIntersectionBox: function (e) {
              return (
                console.warn(
                  "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
                ),
                this.intersectsBox(e)
              );
            },
            size: function (e) {
              return (
                console.warn(
                  "THREE.Box2: .size() has been renamed to .getSize()."
                ),
                this.getSize(e)
              );
            },
          }
        ),
        Object.assign(X.prototype, {
          center: function (e) {
            return (
              console.warn(
                "THREE.Box3: .center() has been renamed to .getCenter()."
              ),
              this.getCenter(e)
            );
          },
          empty: function () {
            return (
              console.warn(
                "THREE.Box3: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          },
          isIntersectionBox: function (e) {
            return (
              console.warn(
                "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(e)
            );
          },
          isIntersectionSphere: function (e) {
            return (
              console.warn(
                "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
              ),
              this.intersectsSphere(e)
            );
          },
          size: function (e) {
            return (
              console.warn(
                "THREE.Box3: .size() has been renamed to .getSize()."
              ),
              this.getSize(e)
            );
          },
        }),
        Object.assign(le.prototype, {
          empty: function () {
            return (
              console.warn(
                "THREE.Sphere: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          },
        }),
        (wn.prototype.setFromMatrix = function (e) {
          return (
            console.warn(
              "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
            ),
            this.setFromProjectionMatrix(e)
          );
        }),
        (class {
          constructor(e, t) {
            (this.start = void 0 !== e ? e : new W()),
              (this.end = void 0 !== t ? t : new W());
          }
          set(e, t) {
            return this.start.copy(e), this.end.copy(t), this;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(e) {
            return this.start.copy(e.start), this.end.copy(e.end), this;
          }
          getCenter(e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Line3: .getCenter() target is now required"
                ),
                (e = new W())),
              e.addVectors(this.start, this.end).multiplyScalar(0.5)
            );
          }
          delta(e) {
            return (
              void 0 === e &&
                (console.warn("THREE.Line3: .delta() target is now required"),
                (e = new W())),
              e.subVectors(this.end, this.start)
            );
          }
          distanceSq() {
            return this.start.distanceToSquared(this.end);
          }
          distance() {
            return this.start.distanceTo(this.end);
          }
          at(e, t) {
            return (
              void 0 === t &&
                (console.warn("THREE.Line3: .at() target is now required"),
                (t = new W())),
              this.delta(t).multiplyScalar(e).add(this.start)
            );
          }
          closestPointToPointParameter(e, t) {
            _c.subVectors(e, this.start), wc.subVectors(this.end, this.start);
            const n = wc.dot(wc);
            let i = wc.dot(_c) / n;
            return t && (i = O.clamp(i, 0, 1)), i;
          }
          closestPointToPoint(e, t, n) {
            const i = this.closestPointToPointParameter(e, t);
            return (
              void 0 === n &&
                (console.warn(
                  "THREE.Line3: .closestPointToPoint() target is now required"
                ),
                (n = new W())),
              this.delta(n).multiplyScalar(i).add(this.start)
            );
          }
          applyMatrix4(e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
          }
          equals(e) {
            return e.start.equals(this.start) && e.end.equals(this.end);
          }
        }.prototype.center = function (e) {
          return (
            console.warn(
              "THREE.Line3: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(e)
          );
        }),
        Object.assign(O, {
          random16: function () {
            return (
              console.warn(
                "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
              ),
              Math.random()
            );
          },
          nearestPowerOfTwo: function (e) {
            return (
              console.warn(
                "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
              ),
              O.floorPowerOfTwo(e)
            );
          },
          nextPowerOfTwo: function (e) {
            return (
              console.warn(
                "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
              ),
              O.ceilPowerOfTwo(e)
            );
          },
        }),
        Object.assign(I.prototype, {
          flattenToArrayOffset: function (e, t) {
            return (
              console.warn(
                "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
              ),
              this.toArray(e, t)
            );
          },
          multiplyVector3: function (e) {
            return (
              console.warn(
                "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
              ),
              e.applyMatrix3(this)
            );
          },
          multiplyVector3Array: function () {
            console.error(
              "THREE.Matrix3: .multiplyVector3Array() has been removed."
            );
          },
          applyToBufferAttribute: function (e) {
            return (
              console.warn(
                "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
              ),
              e.applyMatrix3(this)
            );
          },
          applyToVector3Array: function () {
            console.error(
              "THREE.Matrix3: .applyToVector3Array() has been removed."
            );
          },
          getInverse: function (e) {
            return (
              console.warn(
                "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
              ),
              this.copy(e).invert()
            );
          },
        }),
        Object.assign(ye.prototype, {
          extractPosition: function (e) {
            return (
              console.warn(
                "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
              ),
              this.copyPosition(e)
            );
          },
          flattenToArrayOffset: function (e, t) {
            return (
              console.warn(
                "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
              ),
              this.toArray(e, t)
            );
          },
          getPosition: function () {
            return (
              console.warn(
                "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
              ),
              new W().setFromMatrixColumn(this, 3)
            );
          },
          setRotationFromQuaternion: function (e) {
            return (
              console.warn(
                "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
              ),
              this.makeRotationFromQuaternion(e)
            );
          },
          multiplyToArray: function () {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
          },
          multiplyVector3: function (e) {
            return (
              console.warn(
                "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              e.applyMatrix4(this)
            );
          },
          multiplyVector4: function (e) {
            return (
              console.warn(
                "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              e.applyMatrix4(this)
            );
          },
          multiplyVector3Array: function () {
            console.error(
              "THREE.Matrix4: .multiplyVector3Array() has been removed."
            );
          },
          rotateAxis: function (e) {
            console.warn(
              "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
            ),
              e.transformDirection(this);
          },
          crossVector: function (e) {
            return (
              console.warn(
                "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              e.applyMatrix4(this)
            );
          },
          translate: function () {
            console.error("THREE.Matrix4: .translate() has been removed.");
          },
          rotateX: function () {
            console.error("THREE.Matrix4: .rotateX() has been removed.");
          },
          rotateY: function () {
            console.error("THREE.Matrix4: .rotateY() has been removed.");
          },
          rotateZ: function () {
            console.error("THREE.Matrix4: .rotateZ() has been removed.");
          },
          rotateByAxis: function () {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
          },
          applyToBufferAttribute: function (e) {
            return (
              console.warn(
                "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
              ),
              e.applyMatrix4(this)
            );
          },
          applyToVector3Array: function () {
            console.error(
              "THREE.Matrix4: .applyToVector3Array() has been removed."
            );
          },
          makeFrustum: function (e, t, n, i, r, a) {
            return (
              console.warn(
                "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
              ),
              this.makePerspective(e, t, i, n, r, a)
            );
          },
          getInverse: function (e) {
            return (
              console.warn(
                "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
              ),
              this.copy(e).invert()
            );
          },
        }),
        (Xe.prototype.isIntersectionLine = function (e) {
          return (
            console.warn(
              "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
            ),
            this.intersectsLine(e)
          );
        }),
        Object.assign(G.prototype, {
          multiplyVector3: function (e) {
            return (
              console.warn(
                "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
              ),
              e.applyQuaternion(this)
            );
          },
          inverse: function () {
            return (
              console.warn(
                "THREE.Quaternion: .inverse() has been renamed to invert()."
              ),
              this.invert()
            );
          },
        }),
        Object.assign(ve.prototype, {
          isIntersectionBox: function (e) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(e)
            );
          },
          isIntersectionPlane: function (e) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
              ),
              this.intersectsPlane(e)
            );
          },
          isIntersectionSphere: function (e) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
              ),
              this.intersectsSphere(e)
            );
          },
        }),
        Object.assign(rt.prototype, {
          area: function () {
            return (
              console.warn(
                "THREE.Triangle: .area() has been renamed to .getArea()."
              ),
              this.getArea()
            );
          },
          barycoordFromPoint: function (e, t) {
            return (
              console.warn(
                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
              ),
              this.getBarycoord(e, t)
            );
          },
          midpoint: function (e) {
            return (
              console.warn(
                "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
              ),
              this.getMidpoint(e)
            );
          },
          normal: function (e) {
            return (
              console.warn(
                "THREE.Triangle: .normal() has been renamed to .getNormal()."
              ),
              this.getNormal(e)
            );
          },
          plane: function (e) {
            return (
              console.warn(
                "THREE.Triangle: .plane() has been renamed to .getPlane()."
              ),
              this.getPlane(e)
            );
          },
        }),
        Object.assign(rt, {
          barycoordFromPoint: function (e, t, n, i, r) {
            return (
              console.warn(
                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
              ),
              rt.getBarycoord(e, t, n, i, r)
            );
          },
          normal: function (e, t, n, i) {
            return (
              console.warn(
                "THREE.Triangle: .normal() has been renamed to .getNormal()."
              ),
              rt.getNormal(e, t, n, i)
            );
          },
        }),
        Object.assign(ys.prototype, {
          extractAllPoints: function (e) {
            return (
              console.warn(
                "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
              ),
              this.extractPoints(e)
            );
          },
          extrude: function (e) {
            return (
              console.warn(
                "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
              ),
              new co(this, e)
            );
          },
          makeGeometry: function (e) {
            return (
              console.warn(
                "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
              ),
              new uo(this, e)
            );
          },
        }),
        Object.assign(N.prototype, {
          fromAttribute: function (e, t, n) {
            return (
              console.warn(
                "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(e, t, n)
            );
          },
          distanceToManhattan: function (e) {
            return (
              console.warn(
                "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
              ),
              this.manhattanDistanceTo(e)
            );
          },
          lengthManhattan: function () {
            return (
              console.warn(
                "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          },
        }),
        Object.assign(W.prototype, {
          setEulerFromRotationMatrix: function () {
            console.error(
              "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
            );
          },
          setEulerFromQuaternion: function () {
            console.error(
              "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
            );
          },
          getPositionFromMatrix: function (e) {
            return (
              console.warn(
                "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
              ),
              this.setFromMatrixPosition(e)
            );
          },
          getScaleFromMatrix: function (e) {
            return (
              console.warn(
                "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
              ),
              this.setFromMatrixScale(e)
            );
          },
          getColumnFromMatrix: function (e, t) {
            return (
              console.warn(
                "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
              ),
              this.setFromMatrixColumn(t, e)
            );
          },
          applyProjection: function (e) {
            return (
              console.warn(
                "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
              ),
              this.applyMatrix4(e)
            );
          },
          fromAttribute: function (e, t, n) {
            return (
              console.warn(
                "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(e, t, n)
            );
          },
          distanceToManhattan: function (e) {
            return (
              console.warn(
                "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
              ),
              this.manhattanDistanceTo(e)
            );
          },
          lengthManhattan: function () {
            return (
              console.warn(
                "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          },
        }),
        Object.assign(z.prototype, {
          fromAttribute: function (e, t, n) {
            return (
              console.warn(
                "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(e, t, n)
            );
          },
          lengthManhattan: function () {
            return (
              console.warn(
                "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          },
        }),
        Object.assign(Ge.prototype, {
          getChildByName: function (e) {
            return (
              console.warn(
                "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
              ),
              this.getObjectByName(e)
            );
          },
          renderDepth: function () {
            console.warn(
              "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
            );
          },
          translate: function (e, t) {
            return (
              console.warn(
                "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
              ),
              this.translateOnAxis(t, e)
            );
          },
          getWorldRotation: function () {
            console.error(
              "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
            );
          },
          applyMatrix: function (e) {
            return (
              console.warn(
                "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
              ),
              this.applyMatrix4(e)
            );
          },
        }),
        Object.defineProperties(Ge.prototype, {
          eulerOrder: {
            get: function () {
              return (
                console.warn(
                  "THREE.Object3D: .eulerOrder is now .rotation.order."
                ),
                this.rotation.order
              );
            },
            set: function (e) {
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
                (this.rotation.order = e);
            },
          },
          useQuaternion: {
            get: function () {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            },
            set: function () {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            },
          },
        }),
        Object.assign(rn.prototype, {
          setDrawMode: function () {
            console.error(
              "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          },
        }),
        Object.defineProperties(rn.prototype, {
          drawMode: {
            get: function () {
              return (
                console.error(
                  "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
                ),
                0
              );
            },
            set: function () {
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
              );
            },
          },
        }),
        Object.defineProperties(Qr.prototype, {
          objects: {
            get: function () {
              return (
                console.warn(
                  "THREE.LOD: .objects has been renamed to .levels."
                ),
                this.levels
              );
            },
          },
        }),
        Object.defineProperty(sa.prototype, "useVertexTexture", {
          get: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
          },
          set: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
          },
        }),
        (ia.prototype.initBones = function () {
          console.error("THREE.SkinnedMesh: initBones() has been removed.");
        }),
        Object.defineProperty(Zo.prototype, "__arcLengthDivisions", {
          get: function () {
            return (
              console.warn(
                "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
              ),
              this.arcLengthDivisions
            );
          },
          set: function (e) {
            console.warn(
              "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
            ),
              (this.arcLengthDivisions = e);
          },
        }),
        (pn.prototype.setLens = function (e, t) {
          console.warn(
            "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
          ),
            void 0 !== t && (this.filmGauge = t),
            this.setFocalLength(e);
        }),
        Object.defineProperties(_s.prototype, {
          onlyShadow: {
            set: function () {
              console.warn("THREE.Light: .onlyShadow has been removed.");
            },
          },
          shadowCameraFov: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
              ),
                (this.shadow.camera.fov = e);
            },
          },
          shadowCameraLeft: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
              ),
                (this.shadow.camera.left = e);
            },
          },
          shadowCameraRight: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
              ),
                (this.shadow.camera.right = e);
            },
          },
          shadowCameraTop: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
              ),
                (this.shadow.camera.top = e);
            },
          },
          shadowCameraBottom: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
              ),
                (this.shadow.camera.bottom = e);
            },
          },
          shadowCameraNear: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
              ),
                (this.shadow.camera.near = e);
            },
          },
          shadowCameraFar: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
              ),
                (this.shadow.camera.far = e);
            },
          },
          shadowCameraVisible: {
            set: function () {
              console.warn(
                "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
              );
            },
          },
          shadowBias: {
            set: function (e) {
              console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                (this.shadow.bias = e);
            },
          },
          shadowDarkness: {
            set: function () {
              console.warn("THREE.Light: .shadowDarkness has been removed.");
            },
          },
          shadowMapWidth: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
              ),
                (this.shadow.mapSize.width = e);
            },
          },
          shadowMapHeight: {
            set: function (e) {
              console.warn(
                "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
              ),
                (this.shadow.mapSize.height = e);
            },
          },
        }),
        Object.defineProperties(yt.prototype, {
          length: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
                ),
                this.array.length
              );
            },
          },
          dynamic: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                ),
                this.usage === L
              );
            },
            set: function () {
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
                this.setUsage(L);
            },
          },
        }),
        Object.assign(yt.prototype, {
          setDynamic: function (e) {
            return (
              console.warn(
                "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
              ),
              this.setUsage(!0 === e ? L : A),
              this
            );
          },
          copyIndicesArray: function () {
            console.error(
              "THREE.BufferAttribute: .copyIndicesArray() has been removed."
            );
          },
          setArray: function () {
            console.error(
              "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            );
          },
        }),
        Object.assign(Ht.prototype, {
          addIndex: function (e) {
            console.warn(
              "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
            ),
              this.setIndex(e);
          },
          addAttribute: function (e, t) {
            return (
              console.warn(
                "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
              ),
              (t && t.isBufferAttribute) ||
              (t && t.isInterleavedBufferAttribute)
                ? "index" === e
                  ? (console.warn(
                      "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                    ),
                    this.setIndex(t),
                    this)
                  : this.setAttribute(e, t)
                : (console.warn(
                    "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
                  ),
                  this.setAttribute(e, new yt(arguments[1], arguments[2])))
            );
          },
          addDrawCall: function (e, t, n) {
            void 0 !== n &&
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
              ),
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
              ),
              this.addGroup(e, t);
          },
          clearDrawCalls: function () {
            console.warn(
              "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
            ),
              this.clearGroups();
          },
          computeOffsets: function () {
            console.warn(
              "THREE.BufferGeometry: .computeOffsets() has been removed."
            );
          },
          removeAttribute: function (e) {
            return (
              console.warn(
                "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
              ),
              this.deleteAttribute(e)
            );
          },
          applyMatrix: function (e) {
            return (
              console.warn(
                "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
              ),
              this.applyMatrix4(e)
            );
          },
        }),
        Object.defineProperties(Ht.prototype, {
          drawcalls: {
            get: function () {
              return (
                console.error(
                  "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
                ),
                this.groups
              );
            },
          },
          offsets: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferGeometry: .offsets has been renamed to .groups."
                ),
                this.groups
              );
            },
          },
        }),
        Object.defineProperties(Ds.prototype, {
          maxInstancedCount: {
            get: function () {
              return (
                console.warn(
                  "THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
                ),
                this.instanceCount
              );
            },
            set: function (e) {
              console.warn(
                "THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
              ),
                (this.instanceCount = e);
            },
          },
        }),
        Object.defineProperties(mc.prototype, {
          linePrecision: {
            get: function () {
              return (
                console.warn(
                  "THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
                ),
                this.params.Line.threshold
              );
            },
            set: function (e) {
              console.warn(
                "THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
              ),
                (this.params.Line.threshold = e);
            },
          },
        }),
        Object.defineProperties(Rr.prototype, {
          dynamic: {
            get: function () {
              return (
                console.warn(
                  "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
                ),
                this.usage === L
              );
            },
            set: function (e) {
              console.warn(
                "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
              ),
                this.setUsage(e);
            },
          },
        }),
        Object.assign(Rr.prototype, {
          setDynamic: function (e) {
            return (
              console.warn(
                "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
              ),
              this.setUsage(!0 === e ? L : A),
              this
            );
          },
          setArray: function () {
            console.error(
              "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            );
          },
        }),
        Object.assign(co.prototype, {
          getArrays: function () {
            console.error(
              "THREE.ExtrudeGeometry: .getArrays() has been removed."
            );
          },
          addShapeList: function () {
            console.error(
              "THREE.ExtrudeGeometry: .addShapeList() has been removed."
            );
          },
          addShape: function () {
            console.error(
              "THREE.ExtrudeGeometry: .addShape() has been removed."
            );
          },
        }),
        Object.assign(Pr.prototype, {
          dispose: function () {
            console.error("THREE.Scene: .dispose() has been removed.");
          },
        }),
        Object.defineProperties(pc.prototype, {
          dynamic: {
            set: function () {
              console.warn(
                "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
              );
            },
          },
          onUpdate: {
            value: function () {
              return (
                console.warn(
                  "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
                ),
                this
              );
            },
          },
        }),
        Object.defineProperties(ft.prototype, {
          wrapAround: {
            get: function () {
              console.warn("THREE.Material: .wrapAround has been removed.");
            },
            set: function () {
              console.warn("THREE.Material: .wrapAround has been removed.");
            },
          },
          overdraw: {
            get: function () {
              console.warn("THREE.Material: .overdraw has been removed.");
            },
            set: function () {
              console.warn("THREE.Material: .overdraw has been removed.");
            },
          },
          wrapRGB: {
            get: function () {
              return (
                console.warn("THREE.Material: .wrapRGB has been removed."),
                new ut()
              );
            },
          },
          shading: {
            get: function () {
              console.error(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              );
            },
            set: function (e) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              ),
                (this.flatShading = 1 === e);
            },
          },
          stencilMask: {
            get: function () {
              return (
                console.warn(
                  "THREE." +
                    this.type +
                    ": .stencilMask has been removed. Use .stencilFuncMask instead."
                ),
                this.stencilFuncMask
              );
            },
            set: function (e) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
                (this.stencilFuncMask = e);
            },
          },
        }),
        Object.defineProperties(vo.prototype, {
          metal: {
            get: function () {
              return (
                console.warn(
                  "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
                ),
                !1
              );
            },
            set: function () {
              console.warn(
                "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
              );
            },
          },
        }),
        Object.defineProperties(go.prototype, {
          transparency: {
            get: function () {
              return (
                console.warn(
                  "THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."
                ),
                this.transmission
              );
            },
            set: function (e) {
              console.warn(
                "THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."
              ),
                (this.transmission = e);
            },
          },
        }),
        Object.defineProperties(hn.prototype, {
          derivatives: {
            get: function () {
              return (
                console.warn(
                  "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                ),
                this.extensions.derivatives
              );
            },
            set: function (e) {
              console.warn(
                "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
                (this.extensions.derivatives = e);
            },
          },
        }),
        Object.assign(Ar.prototype, {
          clearTarget: function (e, t, n, i) {
            console.warn(
              "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
            ),
              this.setRenderTarget(e),
              this.clear(t, n, i);
          },
          animate: function (e) {
            console.warn(
              "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
            ),
              this.setAnimationLoop(e);
          },
          getCurrentRenderTarget: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
              ),
              this.getRenderTarget()
            );
          },
          getMaxAnisotropy: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
              ),
              this.capabilities.getMaxAnisotropy()
            );
          },
          getPrecision: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
              ),
              this.capabilities.precision
            );
          },
          resetGLState: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
              ),
              this.state.reset()
            );
          },
          supportsFloatTextures: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
              ),
              this.extensions.get("OES_texture_float")
            );
          },
          supportsHalfFloatTextures: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
              ),
              this.extensions.get("OES_texture_half_float")
            );
          },
          supportsStandardDerivatives: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
              ),
              this.extensions.get("OES_standard_derivatives")
            );
          },
          supportsCompressedTextureS3TC: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
              ),
              this.extensions.get("WEBGL_compressed_texture_s3tc")
            );
          },
          supportsCompressedTexturePVRTC: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
              ),
              this.extensions.get("WEBGL_compressed_texture_pvrtc")
            );
          },
          supportsBlendMinMax: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
              ),
              this.extensions.get("EXT_blend_minmax")
            );
          },
          supportsVertexTextures: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
              ),
              this.capabilities.vertexTextures
            );
          },
          supportsInstancedArrays: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
              ),
              this.extensions.get("ANGLE_instanced_arrays")
            );
          },
          enableScissorTest: function (e) {
            console.warn(
              "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
            ),
              this.setScissorTest(e);
          },
          initMaterial: function () {
            console.warn(
              "THREE.WebGLRenderer: .initMaterial() has been removed."
            );
          },
          addPrePlugin: function () {
            console.warn(
              "THREE.WebGLRenderer: .addPrePlugin() has been removed."
            );
          },
          addPostPlugin: function () {
            console.warn(
              "THREE.WebGLRenderer: .addPostPlugin() has been removed."
            );
          },
          updateShadowMap: function () {
            console.warn(
              "THREE.WebGLRenderer: .updateShadowMap() has been removed."
            );
          },
          setFaceCulling: function () {
            console.warn(
              "THREE.WebGLRenderer: .setFaceCulling() has been removed."
            );
          },
          allocTextureUnit: function () {
            console.warn(
              "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
            );
          },
          setTexture: function () {
            console.warn(
              "THREE.WebGLRenderer: .setTexture() has been removed."
            );
          },
          setTexture2D: function () {
            console.warn(
              "THREE.WebGLRenderer: .setTexture2D() has been removed."
            );
          },
          setTextureCube: function () {
            console.warn(
              "THREE.WebGLRenderer: .setTextureCube() has been removed."
            );
          },
          getActiveMipMapLevel: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
              ),
              this.getActiveMipmapLevel()
            );
          },
        }),
        Object.defineProperties(Ar.prototype, {
          shadowMapEnabled: {
            get: function () {
              return this.shadowMap.enabled;
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
              ),
                (this.shadowMap.enabled = e);
            },
          },
          shadowMapType: {
            get: function () {
              return this.shadowMap.type;
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
              ),
                (this.shadowMap.type = e);
            },
          },
          shadowMapCullFace: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            },
          },
          context: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
                ),
                this.getContext()
              );
            },
          },
          vr: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .vr has been renamed to .xr"
                ),
                this.xr
              );
            },
          },
          gammaInput: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                ),
                !1
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              );
            },
          },
          gammaOutput: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                ),
                !1
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
                (this.outputEncoding = !0 === e ? T : S);
            },
          },
          toneMappingWhitePoint: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                ),
                1
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              );
            },
          },
        }),
        Object.defineProperties(yr.prototype, {
          cullFace: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            },
          },
          renderReverseSided: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            },
          },
          renderSingleSided: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            },
          },
        }),
        Object.defineProperties(U.prototype, {
          wrapS: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                ),
                this.texture.wrapS
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
                (this.texture.wrapS = e);
            },
          },
          wrapT: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                ),
                this.texture.wrapT
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
                (this.texture.wrapT = e);
            },
          },
          magFilter: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                ),
                this.texture.magFilter
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
                (this.texture.magFilter = e);
            },
          },
          minFilter: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                ),
                this.texture.minFilter
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
                (this.texture.minFilter = e);
            },
          },
          anisotropy: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                ),
                this.texture.anisotropy
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
                (this.texture.anisotropy = e);
            },
          },
          offset: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                ),
                this.texture.offset
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
                (this.texture.offset = e);
            },
          },
          repeat: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                ),
                this.texture.repeat
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
                (this.texture.repeat = e);
            },
          },
          format: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .format is now .texture.format."
                ),
                this.texture.format
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
                (this.texture.format = e);
            },
          },
          type: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .type is now .texture.type."
                ),
                this.texture.type
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
                (this.texture.type = e);
            },
          },
          generateMipmaps: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                ),
                this.texture.generateMipmaps
              );
            },
            set: function (e) {
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
                (this.texture.generateMipmaps = e);
            },
          },
        }),
        Object.defineProperties(
          class extends Ge {
            constructor(e) {
              super(),
                (this.type = "Audio"),
                (this.listener = e),
                (this.context = e.context),
                (this.gain = this.context.createGain()),
                this.gain.connect(e.getInput()),
                (this.autoplay = !1),
                (this.buffer = null),
                (this.detune = 0),
                (this.loop = !1),
                (this.loopStart = 0),
                (this.loopEnd = 0),
                (this.offset = 0),
                (this.duration = void 0),
                (this.playbackRate = 1),
                (this.isPlaying = !1),
                (this.hasPlaybackControl = !0),
                (this.source = null),
                (this.sourceType = "empty"),
                (this._startedAt = 0),
                (this._progress = 0),
                (this._connected = !1),
                (this.filters = []);
            }
            getOutput() {
              return this.gain;
            }
            setNodeSource(e) {
              return (
                (this.hasPlaybackControl = !1),
                (this.sourceType = "audioNode"),
                (this.source = e),
                this.connect(),
                this
              );
            }
            setMediaElementSource(e) {
              return (
                (this.hasPlaybackControl = !1),
                (this.sourceType = "mediaNode"),
                (this.source = this.context.createMediaElementSource(e)),
                this.connect(),
                this
              );
            }
            setMediaStreamSource(e) {
              return (
                (this.hasPlaybackControl = !1),
                (this.sourceType = "mediaStreamNode"),
                (this.source = this.context.createMediaStreamSource(e)),
                this.connect(),
                this
              );
            }
            setBuffer(e) {
              return (
                (this.buffer = e),
                (this.sourceType = "buffer"),
                this.autoplay && this.play(),
                this
              );
            }
            play(e = 0) {
              if (!0 === this.isPlaying)
                return void console.warn(
                  "THREE.Audio: Audio is already playing."
                );
              if (!1 === this.hasPlaybackControl)
                return void console.warn(
                  "THREE.Audio: this Audio has no playback control."
                );
              this._startedAt = this.context.currentTime + e;
              const t = this.context.createBufferSource();
              return (
                (t.buffer = this.buffer),
                (t.loop = this.loop),
                (t.loopStart = this.loopStart),
                (t.loopEnd = this.loopEnd),
                (t.onended = this.onEnded.bind(this)),
                t.start(
                  this._startedAt,
                  this._progress + this.offset,
                  this.duration
                ),
                (this.isPlaying = !0),
                (this.source = t),
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
              );
            }
            pause() {
              if (!1 !== this.hasPlaybackControl)
                return (
                  !0 === this.isPlaying &&
                    ((this._progress +=
                      Math.max(this.context.currentTime - this._startedAt, 0) *
                      this.playbackRate),
                    !0 === this.loop &&
                      (this._progress =
                        this._progress %
                        (this.duration || this.buffer.duration)),
                    this.source.stop(),
                    (this.source.onended = null),
                    (this.isPlaying = !1)),
                  this
                );
              console.warn("THREE.Audio: this Audio has no playback control.");
            }
            stop() {
              if (!1 !== this.hasPlaybackControl)
                return (
                  (this._progress = 0),
                  this.source.stop(),
                  (this.source.onended = null),
                  (this.isPlaying = !1),
                  this
                );
              console.warn("THREE.Audio: this Audio has no playback control.");
            }
            connect() {
              if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++)
                  this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput());
              } else this.source.connect(this.getOutput());
              return (this._connected = !0), this;
            }
            disconnect() {
              if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++)
                  this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(
                  this.getOutput()
                );
              } else this.source.disconnect(this.getOutput());
              return (this._connected = !1), this;
            }
            getFilters() {
              return this.filters;
            }
            setFilters(e) {
              return (
                e || (e = []),
                !0 === this._connected
                  ? (this.disconnect(),
                    (this.filters = e.slice()),
                    this.connect())
                  : (this.filters = e.slice()),
                this
              );
            }
            setDetune(e) {
              if (((this.detune = e), void 0 !== this.source.detune))
                return (
                  !0 === this.isPlaying &&
                    this.source.detune.setTargetAtTime(
                      this.detune,
                      this.context.currentTime,
                      0.01
                    ),
                  this
                );
            }
            getDetune() {
              return this.detune;
            }
            getFilter() {
              return this.getFilters()[0];
            }
            setFilter(e) {
              return this.setFilters(e ? [e] : []);
            }
            setPlaybackRate(e) {
              if (!1 !== this.hasPlaybackControl)
                return (
                  (this.playbackRate = e),
                  !0 === this.isPlaying &&
                    this.source.playbackRate.setTargetAtTime(
                      this.playbackRate,
                      this.context.currentTime,
                      0.01
                    ),
                  this
                );
              console.warn("THREE.Audio: this Audio has no playback control.");
            }
            getPlaybackRate() {
              return this.playbackRate;
            }
            onEnded() {
              this.isPlaying = !1;
            }
            getLoop() {
              return !1 === this.hasPlaybackControl
                ? (console.warn(
                    "THREE.Audio: this Audio has no playback control."
                  ),
                  !1)
                : this.loop;
            }
            setLoop(e) {
              if (!1 !== this.hasPlaybackControl)
                return (
                  (this.loop = e),
                  !0 === this.isPlaying && (this.source.loop = this.loop),
                  this
                );
              console.warn("THREE.Audio: this Audio has no playback control.");
            }
            setLoopStart(e) {
              return (this.loopStart = e), this;
            }
            setLoopEnd(e) {
              return (this.loopEnd = e), this;
            }
            getVolume() {
              return this.gain.gain.value;
            }
            setVolume(e) {
              return (
                this.gain.gain.setTargetAtTime(
                  e,
                  this.context.currentTime,
                  0.01
                ),
                this
              );
            }
          }.prototype,
          {
            load: {
              value: function (e) {
                console.warn(
                  "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
                );
                const t = this;
                return (
                  new Vs().load(e, function (e) {
                    t.setBuffer(e);
                  }),
                  this
                );
              },
            },
            startTime: {
              set: function () {
                console.warn("THREE.Audio: .startTime is now .play( delay ).");
              },
            },
          }
        ),
        (class {
          constructor(e, t = 2048) {
            (this.analyser = e.context.createAnalyser()),
              (this.analyser.fftSize = t),
              (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
              e.getOutput().connect(this.analyser);
          }
          getFrequencyData() {
            return this.analyser.getByteFrequencyData(this.data), this.data;
          }
          getAverageFrequency() {
            let e = 0;
            const t = this.getFrequencyData();
            for (let n = 0; n < t.length; n++) e += t[n];
            return e / t.length;
          }
        }.prototype.getData = function () {
          return (
            console.warn(
              "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
            ),
            this.getFrequencyData()
          );
        }),
        (fn.prototype.updateCubeMap = function (e, t) {
          return (
            console.warn(
              "THREE.CubeCamera: .updateCubeMap() is now .update()."
            ),
            this.update(e, t)
          );
        }),
        (fn.prototype.clear = function (e, t, n, i) {
          return (
            console.warn(
              "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
            ),
            this.renderTarget.clear(e, t, n, i)
          );
        }),
        (j.crossOrigin = void 0),
        (j.loadTexture = function (e, t, n, i) {
          console.warn(
            "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
          );
          const r = new Jo();
          r.setCrossOrigin(this.crossOrigin);
          const a = r.load(e, n, void 0, i);
          return t && (a.mapping = t), a;
        }),
        (j.loadTextureCube = function (e, t, n, i) {
          console.warn(
            "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
          );
          const r = new Xo();
          r.setCrossOrigin(this.crossOrigin);
          const a = r.load(e, n, void 0, i);
          return t && (a.mapping = t), a;
        }),
        (j.loadCompressedTexture = function () {
          console.error(
            "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
          );
        }),
        (j.loadCompressedTextureCube = function () {
          console.error(
            "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
          );
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("register", { detail: { revision: "125" } })
          ),
        "undefined" != typeof window &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported."
              )
            : (window.__THREE__ = "125"));
      var Ic = (function () {
        function e(e) {
          zo.call(this, e),
            (this.dracoLoader = null),
            (this.ddsLoader = null),
            (this.ktx2Loader = null),
            (this.meshoptDecoder = null),
            (this.pluginCallbacks = []),
            this.register(function (e) {
              return new m(e);
            }),
            this.register(function (e) {
              return new v(e);
            }),
            this.register(function (e) {
              return new w(e);
            }),
            this.register(function (e) {
              return new g(e);
            }),
            this.register(function (e) {
              return new p(e);
            }),
            this.register(function (e) {
              return new x(e);
            });
        }
        function l() {
          var e = {};
          return {
            get: function (t) {
              return e[t];
            },
            add: function (t, n) {
              e[t] = n;
            },
            remove: function (t) {
              delete e[t];
            },
            removeAll: function () {
              e = {};
            },
          };
        }
        e.prototype = Object.assign(Object.create(zo.prototype), {
          constructor: e,
          load: function (e, t, n, i) {
            var r,
              a = this;
            (r =
              "" !== this.resourcePath
                ? this.resourcePath
                : "" !== this.path
                ? this.path
                : Is(e)),
              this.manager.itemStart(e);
            var o = function (t) {
                i ? i(t) : console.error(t),
                  a.manager.itemError(e),
                  a.manager.itemEnd(e);
              },
              s = new Go(this.manager);
            s.setPath(this.path),
              s.setResponseType("arraybuffer"),
              s.setRequestHeader(this.requestHeader),
              s.setWithCredentials(this.withCredentials),
              s.load(
                e,
                function (n) {
                  try {
                    a.parse(
                      n,
                      r,
                      function (n) {
                        t(n), a.manager.itemEnd(e);
                      },
                      o
                    );
                  } catch (e) {
                    o(e);
                  }
                },
                n,
                o
              );
          },
          setDRACOLoader: function (e) {
            return (this.dracoLoader = e), this;
          },
          setDDSLoader: function (e) {
            return (this.ddsLoader = e), this;
          },
          setKTX2Loader: function (e) {
            return (this.ktx2Loader = e), this;
          },
          setMeshoptDecoder: function (e) {
            return (this.meshoptDecoder = e), this;
          },
          register: function (e) {
            return (
              -1 === this.pluginCallbacks.indexOf(e) &&
                this.pluginCallbacks.push(e),
              this
            );
          },
          unregister: function (e) {
            return (
              -1 !== this.pluginCallbacks.indexOf(e) &&
                this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
              this
            );
          },
          parse: function (e, t, n, i) {
            var r,
              a = {},
              o = {};
            if ("string" == typeof e) r = e;
            else if (Ns(new Uint8Array(e, 0, 4)) === b) {
              try {
                a[h.KHR_BINARY_GLTF] = new M(e);
              } catch (e) {
                return void (i && i(e));
              }
              r = a[h.KHR_BINARY_GLTF].content;
            } else r = Ns(new Uint8Array(e));
            var s = JSON.parse(r);
            if (void 0 === s.asset || s.asset.version[0] < 2)
              i &&
                i(
                  new Error(
                    "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                  )
                );
            else {
              var c = new q(s, {
                path: t || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder,
              });
              c.fileLoader.setRequestHeader(this.requestHeader);
              for (var l = 0; l < this.pluginCallbacks.length; l++) {
                var p = this.pluginCallbacks[l](c);
                (o[p.name] = p), (a[p.name] = !0);
              }
              if (s.extensionsUsed)
                for (l = 0; l < s.extensionsUsed.length; ++l) {
                  var f = s.extensionsUsed[l],
                    m = s.extensionsRequired || [];
                  switch (f) {
                    case h.KHR_MATERIALS_UNLIT:
                      a[f] = new d();
                      break;
                    case h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                      a[f] = new L();
                      break;
                    case h.KHR_DRACO_MESH_COMPRESSION:
                      a[f] = new S(s, this.dracoLoader);
                      break;
                    case h.MSFT_TEXTURE_DDS:
                      a[f] = new u(this.ddsLoader);
                      break;
                    case h.KHR_TEXTURE_TRANSFORM:
                      a[f] = new E();
                      break;
                    case h.KHR_MESH_QUANTIZATION:
                      a[f] = new P();
                      break;
                    default:
                      m.indexOf(f) >= 0 &&
                        void 0 === o[f] &&
                        console.warn(
                          'THREE.GLTFLoader: Unknown extension "' + f + '".'
                        );
                  }
                }
              c.setExtensions(a), c.setPlugins(o), c.parse(n, i);
            }
          },
        });
        var h = {
          KHR_BINARY_GLTF: "KHR_binary_glTF",
          KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
          KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
          KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
          KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            "KHR_materials_pbrSpecularGlossiness",
          KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
          KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
          KHR_TEXTURE_BASISU: "KHR_texture_basisu",
          KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
          KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
          EXT_TEXTURE_WEBP: "EXT_texture_webp",
          EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
          MSFT_TEXTURE_DDS: "MSFT_texture_dds",
        };
        function u(e) {
          if (!e)
            throw new Error(
              "THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader"
            );
          (this.name = h.MSFT_TEXTURE_DDS), (this.ddsLoader = e);
        }
        function p(e) {
          (this.parser = e),
            (this.name = h.KHR_LIGHTS_PUNCTUAL),
            (this.cache = { refs: {}, uses: {} });
        }
        function d() {
          this.name = h.KHR_MATERIALS_UNLIT;
        }
        function m(e) {
          (this.parser = e), (this.name = h.KHR_MATERIALS_CLEARCOAT);
        }
        function g(e) {
          (this.parser = e), (this.name = h.KHR_MATERIALS_TRANSMISSION);
        }
        function v(e) {
          (this.parser = e), (this.name = h.KHR_TEXTURE_BASISU);
        }
        function w(e) {
          (this.parser = e),
            (this.name = h.EXT_TEXTURE_WEBP),
            (this.isSupported = null);
        }
        function x(e) {
          (this.name = h.EXT_MESHOPT_COMPRESSION), (this.parser = e);
        }
        (p.prototype._markDefs = function () {
          for (
            var e = this.parser,
              t = this.parser.json.nodes || [],
              n = 0,
              i = t.length;
            n < i;
            n++
          ) {
            var r = t[n];
            r.extensions &&
              r.extensions[this.name] &&
              void 0 !== r.extensions[this.name].light &&
              e._addNodeRef(this.cache, r.extensions[this.name].light);
          }
        }),
          (p.prototype._loadLight = function (e) {
            var t = this.parser,
              n = "light:" + e,
              i = t.cache.get(n);
            if (i) return i;
            var r,
              a = t.json,
              o = (((a.extensions && a.extensions[this.name]) || {}).lights ||
                [])[e],
              s = new ut(16777215);
            void 0 !== o.color && s.fromArray(o.color);
            var c = void 0 !== o.range ? o.range : 0;
            switch (o.type) {
              case "directional":
                (r = new Ls(s)).target.position.set(0, 0, -1), r.add(r.target);
                break;
              case "point":
                (r = new Ts(s)).distance = c;
                break;
              case "spot":
                ((r = new Ms(s)).distance = c),
                  (o.spot = o.spot || {}),
                  (o.spot.innerConeAngle =
                    void 0 !== o.spot.innerConeAngle
                      ? o.spot.innerConeAngle
                      : 0),
                  (o.spot.outerConeAngle =
                    void 0 !== o.spot.outerConeAngle
                      ? o.spot.outerConeAngle
                      : Math.PI / 4),
                  (r.angle = o.spot.outerConeAngle),
                  (r.penumbra =
                    1 - o.spot.innerConeAngle / o.spot.outerConeAngle),
                  r.target.position.set(0, 0, -1),
                  r.add(r.target);
                break;
              default:
                throw new Error(
                  "THREE.GLTFLoader: Unexpected light type: " + o.type
                );
            }
            return (
              r.position.set(0, 0, 0),
              (r.decay = 2),
              void 0 !== o.intensity && (r.intensity = o.intensity),
              (r.name = t.createUniqueName(o.name || "light_" + e)),
              (i = Promise.resolve(r)),
              t.cache.add(n, i),
              i
            );
          }),
          (p.prototype.createNodeAttachment = function (e) {
            var t = this,
              n = this.parser,
              i = n.json.nodes[e],
              r = ((i.extensions && i.extensions[this.name]) || {}).light;
            return void 0 === r
              ? null
              : this._loadLight(r).then(function (e) {
                  return n._getNodeRef(t.cache, r, e);
                });
          }),
          (d.prototype.getMaterialType = function () {
            return mt;
          }),
          (d.prototype.extendParams = function (e, t, n) {
            var i = [];
            (e.color = new ut(1, 1, 1)), (e.opacity = 1);
            var r = t.pbrMetallicRoughness;
            if (r) {
              if (Array.isArray(r.baseColorFactor)) {
                var a = r.baseColorFactor;
                e.color.fromArray(a), (e.opacity = a[3]);
              }
              void 0 !== r.baseColorTexture &&
                i.push(n.assignTexture(e, "map", r.baseColorTexture));
            }
            return Promise.all(i);
          }),
          (m.prototype.getMaterialType = function (e) {
            var t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? go : null;
          }),
          (m.prototype.extendMaterialParams = function (e, t) {
            var n = this.parser,
              i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name])
              return Promise.resolve();
            var r = [],
              a = i.extensions[this.name];
            if (
              (void 0 !== a.clearcoatFactor &&
                (t.clearcoat = a.clearcoatFactor),
              void 0 !== a.clearcoatTexture &&
                r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
              void 0 !== a.clearcoatRoughnessFactor &&
                (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
              void 0 !== a.clearcoatRoughnessTexture &&
                r.push(
                  n.assignTexture(
                    t,
                    "clearcoatRoughnessMap",
                    a.clearcoatRoughnessTexture
                  )
                ),
              void 0 !== a.clearcoatNormalTexture &&
                (r.push(
                  n.assignTexture(
                    t,
                    "clearcoatNormalMap",
                    a.clearcoatNormalTexture
                  )
                ),
                void 0 !== a.clearcoatNormalTexture.scale))
            ) {
              var o = a.clearcoatNormalTexture.scale;
              t.clearcoatNormalScale = new N(o, -o);
            }
            return Promise.all(r);
          }),
          (g.prototype.getMaterialType = function (e) {
            var t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? go : null;
          }),
          (g.prototype.extendMaterialParams = function (e, t) {
            var n = this.parser,
              i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name])
              return Promise.resolve();
            var r = [],
              a = i.extensions[this.name];
            return (
              void 0 !== a.transmissionFactor &&
                (t.transmission = a.transmissionFactor),
              void 0 !== a.transmissionTexture &&
                r.push(
                  n.assignTexture(t, "transmissionMap", a.transmissionTexture)
                ),
              Promise.all(r)
            );
          }),
          (v.prototype.loadTexture = function (e) {
            var t = this.parser,
              n = t.json,
              i = n.textures[e];
            if (!i.extensions || !i.extensions[this.name]) return null;
            var r = i.extensions[this.name],
              a = n.images[r.source],
              o = t.options.ktx2Loader;
            if (!o) {
              if (
                n.extensionsRequired &&
                n.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
                );
              return null;
            }
            return t.loadTextureImage(e, a, o);
          }),
          (w.prototype.loadTexture = function (e) {
            var t = this.name,
              n = this.parser,
              i = n.json,
              r = i.textures[e];
            if (!r.extensions || !r.extensions[t]) return null;
            var a = r.extensions[t],
              o = i.images[a.source],
              s = o.uri ? n.options.manager.getHandler(o.uri) : n.textureLoader;
            return this.detectSupport().then(function (r) {
              if (r) return n.loadTextureImage(e, o, s);
              if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                throw new Error(
                  "THREE.GLTFLoader: WebP required by asset but unsupported."
                );
              return n.loadTexture(e);
            });
          }),
          (w.prototype.detectSupport = function () {
            return (
              this.isSupported ||
                (this.isSupported = new Promise(function (e) {
                  var t = new Image();
                  (t.src =
                    "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                    (t.onload = t.onerror =
                      function () {
                        e(1 === t.height);
                      });
                })),
              this.isSupported
            );
          }),
          (x.prototype.loadBufferView = function (e) {
            var t = this.parser.json,
              n = t.bufferViews[e];
            if (n.extensions && n.extensions[this.name]) {
              var i = n.extensions[this.name],
                r = this.parser.getDependency("buffer", i.buffer),
                a = this.parser.options.meshoptDecoder;
              if (!a || !a.supported) {
                if (
                  t.extensionsRequired &&
                  t.extensionsRequired.indexOf(this.name) >= 0
                )
                  throw new Error(
                    "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                  );
                return null;
              }
              return Promise.all([r, a.ready]).then(function (e) {
                var t = i.byteOffset || 0,
                  n = i.byteLength || 0,
                  r = i.count,
                  o = i.byteStride,
                  s = new ArrayBuffer(r * o),
                  c = new Uint8Array(e[0], t, n);
                return (
                  a.decodeGltfBuffer(
                    new Uint8Array(s),
                    r,
                    o,
                    c,
                    i.mode,
                    i.filter
                  ),
                  s
                );
              });
            }
            return null;
          });
        var b = "glTF";
        function M(e) {
          (this.name = h.KHR_BINARY_GLTF),
            (this.content = null),
            (this.body = null);
          var t = new DataView(e, 0, 12);
          if (
            ((this.header = {
              magic: Ns(new Uint8Array(e.slice(0, 4))),
              version: t.getUint32(4, !0),
              length: t.getUint32(8, !0),
            }),
            this.header.magic !== b)
          )
            throw new Error(
              "THREE.GLTFLoader: Unsupported glTF-Binary header."
            );
          if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          for (
            var n = this.header.length - 12, i = new DataView(e, 12), r = 0;
            r < n;

          ) {
            var a = i.getUint32(r, !0);
            r += 4;
            var o = i.getUint32(r, !0);
            if (((r += 4), 1313821514 === o)) {
              var s = new Uint8Array(e, 12 + r, a);
              this.content = Ns(s);
            } else if (5130562 === o) {
              var c = 12 + r;
              this.body = e.slice(c, c + a);
            }
            r += a;
          }
          if (null === this.content)
            throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
        function S(e, t) {
          if (!t)
            throw new Error(
              "THREE.GLTFLoader: No DRACOLoader instance provided."
            );
          (this.name = h.KHR_DRACO_MESH_COMPRESSION),
            (this.json = e),
            (this.dracoLoader = t),
            this.dracoLoader.preload();
        }
        function E() {
          this.name = h.KHR_TEXTURE_TRANSFORM;
        }
        function A(e) {
          mo.call(this), (this.isGLTFSpecularGlossinessMaterial = !0);
          var t = [
              "#ifdef USE_SPECULARMAP",
              "\tuniform sampler2D specularMap;",
              "#endif",
            ].join("\n"),
            n = [
              "#ifdef USE_GLOSSINESSMAP",
              "\tuniform sampler2D glossinessMap;",
              "#endif",
            ].join("\n"),
            i = [
              "vec3 specularFactor = specular;",
              "#ifdef USE_SPECULARMAP",
              "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
              "\ttexelSpecular = sRGBToLinear( texelSpecular );",
              "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "\tspecularFactor *= texelSpecular.rgb;",
              "#endif",
            ].join("\n"),
            r = [
              "float glossinessFactor = glossiness;",
              "#ifdef USE_GLOSSINESSMAP",
              "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
              "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "\tglossinessFactor *= texelGlossiness.a;",
              "#endif",
            ].join("\n"),
            a = [
              "PhysicalMaterial material;",
              "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
              "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
              "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
              "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
              "material.specularRoughness += geometryRoughness;",
              "material.specularRoughness = min( material.specularRoughness, 1.0 );",
              "material.specularColor = specularFactor;",
            ].join("\n"),
            o = {
              specular: { value: new ut().setHex(16777215) },
              glossiness: { value: 1 },
              specularMap: { value: null },
              glossinessMap: { value: null },
            };
          (this._extraUniforms = o),
            (this.onBeforeCompile = function (e) {
              for (var s in o) e.uniforms[s] = o[s];
              e.fragmentShader = e.fragmentShader
                .replace("uniform float roughness;", "uniform vec3 specular;")
                .replace(
                  "uniform float metalness;",
                  "uniform float glossiness;"
                )
                .replace("#include <roughnessmap_pars_fragment>", t)
                .replace("#include <metalnessmap_pars_fragment>", n)
                .replace("#include <roughnessmap_fragment>", i)
                .replace("#include <metalnessmap_fragment>", r)
                .replace("#include <lights_physical_fragment>", a);
            }),
            Object.defineProperties(this, {
              specular: {
                get: function () {
                  return o.specular.value;
                },
                set: function (e) {
                  o.specular.value = e;
                },
              },
              specularMap: {
                get: function () {
                  return o.specularMap.value;
                },
                set: function (e) {
                  (o.specularMap.value = e),
                    e
                      ? (this.defines.USE_SPECULARMAP = "")
                      : delete this.defines.USE_SPECULARMAP;
                },
              },
              glossiness: {
                get: function () {
                  return o.glossiness.value;
                },
                set: function (e) {
                  o.glossiness.value = e;
                },
              },
              glossinessMap: {
                get: function () {
                  return o.glossinessMap.value;
                },
                set: function (e) {
                  (o.glossinessMap.value = e),
                    e
                      ? ((this.defines.USE_GLOSSINESSMAP = ""),
                        (this.defines.USE_UV = ""))
                      : (delete this.defines.USE_GLOSSINESSMAP,
                        delete this.defines.USE_UV);
                },
              },
            }),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this.setValues(e);
        }
        function L() {
          return {
            name: h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
            specularGlossinessParams: [
              "color",
              "map",
              "lightMap",
              "lightMapIntensity",
              "aoMap",
              "aoMapIntensity",
              "emissive",
              "emissiveIntensity",
              "emissiveMap",
              "bumpMap",
              "bumpScale",
              "normalMap",
              "normalMapType",
              "displacementMap",
              "displacementScale",
              "displacementBias",
              "specularMap",
              "specular",
              "glossinessMap",
              "glossiness",
              "alphaMap",
              "envMap",
              "envMapIntensity",
              "refractionRatio",
            ],
            getMaterialType: function () {
              return A;
            },
            extendParams: function (e, t, n) {
              var i = t.extensions[this.name];
              (e.color = new ut(1, 1, 1)), (e.opacity = 1);
              var r = [];
              if (Array.isArray(i.diffuseFactor)) {
                var a = i.diffuseFactor;
                e.color.fromArray(a), (e.opacity = a[3]);
              }
              if (
                (void 0 !== i.diffuseTexture &&
                  r.push(n.assignTexture(e, "map", i.diffuseTexture)),
                (e.emissive = new ut(0, 0, 0)),
                (e.glossiness =
                  void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
                (e.specular = new ut(1, 1, 1)),
                Array.isArray(i.specularFactor) &&
                  e.specular.fromArray(i.specularFactor),
                void 0 !== i.specularGlossinessTexture)
              ) {
                var o = i.specularGlossinessTexture;
                r.push(n.assignTexture(e, "glossinessMap", o)),
                  r.push(n.assignTexture(e, "specularMap", o));
              }
              return Promise.all(r);
            },
            createMaterial: function (e) {
              var t = new A(e);
              return (
                (t.fog = !0),
                (t.color = e.color),
                (t.map = void 0 === e.map ? null : e.map),
                (t.lightMap = null),
                (t.lightMapIntensity = 1),
                (t.aoMap = void 0 === e.aoMap ? null : e.aoMap),
                (t.aoMapIntensity = 1),
                (t.emissive = e.emissive),
                (t.emissiveIntensity = 1),
                (t.emissiveMap =
                  void 0 === e.emissiveMap ? null : e.emissiveMap),
                (t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap),
                (t.bumpScale = 1),
                (t.normalMap = void 0 === e.normalMap ? null : e.normalMap),
                (t.normalMapType = 0),
                e.normalScale && (t.normalScale = e.normalScale),
                (t.displacementMap = null),
                (t.displacementScale = 1),
                (t.displacementBias = 0),
                (t.specularMap =
                  void 0 === e.specularMap ? null : e.specularMap),
                (t.specular = e.specular),
                (t.glossinessMap =
                  void 0 === e.glossinessMap ? null : e.glossinessMap),
                (t.glossiness = e.glossiness),
                (t.alphaMap = null),
                (t.envMap = void 0 === e.envMap ? null : e.envMap),
                (t.envMapIntensity = 1),
                (t.refractionRatio = 0.98),
                t
              );
            },
          };
        }
        function P() {
          this.name = h.KHR_MESH_QUANTIZATION;
        }
        function R(e, t, n, i) {
          To.call(this, e, t, n, i);
        }
        (S.prototype.decodePrimitive = function (e, t) {
          var n = this.json,
            i = this.dracoLoader,
            r = e.extensions[this.name].bufferView,
            a = e.extensions[this.name].attributes,
            o = {},
            s = {},
            c = {};
          for (var l in a) {
            var h = j[l] || l.toLowerCase();
            o[h] = a[l];
          }
          for (l in e.attributes)
            if (((h = j[l] || l.toLowerCase()), void 0 !== a[l])) {
              var u = n.accessors[e.attributes[l]],
                p = k[u.componentType];
              (c[h] = p), (s[h] = !0 === u.normalized);
            }
          return t.getDependency("bufferView", r).then(function (e) {
            return new Promise(function (t) {
              i.decodeDracoFile(
                e,
                function (e) {
                  for (var n in e.attributes) {
                    var i = e.attributes[n],
                      r = s[n];
                    void 0 !== r && (i.normalized = r);
                  }
                  t(e);
                },
                o,
                c
              );
            });
          });
        }),
          (E.prototype.extendTexture = function (e, t) {
            return (
              (e = e.clone()),
              void 0 !== t.offset && e.offset.fromArray(t.offset),
              void 0 !== t.rotation && (e.rotation = t.rotation),
              void 0 !== t.scale && e.repeat.fromArray(t.scale),
              void 0 !== t.texCoord &&
                console.warn(
                  'THREE.GLTFLoader: Custom UV sets in "' +
                    this.name +
                    '" extension not yet supported.'
                ),
              (e.needsUpdate = !0),
              e
            );
          }),
          (A.prototype = Object.create(mo.prototype)),
          (A.prototype.constructor = A),
          (A.prototype.copy = function (e) {
            return (
              mo.prototype.copy.call(this, e),
              (this.specularMap = e.specularMap),
              this.specular.copy(e.specular),
              (this.glossinessMap = e.glossinessMap),
              (this.glossiness = e.glossiness),
              delete this.metalness,
              delete this.roughness,
              delete this.metalnessMap,
              delete this.roughnessMap,
              this
            );
          }),
          (R.prototype = Object.create(To.prototype)),
          (R.prototype.constructor = R),
          (R.prototype.copySampleValue_ = function (e) {
            for (
              var t = this.resultBuffer,
                n = this.sampleValues,
                i = this.valueSize,
                r = e * i * 3 + i,
                a = 0;
              a !== i;
              a++
            )
              t[a] = n[r + a];
            return t;
          }),
          (R.prototype.beforeStart_ = R.prototype.copySampleValue_),
          (R.prototype.afterEnd_ = R.prototype.copySampleValue_),
          (R.prototype.interpolate_ = function (e, t, n, i) {
            for (
              var r = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = 2 * o,
                c = 3 * o,
                l = i - t,
                h = (n - t) / l,
                u = h * h,
                p = u * h,
                d = e * c,
                f = d - c,
                m = -2 * p + 3 * u,
                g = p - u,
                v = 1 - m,
                y = g - u + h,
                _ = 0;
              _ !== o;
              _++
            ) {
              var w = a[f + _ + o],
                x = a[f + _ + s] * l,
                b = a[d + _ + o],
                M = a[d + _] * l;
              r[_] = v * w + y * x + m * b + g * M;
            }
            return r;
          });
        var k = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array,
          },
          C = { 9728: r, 9729: s, 9984: a, 9985: 1007, 9986: o, 9987: c },
          I = { 33071: n, 33648: i, 10497: t },
          D = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16,
          },
          j = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex",
          },
          F = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences",
          },
          H = { CUBICSPLINE: void 0, LINEAR: _, STEP: y };
        function B(e, t) {
          return "string" != typeof e || "" === e
            ? ""
            : (/^https?:\/\//i.test(t) &&
                /^\//.test(e) &&
                (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(e) ||
              /^data:.*,.*$/i.test(e) ||
              /^blob:.*$/i.test(e)
                ? e
                : t + e);
        }
        function z(e, t, n) {
          for (var i in n.extensions)
            void 0 === e[i] &&
              ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
              (t.userData.gltfExtensions[i] = n.extensions[i]));
        }
        function U(e, t) {
          void 0 !== t.extras &&
            ("object" == typeof t.extras
              ? Object.assign(e.userData, t.extras)
              : console.warn(
                  "THREE.GLTFLoader: Ignoring primitive type .extras, " +
                    t.extras
                ));
        }
        function G(e, t) {
          if ((e.updateMorphTargets(), void 0 !== t.weights))
            for (var n = 0, i = t.weights.length; n < i; n++)
              e.morphTargetInfluences[n] = t.weights[n];
          if (t.extras && Array.isArray(t.extras.targetNames)) {
            var r = t.extras.targetNames;
            if (e.morphTargetInfluences.length === r.length)
              for (
                e.morphTargetDictionary = {}, n = 0, i = r.length;
                n < i;
                n++
              )
                e.morphTargetDictionary[r[n]] = n;
            else
              console.warn(
                "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
              );
          }
        }
        function V(e) {
          for (
            var t = "", n = Object.keys(e).sort(), i = 0, r = n.length;
            i < r;
            i++
          )
            t += n[i] + ":" + e[n[i]] + ";";
          return t;
        }
        function q(e, t) {
          (this.json = e || {}),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = t || {}),
            (this.cache = new l()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            (this.meshCache = { refs: {}, uses: {} }),
            (this.cameraCache = { refs: {}, uses: {} }),
            (this.lightCache = { refs: {}, uses: {} }),
            (this.nodeNamesUsed = {}),
            "undefined" != typeof createImageBitmap &&
            !1 === /Firefox/.test(navigator.userAgent)
              ? (this.textureLoader = new Hs(this.options.manager))
              : (this.textureLoader = new Jo(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            (this.fileLoader = new Go(this.options.manager)),
            this.fileLoader.setResponseType("arraybuffer"),
            "use-credentials" === this.options.crossOrigin &&
              this.fileLoader.setWithCredentials(!0);
        }
        function Y(e, t, n) {
          var i = t.attributes,
            r = [];
          function a(t, i) {
            return n.getDependency("accessor", t).then(function (t) {
              e.setAttribute(i, t);
            });
          }
          for (var o in i) {
            var s = j[o] || o.toLowerCase();
            s in e.attributes || r.push(a(i[o], s));
          }
          if (void 0 !== t.indices && !e.index) {
            var c = n.getDependency("accessor", t.indices).then(function (t) {
              e.setIndex(t);
            });
            r.push(c);
          }
          return (
            U(e, t),
            (function (e, t, n) {
              var i = t.attributes,
                r = new X();
              if (void 0 !== i.POSITION) {
                var a = (p = n.json.accessors[i.POSITION]).min,
                  o = p.max;
                if (void 0 !== a && void 0 !== o) {
                  r.set(new W(a[0], a[1], a[2]), new W(o[0], o[1], o[2]));
                  var s = t.targets;
                  if (void 0 !== s) {
                    for (
                      var c = new W(), l = new W(), h = 0, u = s.length;
                      h < u;
                      h++
                    ) {
                      var p,
                        d = s[h];
                      void 0 !== d.POSITION &&
                        ((a = (p = n.json.accessors[d.POSITION]).min),
                        (o = p.max),
                        void 0 !== a && void 0 !== o
                          ? (l.setX(Math.max(Math.abs(a[0]), Math.abs(o[0]))),
                            l.setY(Math.max(Math.abs(a[1]), Math.abs(o[1]))),
                            l.setZ(Math.max(Math.abs(a[2]), Math.abs(o[2]))),
                            c.max(l))
                          : console.warn(
                              "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                            ));
                    }
                    r.expandByVector(c);
                  }
                  e.boundingBox = r;
                  var f = new le();
                  r.getCenter(f.center),
                    (f.radius = r.min.distanceTo(r.max) / 2),
                    (e.boundingSphere = f);
                } else
                  console.warn(
                    "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                  );
              }
            })(e, t, n),
            Promise.all(r).then(function () {
              return void 0 !== t.targets
                ? (function (e, t, n) {
                    for (
                      var i = !1, r = !1, a = 0, o = t.length;
                      a < o &&
                      (void 0 !== (l = t[a]).POSITION && (i = !0),
                      void 0 !== l.NORMAL && (r = !0),
                      !i || !r);
                      a++
                    );
                    if (!i && !r) return Promise.resolve(e);
                    var s = [],
                      c = [];
                    for (a = 0, o = t.length; a < o; a++) {
                      var l = t[a];
                      if (i) {
                        var h =
                          void 0 !== l.POSITION
                            ? n.getDependency("accessor", l.POSITION)
                            : e.attributes.position;
                        s.push(h);
                      }
                      r &&
                        ((h =
                          void 0 !== l.NORMAL
                            ? n.getDependency("accessor", l.NORMAL)
                            : e.attributes.normal),
                        c.push(h));
                    }
                    return Promise.all([Promise.all(s), Promise.all(c)]).then(
                      function (t) {
                        var n = t[0],
                          a = t[1];
                        return (
                          i && (e.morphAttributes.position = n),
                          r && (e.morphAttributes.normal = a),
                          (e.morphTargetsRelative = !0),
                          e
                        );
                      }
                    );
                  })(e, t.targets, n)
                : e;
            })
          );
        }
        function J(e, t) {
          var n = e.getIndex();
          if (null === n) {
            var i = [],
              r = e.getAttribute("position");
            if (void 0 === r)
              return (
                console.error(
                  "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
                ),
                e
              );
            for (var a = 0; a < r.count; a++) i.push(a);
            e.setIndex(i), (n = e.getIndex());
          }
          var o = n.count - 2,
            s = [];
          if (2 === t)
            for (a = 1; a <= o; a++)
              s.push(n.getX(0)), s.push(n.getX(a)), s.push(n.getX(a + 1));
          else
            for (a = 0; a < o; a++)
              a % 2 == 0
                ? (s.push(n.getX(a)),
                  s.push(n.getX(a + 1)),
                  s.push(n.getX(a + 2)))
                : (s.push(n.getX(a + 2)),
                  s.push(n.getX(a + 1)),
                  s.push(n.getX(a)));
          s.length / 3 !== o &&
            console.error(
              "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
            );
          var c = e.clone();
          return c.setIndex(s), c;
        }
        return (
          (q.prototype.setExtensions = function (e) {
            this.extensions = e;
          }),
          (q.prototype.setPlugins = function (e) {
            this.plugins = e;
          }),
          (q.prototype.parse = function (e, t) {
            var n = this,
              i = this.json,
              r = this.extensions;
            this.cache.removeAll(),
              this._invokeAll(function (e) {
                return e._markDefs && e._markDefs();
              }),
              Promise.all([
                this.getDependencies("scene"),
                this.getDependencies("animation"),
                this.getDependencies("camera"),
              ])
                .then(function (t) {
                  var a = {
                    scene: t[0][i.scene || 0],
                    scenes: t[0],
                    animations: t[1],
                    cameras: t[2],
                    asset: i.asset,
                    parser: n,
                    userData: {},
                  };
                  z(r, a, i), U(a, i), e(a);
                })
                .catch(t);
          }),
          (q.prototype._markDefs = function () {
            for (
              var e = this.json.nodes || [],
                t = this.json.skins || [],
                n = this.json.meshes || [],
                i = 0,
                r = t.length;
              i < r;
              i++
            )
              for (var a = t[i].joints, o = 0, s = a.length; o < s; o++)
                e[a[o]].isBone = !0;
            for (var c = 0, l = e.length; c < l; c++) {
              var h = e[c];
              void 0 !== h.mesh &&
                (this._addNodeRef(this.meshCache, h.mesh),
                void 0 !== h.skin && (n[h.mesh].isSkinnedMesh = !0)),
                void 0 !== h.camera &&
                  this._addNodeRef(this.cameraCache, h.camera);
            }
          }),
          (q.prototype._addNodeRef = function (e, t) {
            void 0 !== t &&
              (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0),
              e.refs[t]++);
          }),
          (q.prototype._getNodeRef = function (e, t, n) {
            if (e.refs[t] <= 1) return n;
            var i = n.clone();
            return (i.name += "_instance_" + e.uses[t]++), i;
          }),
          (q.prototype._invokeOne = function (e) {
            var t = Object.values(this.plugins);
            t.push(this);
            for (var n = 0; n < t.length; n++) {
              var i = e(t[n]);
              if (i) return i;
            }
          }),
          (q.prototype._invokeAll = function (e) {
            var t = Object.values(this.plugins);
            t.unshift(this);
            for (var n = [], i = 0; i < t.length; i++) {
              var r = e(t[i]);
              r && n.push(r);
            }
            return n;
          }),
          (q.prototype.getDependency = function (e, t) {
            var n = e + ":" + t,
              i = this.cache.get(n);
            if (!i) {
              switch (e) {
                case "scene":
                  i = this.loadScene(t);
                  break;
                case "node":
                  i = this.loadNode(t);
                  break;
                case "mesh":
                  i = this._invokeOne(function (e) {
                    return e.loadMesh && e.loadMesh(t);
                  });
                  break;
                case "accessor":
                  i = this.loadAccessor(t);
                  break;
                case "bufferView":
                  i = this._invokeOne(function (e) {
                    return e.loadBufferView && e.loadBufferView(t);
                  });
                  break;
                case "buffer":
                  i = this.loadBuffer(t);
                  break;
                case "material":
                  i = this._invokeOne(function (e) {
                    return e.loadMaterial && e.loadMaterial(t);
                  });
                  break;
                case "texture":
                  i = this._invokeOne(function (e) {
                    return e.loadTexture && e.loadTexture(t);
                  });
                  break;
                case "skin":
                  i = this.loadSkin(t);
                  break;
                case "animation":
                  i = this.loadAnimation(t);
                  break;
                case "camera":
                  i = this.loadCamera(t);
                  break;
                default:
                  throw new Error("Unknown type: " + e);
              }
              this.cache.add(n, i);
            }
            return i;
          }),
          (q.prototype.getDependencies = function (e) {
            var t = this.cache.get(e);
            if (!t) {
              var n = this,
                i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
              (t = Promise.all(
                i.map(function (t, i) {
                  return n.getDependency(e, i);
                })
              )),
                this.cache.add(e, t);
            }
            return t;
          }),
          (q.prototype.loadBuffer = function (e) {
            var t = this.json.buffers[e],
              n = this.fileLoader;
            if (t.type && "arraybuffer" !== t.type)
              throw new Error(
                "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
              );
            if (void 0 === t.uri && 0 === e)
              return Promise.resolve(this.extensions[h.KHR_BINARY_GLTF].body);
            var i = this.options;
            return new Promise(function (e, r) {
              n.load(B(t.uri, i.path), e, void 0, function () {
                r(
                  new Error(
                    'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
                  )
                );
              });
            });
          }),
          (q.prototype.loadBufferView = function (e) {
            var t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then(function (e) {
              var n = t.byteLength || 0,
                i = t.byteOffset || 0;
              return e.slice(i, i + n);
            });
          }),
          (q.prototype.loadAccessor = function (e) {
            var t = this,
              n = this.json,
              i = this.json.accessors[e];
            if (void 0 === i.bufferView && void 0 === i.sparse)
              return Promise.resolve(null);
            var r = [];
            return (
              void 0 !== i.bufferView
                ? r.push(this.getDependency("bufferView", i.bufferView))
                : r.push(null),
              void 0 !== i.sparse &&
                (r.push(
                  this.getDependency("bufferView", i.sparse.indices.bufferView)
                ),
                r.push(
                  this.getDependency("bufferView", i.sparse.values.bufferView)
                )),
              Promise.all(r).then(function (e) {
                var r,
                  a = e[0],
                  o = D[i.type],
                  s = k[i.componentType],
                  c = s.BYTES_PER_ELEMENT,
                  l = c * o,
                  h = i.byteOffset || 0,
                  u =
                    void 0 !== i.bufferView
                      ? n.bufferViews[i.bufferView].byteStride
                      : void 0,
                  p = !0 === i.normalized;
                if (u && u !== l) {
                  var d = Math.floor(h / u),
                    f =
                      "InterleavedBuffer:" +
                      i.bufferView +
                      ":" +
                      i.componentType +
                      ":" +
                      d +
                      ":" +
                      i.count,
                    m = t.cache.get(f);
                  m ||
                    ((m = new Rr(new s(a, d * u, (i.count * u) / c), u / c)),
                    t.cache.add(f, m)),
                    (r = new Cr(m, o, (h % u) / c, p));
                } else r = new yt(null === a ? new s(i.count * o) : new s(a, h, i.count * o), o, p);
                if (void 0 !== i.sparse) {
                  var g = D.SCALAR,
                    v = k[i.sparse.indices.componentType],
                    y = i.sparse.indices.byteOffset || 0,
                    _ = i.sparse.values.byteOffset || 0,
                    w = new v(e[1], y, i.sparse.count * g),
                    x = new s(e[2], _, i.sparse.count * o);
                  null !== a &&
                    (r = new yt(r.array.slice(), r.itemSize, r.normalized));
                  for (var b = 0, M = w.length; b < M; b++) {
                    var S = w[b];
                    if (
                      (r.setX(S, x[b * o]),
                      o >= 2 && r.setY(S, x[b * o + 1]),
                      o >= 3 && r.setZ(S, x[b * o + 2]),
                      o >= 4 && r.setW(S, x[b * o + 3]),
                      o >= 5)
                    )
                      throw new Error(
                        "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                      );
                  }
                }
                return r;
              })
            );
          }),
          (q.prototype.loadTexture = function (e) {
            var t,
              n,
              i = this.json,
              r = this.options,
              a = i.textures[e],
              o = a.extensions || {};
            return (
              (t = o[h.MSFT_TEXTURE_DDS]
                ? i.images[o[h.MSFT_TEXTURE_DDS].source]
                : i.images[a.source]).uri && (n = r.manager.getHandler(t.uri)),
              n ||
                (n = o[h.MSFT_TEXTURE_DDS]
                  ? this.extensions[h.MSFT_TEXTURE_DDS].ddsLoader
                  : this.textureLoader),
              this.loadTextureImage(e, t, n)
            );
          }),
          (q.prototype.loadTextureImage = function (e, n, i) {
            var r = this,
              a = this.json,
              o = this.options,
              l = a.textures[e],
              h = self.URL || self.webkitURL,
              u = n.uri,
              p = !1,
              d = !0;
            return (
              "image/jpeg" === n.mimeType && (d = !1),
              void 0 !== n.bufferView &&
                (u = r
                  .getDependency("bufferView", n.bufferView)
                  .then(function (e) {
                    if ("image/png" === n.mimeType) {
                      var t = new DataView(e, 25, 1).getUint8(0, !1);
                      d = 6 === t || 4 === t || 3 === t;
                    }
                    p = !0;
                    var i = new Blob([e], { type: n.mimeType });
                    return (u = h.createObjectURL(i));
                  })),
              Promise.resolve(u)
                .then(function (e) {
                  return new Promise(function (t, n) {
                    var r = t;
                    !0 === i.isImageBitmapLoader &&
                      (r = function (e) {
                        t(new Oa(e));
                      }),
                      i.load(B(e, o.path), r, void 0, n);
                  });
                })
                .then(function (n) {
                  !0 === p && h.revokeObjectURL(u),
                    (n.flipY = !1),
                    l.name && (n.name = l.name),
                    d || (n.format = f);
                  var i = (a.samplers || {})[l.sampler] || {};
                  return (
                    (n.magFilter = C[i.magFilter] || s),
                    (n.minFilter = C[i.minFilter] || c),
                    (n.wrapS = I[i.wrapS] || t),
                    (n.wrapT = I[i.wrapT] || t),
                    r.associations.set(n, { type: "textures", index: e }),
                    n
                  );
                })
            );
          }),
          (q.prototype.assignTexture = function (e, t, n) {
            var i = this;
            return this.getDependency("texture", n.index).then(function (r) {
              if (
                (void 0 === n.texCoord ||
                  0 == n.texCoord ||
                  ("aoMap" === t && 1 == n.texCoord) ||
                  console.warn(
                    "THREE.GLTFLoader: Custom UV set " +
                      n.texCoord +
                      " for texture " +
                      t +
                      " not yet supported."
                  ),
                i.extensions[h.KHR_TEXTURE_TRANSFORM])
              ) {
                var a =
                  void 0 !== n.extensions
                    ? n.extensions[h.KHR_TEXTURE_TRANSFORM]
                    : void 0;
                if (a) {
                  var o = i.associations.get(r);
                  (r = i.extensions[h.KHR_TEXTURE_TRANSFORM].extendTexture(
                    r,
                    a
                  )),
                    i.associations.set(r, o);
                }
              }
              e[t] = r;
            });
          }),
          (q.prototype.assignFinalMaterial = function (e) {
            var t = e.geometry,
              n = e.material,
              i = void 0 !== t.attributes.tangent,
              r = void 0 !== t.attributes.color,
              a = void 0 === t.attributes.normal,
              o = !0 === e.isSkinnedMesh,
              s = Object.keys(t.morphAttributes).length > 0,
              c = s && void 0 !== t.morphAttributes.normal;
            if (e.isPoints) {
              var l = "PointsMaterial:" + n.uuid,
                h = this.cache.get(l);
              h ||
                ((h = new Sa()),
                ft.prototype.copy.call(h, n),
                h.color.copy(n.color),
                (h.map = n.map),
                (h.sizeAttenuation = !1),
                this.cache.add(l, h)),
                (n = h);
            } else if (e.isLine) {
              l = "LineBasicMaterial:" + n.uuid;
              var u = this.cache.get(l);
              u ||
                ((u = new da()),
                ft.prototype.copy.call(u, n),
                u.color.copy(n.color),
                this.cache.add(l, u)),
                (n = u);
            }
            if (i || r || a || o || s) {
              (l = "ClonedMaterial:" + n.uuid + ":"),
                n.isGLTFSpecularGlossinessMaterial &&
                  (l += "specular-glossiness:"),
                o && (l += "skinning:"),
                i && (l += "vertex-tangents:"),
                r && (l += "vertex-colors:"),
                a && (l += "flat-shading:"),
                s && (l += "morph-targets:"),
                c && (l += "morph-normals:");
              var p = this.cache.get(l);
              p ||
                ((p = n.clone()),
                o && (p.skinning = !0),
                r && (p.vertexColors = !0),
                a && (p.flatShading = !0),
                s && (p.morphTargets = !0),
                c && (p.morphNormals = !0),
                i &&
                  ((p.vertexTangents = !0),
                  n.normalScale && (n.normalScale.y *= -1),
                  n.clearcoatNormalScale && (n.clearcoatNormalScale.y *= -1)),
                this.cache.add(l, p),
                this.associations.set(p, this.associations.get(n))),
                (n = p);
            }
            n.aoMap &&
              void 0 === t.attributes.uv2 &&
              void 0 !== t.attributes.uv &&
              t.setAttribute("uv2", t.attributes.uv),
              (e.material = n);
          }),
          (q.prototype.getMaterialType = function () {
            return mo;
          }),
          (q.prototype.loadMaterial = function (e) {
            var t,
              n = this,
              i = this.json,
              r = this.extensions,
              a = i.materials[e],
              o = {},
              s = a.extensions || {},
              c = [];
            if (s[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
              var l = r[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
              (t = l.getMaterialType()), c.push(l.extendParams(o, a, n));
            } else if (s[h.KHR_MATERIALS_UNLIT]) {
              var u = r[h.KHR_MATERIALS_UNLIT];
              (t = u.getMaterialType()), c.push(u.extendParams(o, a, n));
            } else {
              var p = a.pbrMetallicRoughness || {};
              if (
                ((o.color = new ut(1, 1, 1)),
                (o.opacity = 1),
                Array.isArray(p.baseColorFactor))
              ) {
                var d = p.baseColorFactor;
                o.color.fromArray(d), (o.opacity = d[3]);
              }
              void 0 !== p.baseColorTexture &&
                c.push(n.assignTexture(o, "map", p.baseColorTexture)),
                (o.metalness =
                  void 0 !== p.metallicFactor ? p.metallicFactor : 1),
                (o.roughness =
                  void 0 !== p.roughnessFactor ? p.roughnessFactor : 1),
                void 0 !== p.metallicRoughnessTexture &&
                  (c.push(
                    n.assignTexture(
                      o,
                      "metalnessMap",
                      p.metallicRoughnessTexture
                    )
                  ),
                  c.push(
                    n.assignTexture(
                      o,
                      "roughnessMap",
                      p.metallicRoughnessTexture
                    )
                  )),
                (t = this._invokeOne(function (t) {
                  return t.getMaterialType && t.getMaterialType(e);
                })),
                c.push(
                  Promise.all(
                    this._invokeAll(function (t) {
                      return (
                        t.extendMaterialParams && t.extendMaterialParams(e, o)
                      );
                    })
                  )
                );
            }
            !0 === a.doubleSided && (o.side = 2);
            var f = a.alphaMode || "OPAQUE";
            return (
              "BLEND" === f
                ? ((o.transparent = !0), (o.depthWrite = !1))
                : ((o.transparent = !1),
                  "MASK" === f &&
                    (o.alphaTest =
                      void 0 !== a.alphaCutoff ? a.alphaCutoff : 0.5)),
              void 0 !== a.normalTexture &&
                t !== mt &&
                (c.push(n.assignTexture(o, "normalMap", a.normalTexture)),
                (o.normalScale = new N(1, -1)),
                void 0 !== a.normalTexture.scale &&
                  o.normalScale.set(
                    a.normalTexture.scale,
                    -a.normalTexture.scale
                  )),
              void 0 !== a.occlusionTexture &&
                t !== mt &&
                (c.push(n.assignTexture(o, "aoMap", a.occlusionTexture)),
                void 0 !== a.occlusionTexture.strength &&
                  (o.aoMapIntensity = a.occlusionTexture.strength)),
              void 0 !== a.emissiveFactor &&
                t !== mt &&
                (o.emissive = new ut().fromArray(a.emissiveFactor)),
              void 0 !== a.emissiveTexture &&
                t !== mt &&
                c.push(n.assignTexture(o, "emissiveMap", a.emissiveTexture)),
              Promise.all(c).then(function () {
                var i;
                return (
                  (i =
                    t === A
                      ? r[
                          h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                        ].createMaterial(o)
                      : new t(o)),
                  a.name && (i.name = a.name),
                  i.map && (i.map.encoding = T),
                  i.emissiveMap && (i.emissiveMap.encoding = T),
                  U(i, a),
                  n.associations.set(i, { type: "materials", index: e }),
                  a.extensions && z(r, i, a),
                  i
                );
              })
            );
          }),
          (q.prototype.createUniqueName = function (e) {
            for (
              var t = lc.sanitizeNodeName(e || ""), n = t, i = 1;
              this.nodeNamesUsed[n];
              ++i
            )
              n = t + "_" + i;
            return (this.nodeNamesUsed[n] = !0), n;
          }),
          (q.prototype.loadGeometries = function (e) {
            var t = this,
              n = this.extensions,
              i = this.primitiveCache;
            function r(e) {
              return n[h.KHR_DRACO_MESH_COMPRESSION]
                .decodePrimitive(e, t)
                .then(function (n) {
                  return Y(n, e, t);
                });
            }
            for (var a, o, s = [], c = 0, l = e.length; c < l; c++) {
              var u,
                p = e[c],
                d =
                  (void 0,
                  (o =
                    (a = p).extensions &&
                    a.extensions[h.KHR_DRACO_MESH_COMPRESSION])
                    ? "draco:" +
                      o.bufferView +
                      ":" +
                      o.indices +
                      ":" +
                      V(o.attributes)
                    : a.indices + ":" + V(a.attributes) + ":" + a.mode),
                f = i[d];
              f
                ? s.push(f.promise)
                : ((u =
                    p.extensions && p.extensions[h.KHR_DRACO_MESH_COMPRESSION]
                      ? r(p)
                      : Y(new Ht(), p, t)),
                  (i[d] = { primitive: p, promise: u }),
                  s.push(u));
            }
            return Promise.all(s);
          }),
          (q.prototype.loadMesh = function (e) {
            for (
              var t,
                n = this,
                i = this.json,
                r = this.extensions,
                a = i.meshes[e],
                o = a.primitives,
                s = [],
                c = 0,
                l = o.length;
              c < l;
              c++
            ) {
              var h =
                void 0 === o[c].material
                  ? (void 0 === (t = this.cache).DefaultMaterial &&
                      (t.DefaultMaterial = new mo({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: 0,
                      })),
                    t.DefaultMaterial)
                  : this.getDependency("material", o[c].material);
              s.push(h);
            }
            return (
              s.push(n.loadGeometries(o)),
              Promise.all(s).then(function (t) {
                for (
                  var i = t.slice(0, t.length - 1),
                    s = t[t.length - 1],
                    c = [],
                    l = 0,
                    h = s.length;
                  l < h;
                  l++
                ) {
                  var u,
                    p = s[l],
                    d = o[l],
                    f = i[l];
                  if (
                    4 === d.mode ||
                    5 === d.mode ||
                    6 === d.mode ||
                    void 0 === d.mode
                  )
                    (u = !0 === a.isSkinnedMesh ? new ia(p, f) : new rn(p, f)),
                      !0 === f.isMeshStandardMaterial &&
                        2 === f.side &&
                        null !== p.getIndex() &&
                        !0 === p.hasAttribute("position") &&
                        !0 === p.hasAttribute("normal") &&
                        !0 === p.hasAttribute("uv") &&
                        !1 === p.hasAttribute("tangent") &&
                        (p.computeTangents(), (f.vertexTangents = !0)),
                      !0 !== u.isSkinnedMesh ||
                        u.geometry.attributes.skinWeight.normalized ||
                        u.normalizeSkinWeights(),
                      5 === d.mode
                        ? (u.geometry = J(u.geometry, 1))
                        : 6 === d.mode && (u.geometry = J(u.geometry, 2));
                  else if (1 === d.mode) u = new ba(p, f);
                  else if (3 === d.mode) u = new _a(p, f);
                  else if (2 === d.mode) u = new Ma(p, f);
                  else {
                    if (0 !== d.mode)
                      throw new Error(
                        "THREE.GLTFLoader: Primitive mode unsupported: " +
                          d.mode
                      );
                    u = new Pa(p, f);
                  }
                  Object.keys(u.geometry.morphAttributes).length > 0 && G(u, a),
                    (u.name = n.createUniqueName(a.name || "mesh_" + e)),
                    U(u, a),
                    d.extensions && z(r, u, d),
                    n.assignFinalMaterial(u),
                    c.push(u);
                }
                if (1 === c.length) return c[0];
                var m = new Mr();
                for (l = 0, h = c.length; l < h; l++) m.add(c[l]);
                return m;
              })
            );
          }),
          (q.prototype.loadCamera = function (e) {
            var t,
              n = this.json.cameras[e],
              i = n[n.type];
            if (i)
              return (
                "perspective" === n.type
                  ? (t = new pn(
                      O.radToDeg(i.yfov),
                      i.aspectRatio || 1,
                      i.znear || 1,
                      i.zfar || 2e6
                    ))
                  : "orthographic" === n.type &&
                    (t = new Es(
                      -i.xmag,
                      i.xmag,
                      i.ymag,
                      -i.ymag,
                      i.znear,
                      i.zfar
                    )),
                n.name && (t.name = this.createUniqueName(n.name)),
                U(t, n),
                Promise.resolve(t)
              );
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
          }),
          (q.prototype.loadSkin = function (e) {
            var t = this.json.skins[e],
              n = { joints: t.joints };
            return void 0 === t.inverseBindMatrices
              ? Promise.resolve(n)
              : this.getDependency("accessor", t.inverseBindMatrices).then(
                  function (e) {
                    return (n.inverseBindMatrices = e), n;
                  }
                );
          }),
          (q.prototype.loadAnimation = function (e) {
            for (
              var t = this.json.animations[e],
                n = [],
                i = [],
                r = [],
                a = [],
                o = [],
                s = 0,
                c = t.channels.length;
              s < c;
              s++
            ) {
              var l = t.channels[s],
                h = t.samplers[l.sampler],
                u = l.target,
                p = void 0 !== u.node ? u.node : u.id,
                d = void 0 !== t.parameters ? t.parameters[h.input] : h.input,
                f = void 0 !== t.parameters ? t.parameters[h.output] : h.output;
              n.push(this.getDependency("node", p)),
                i.push(this.getDependency("accessor", d)),
                r.push(this.getDependency("accessor", f)),
                a.push(h),
                o.push(u);
            }
            return Promise.all([
              Promise.all(n),
              Promise.all(i),
              Promise.all(r),
              Promise.all(a),
              Promise.all(o),
            ]).then(function (n) {
              for (
                var i = n[0],
                  r = n[1],
                  a = n[2],
                  o = n[3],
                  s = n[4],
                  c = [],
                  l = 0,
                  h = i.length;
                l < h;
                l++
              ) {
                var u = i[l],
                  p = r[l],
                  d = a[l],
                  f = o[l],
                  m = s[l];
                if (void 0 !== u) {
                  var g;
                  switch (
                    (u.updateMatrix(), (u.matrixAutoUpdate = !0), F[m.path])
                  ) {
                    case F.weights:
                      g = Co;
                      break;
                    case F.rotation:
                      g = No;
                      break;
                    case F.position:
                    case F.scale:
                    default:
                      g = Do;
                  }
                  var v = u.name ? u.name : u.uuid,
                    y = void 0 !== f.interpolation ? H[f.interpolation] : _,
                    w = [];
                  F[m.path] === F.weights
                    ? u.traverse(function (e) {
                        !0 === e.isMesh &&
                          e.morphTargetInfluences &&
                          w.push(e.name ? e.name : e.uuid);
                      })
                    : w.push(v);
                  var x = d.array;
                  if (d.normalized) {
                    var b;
                    if (x.constructor === Int8Array) b = 1 / 127;
                    else if (x.constructor === Uint8Array) b = 1 / 255;
                    else if (x.constructor == Int16Array) b = 1 / 32767;
                    else {
                      if (x.constructor !== Uint16Array)
                        throw new Error(
                          "THREE.GLTFLoader: Unsupported output accessor component type."
                        );
                      b = 1 / 65535;
                    }
                    for (
                      var M = new Float32Array(x.length), S = 0, T = x.length;
                      S < T;
                      S++
                    )
                      M[S] = x[S] * b;
                    x = M;
                  }
                  for (S = 0, T = w.length; S < T; S++) {
                    var E = new g(w[S] + "." + F[m.path], p.array, x, y);
                    "CUBICSPLINE" === f.interpolation &&
                      ((E.createInterpolant = function (e) {
                        return new R(
                          this.times,
                          this.values,
                          this.getValueSize() / 3,
                          e
                        );
                      }),
                      (E.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                        !0)),
                      c.push(E);
                  }
                }
              }
              return new jo(t.name ? t.name : "animation_" + e, void 0, c);
            });
          }),
          (q.prototype.loadNode = function (e) {
            var t,
              n = this.json,
              i = this.extensions,
              r = this,
              a = n.nodes[e],
              o = a.name ? r.createUniqueName(a.name) : "";
            return ((t = []),
            void 0 !== a.mesh &&
              t.push(
                r.getDependency("mesh", a.mesh).then(function (e) {
                  var t = r._getNodeRef(r.meshCache, a.mesh, e);
                  return (
                    void 0 !== a.weights &&
                      t.traverse(function (e) {
                        if (e.isMesh)
                          for (var t = 0, n = a.weights.length; t < n; t++)
                            e.morphTargetInfluences[t] = a.weights[t];
                      }),
                    t
                  );
                })
              ),
            void 0 !== a.camera &&
              t.push(
                r.getDependency("camera", a.camera).then(function (e) {
                  return r._getNodeRef(r.cameraCache, a.camera, e);
                })
              ),
            r
              ._invokeAll(function (t) {
                return t.createNodeAttachment && t.createNodeAttachment(e);
              })
              .forEach(function (e) {
                t.push(e);
              }),
            Promise.all(t)).then(function (t) {
              var n;
              if (
                (n =
                  !0 === a.isBone
                    ? new ra()
                    : t.length > 1
                    ? new Mr()
                    : 1 === t.length
                    ? t[0]
                    : new Ge()) !== t[0]
              )
                for (var s = 0, c = t.length; s < c; s++) n.add(t[s]);
              if (
                (a.name && ((n.userData.name = a.name), (n.name = o)),
                U(n, a),
                a.extensions && z(i, n, a),
                void 0 !== a.matrix)
              ) {
                var l = new ye();
                l.fromArray(a.matrix), n.applyMatrix4(l);
              } else void 0 !== a.translation && n.position.fromArray(a.translation), void 0 !== a.rotation && n.quaternion.fromArray(a.rotation), void 0 !== a.scale && n.scale.fromArray(a.scale);
              return r.associations.set(n, { type: "nodes", index: e }), n;
            });
          }),
          (q.prototype.loadScene = (function () {
            function e(t, n, i, r) {
              var a = i.nodes[t];
              return r
                .getDependency("node", t)
                .then(function (e) {
                  return void 0 === a.skin
                    ? e
                    : r
                        .getDependency("skin", a.skin)
                        .then(function (e) {
                          for (
                            var n = [], i = 0, a = (t = e).joints.length;
                            i < a;
                            i++
                          )
                            n.push(r.getDependency("node", t.joints[i]));
                          return Promise.all(n);
                        })
                        .then(function (n) {
                          return (
                            e.traverse(function (e) {
                              if (e.isMesh) {
                                for (
                                  var i = [], r = [], a = 0, o = n.length;
                                  a < o;
                                  a++
                                ) {
                                  var s = n[a];
                                  if (s) {
                                    i.push(s);
                                    var c = new ye();
                                    void 0 !== t.inverseBindMatrices &&
                                      c.fromArray(
                                        t.inverseBindMatrices.array,
                                        16 * a
                                      ),
                                      r.push(c);
                                  } else
                                    console.warn(
                                      'THREE.GLTFLoader: Joint "%s" could not be found.',
                                      t.joints[a]
                                    );
                                }
                                e.bind(new sa(i, r), e.matrixWorld);
                              }
                            }),
                            e
                          );
                        });
                  var t;
                })
                .then(function (t) {
                  n.add(t);
                  var o = [];
                  if (a.children)
                    for (var s = a.children, c = 0, l = s.length; c < l; c++) {
                      var h = s[c];
                      o.push(e(h, t, i, r));
                    }
                  return Promise.all(o);
                });
            }
            return function (t) {
              var n = this.json,
                i = this.extensions,
                r = this.json.scenes[t],
                a = new Mr();
              r.name && (a.name = this.createUniqueName(r.name)),
                U(a, r),
                r.extensions && z(i, a, r);
              for (
                var o = r.nodes || [], s = [], c = 0, l = o.length;
                c < l;
                c++
              )
                s.push(e(o[c], a, n, this));
              return Promise.all(s).then(function () {
                return a;
              });
            };
          })()),
          e
        );
      })();
      function Dc(e) {
        if (void 0 === e)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return e;
      }
      function jc(e, t) {
        (e.prototype = Object.create(t.prototype)),
          (e.prototype.constructor = e),
          (e.__proto__ = t);
      }
      var Fc,
        Hc,
        Bc,
        zc,
        Uc,
        Gc,
        Wc,
        Vc,
        qc,
        Xc,
        Yc,
        Jc,
        Zc,
        Qc = {
          autoSleep: 120,
          force3D: "auto",
          nullTargetWarn: 1,
          units: { lineHeight: "" },
        },
        Kc = { duration: 0.5, overwrite: !1, delay: 0 },
        $c = 1e8,
        el = 1e-8,
        tl = 2 * Math.PI,
        nl = tl / 4,
        il = 0,
        rl = Math.sqrt,
        al = Math.cos,
        ol = Math.sin,
        sl = function (e) {
          return "string" == typeof e;
        },
        cl = function (e) {
          return "function" == typeof e;
        },
        ll = function (e) {
          return "number" == typeof e;
        },
        hl = function (e) {
          return void 0 === e;
        },
        ul = function (e) {
          return "object" == typeof e;
        },
        pl = function (e) {
          return !1 !== e;
        },
        dl = function () {
          return "undefined" != typeof window;
        },
        fl = function (e) {
          return cl(e) || sl(e);
        },
        ml =
          ("function" == typeof ArrayBuffer && ArrayBuffer.isView) ||
          function () {},
        gl = Array.isArray,
        vl = /(?:-?\.?\d|\.)+/gi,
        yl = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        _l = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        wl = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        xl = /[+-]=-?[.\d]+/,
        bl = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
        Ml = /[\d.+\-=]+(?:e[-+]\d*)*/i,
        Sl = {},
        Tl = {},
        El = function (e) {
          return (Tl = Kl(e, Sl)) && Du;
        },
        Al = function (e, t) {
          return console.warn(
            "Invalid property",
            e,
            "set to",
            t,
            "Missing plugin? gsap.registerPlugin()"
          );
        },
        Ll = function (e, t) {
          return !t && console.warn(e);
        },
        Pl = function (e, t) {
          return (e && (Sl[e] = t) && Tl && (Tl[e] = t)) || Sl;
        },
        Rl = function () {
          return 0;
        },
        kl = {},
        Cl = [],
        Ol = {},
        Nl = {},
        Il = {},
        Dl = 30,
        jl = [],
        Fl = "",
        Hl = function (e) {
          var t,
            n,
            i = e[0];
          if ((ul(i) || cl(i) || (e = [e]), !(t = (i._gsap || {}).harness))) {
            for (n = jl.length; n-- && !jl[n].targetTest(i); );
            t = jl[n];
          }
          for (n = e.length; n--; )
            (e[n] && (e[n]._gsap || (e[n]._gsap = new su(e[n], t)))) ||
              e.splice(n, 1);
          return e;
        },
        Bl = function (e) {
          return e._gsap || Hl(Eh(e))[0]._gsap;
        },
        zl = function (e, t, n) {
          return (n = e[t]) && cl(n)
            ? e[t]()
            : (hl(n) && e.getAttribute && e.getAttribute(t)) || n;
        },
        Ul = function (e, t) {
          return (e = e.split(",")).forEach(t) || e;
        },
        Gl = function (e) {
          return Math.round(1e5 * e) / 1e5 || 0;
        },
        Wl = function (e, t) {
          for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; );
          return i < n;
        },
        Vl = function (e, t, n) {
          var i,
            r = ll(e[1]),
            a = (r ? 2 : 1) + (t < 2 ? 0 : 1),
            o = e[a];
          if ((r && (o.duration = e[1]), (o.parent = n), t)) {
            for (i = o; n && !("immediateRender" in i); )
              (i = n.vars.defaults || {}), (n = pl(n.vars.inherit) && n.parent);
            (o.immediateRender = pl(i.immediateRender)),
              t < 2 ? (o.runBackwards = 1) : (o.startAt = e[a - 1]);
          }
          return o;
        },
        ql = function () {
          var e,
            t,
            n = Cl.length,
            i = Cl.slice(0);
          for (Ol = {}, Cl.length = 0, e = 0; e < n; e++)
            (t = i[e]) &&
              t._lazy &&
              (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0);
        },
        Xl = function (e, t, n, i) {
          Cl.length && ql(), e.render(t, n, i), Cl.length && ql();
        },
        Yl = function (e) {
          var t = parseFloat(e);
          return (t || 0 === t) && (e + "").match(bl).length < 2
            ? t
            : sl(e)
            ? e.trim()
            : e;
        },
        Jl = function (e) {
          return e;
        },
        Zl = function (e, t) {
          for (var n in t) n in e || (e[n] = t[n]);
          return e;
        },
        Ql = function (e, t) {
          for (var n in t)
            n in e || "duration" === n || "ease" === n || (e[n] = t[n]);
        },
        Kl = function (e, t) {
          for (var n in t) e[n] = t[n];
          return e;
        },
        $l = function e(t, n) {
          for (var i in n)
            "__proto__" !== i &&
              "constructor" !== i &&
              "prototype" !== i &&
              (t[i] = ul(n[i]) ? e(t[i] || (t[i] = {}), n[i]) : n[i]);
          return t;
        },
        eh = function (e, t) {
          var n,
            i = {};
          for (n in e) n in t || (i[n] = e[n]);
          return i;
        },
        th = function (e) {
          var t = e.parent || Hc,
            n = e.keyframes ? Ql : Zl;
          if (pl(e.inherit))
            for (; t; ) n(e, t.vars.defaults), (t = t.parent || t._dp);
          return e;
        },
        nh = function (e, t, n, i) {
          void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
          var r = t._prev,
            a = t._next;
          r ? (r._next = a) : e[n] === t && (e[n] = a),
            a ? (a._prev = r) : e[i] === t && (e[i] = r),
            (t._next = t._prev = t.parent = null);
        },
        ih = function (e, t) {
          e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove(e),
            (e._act = 0);
        },
        rh = function (e, t) {
          if (e && (!t || t._end > e._dur || t._start < 0))
            for (var n = e; n; ) (n._dirty = 1), (n = n.parent);
          return e;
        },
        ah = function (e) {
          for (var t = e.parent; t && t.parent; )
            (t._dirty = 1), t.totalDuration(), (t = t.parent);
          return e;
        },
        oh = function e(t) {
          return !t || (t._ts && e(t.parent));
        },
        sh = function (e) {
          return e._repeat
            ? ch(e._tTime, (e = e.duration() + e._rDelay)) * e
            : 0;
        },
        ch = function (e, t) {
          var n = Math.floor((e /= t));
          return e && n === e ? n - 1 : n;
        },
        lh = function (e, t) {
          return (
            (e - t._start) * t._ts +
            (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
          );
        },
        hh = function (e) {
          return (e._end = Gl(
            e._start + (e._tDur / Math.abs(e._ts || e._rts || el) || 0)
          ));
        },
        uh = function (e, t) {
          var n = e._dp;
          return (
            n &&
              n.smoothChildTiming &&
              e._ts &&
              ((e._start = Gl(
                n._time -
                  (e._ts > 0
                    ? t / e._ts
                    : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)
              )),
              hh(e),
              n._dirty || rh(n, e)),
            e
          );
        },
        ph = function (e, t) {
          var n;
          if (
            ((t._time || (t._initted && !t._dur)) &&
              ((n = lh(e.rawTime(), t)),
              (!t._dur || bh(0, t.totalDuration(), n) - t._tTime > el) &&
                t.render(n, !0)),
            rh(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
          ) {
            if (e._dur < e.duration())
              for (n = e; n._dp; )
                n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
            e._zTime = -1e-8;
          }
        },
        dh = function (e, t, n, i) {
          return (
            t.parent && ih(t),
            (t._start = Gl(n + t._delay)),
            (t._end = Gl(
              t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
            )),
            (function (e, t, n, i, r) {
              void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
              var a,
                o = e[i];
              if (r) for (a = t[r]; o && o[r] > a; ) o = o._prev;
              o
                ? ((t._next = o._next), (o._next = t))
                : ((t._next = e[n]), (e[n] = t)),
                t._next ? (t._next._prev = t) : (e[i] = t),
                (t._prev = o),
                (t.parent = t._dp = e);
            })(e, t, "_first", "_last", e._sort ? "_start" : 0),
            (e._recent = t),
            i || ph(e, t),
            e
          );
        },
        fh = function (e, t) {
          return (
            (Sl.ScrollTrigger || Al("scrollTrigger", t)) &&
            Sl.ScrollTrigger.create(t, e)
          );
        },
        mh = function (e, t, n, i) {
          return (
            fu(e, t),
            e._initted
              ? !n &&
                e._pt &&
                ((e._dur && !1 !== e.vars.lazy) || (!e._dur && e.vars.lazy)) &&
                Wc !== Yh.frame
                ? (Cl.push(e), (e._lazy = [t, i]), 1)
                : void 0
              : 1
          );
        },
        gh = function e(t) {
          var n = t.parent;
          return (
            n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n))
          );
        },
        vh = function (e, t, n, i) {
          var r = e._repeat,
            a = Gl(t) || 0,
            o = e._tTime / e._tDur;
          return (
            o && !i && (e._time *= a / e._dur),
            (e._dur = a),
            (e._tDur = r
              ? r < 0
                ? 1e10
                : Gl(a * (r + 1) + e._rDelay * r)
              : a),
            o && !i ? uh(e, (e._tTime = e._tDur * o)) : e.parent && hh(e),
            n || rh(e.parent, e),
            e
          );
        },
        yh = function (e) {
          return e instanceof lu ? rh(e) : vh(e, e._dur);
        },
        _h = { _start: 0, endTime: Rl },
        wh = function e(t, n) {
          var i,
            r,
            a = t.labels,
            o = t._recent || _h,
            s = t.duration() >= $c ? o.endTime(!1) : t._dur;
          return sl(n) && (isNaN(n) || n in a)
            ? "<" === (i = n.charAt(0)) || ">" === i
              ? ("<" === i ? o._start : o.endTime(o._repeat >= 0)) +
                (parseFloat(n.substr(1)) || 0)
              : (i = n.indexOf("=")) < 0
              ? (n in a || (a[n] = s), a[n])
              : ((r = +(n.charAt(i - 1) + n.substr(i + 1))),
                i > 1 ? e(t, n.substr(0, i - 1)) + r : s + r)
            : null == n
            ? s
            : +n;
        },
        xh = function (e, t) {
          return e || 0 === e ? t(e) : t;
        },
        bh = function (e, t, n) {
          return n < e ? e : n > t ? t : n;
        },
        Mh = function (e) {
          if ("string" != typeof e) return "";
          var t = Ml.exec(e);
          return t ? e.substr(t.index + t[0].length) : "";
        },
        Sh = [].slice,
        Th = function (e, t) {
          return (
            e &&
            ul(e) &&
            "length" in e &&
            ((!t && !e.length) || (e.length - 1 in e && ul(e[0]))) &&
            !e.nodeType &&
            e !== Bc
          );
        },
        Eh = function (e, t) {
          return !sl(e) || t || (!zc && Jh())
            ? gl(e)
              ? (function (e, t, n) {
                  return (
                    void 0 === n && (n = []),
                    e.forEach(function (e) {
                      var i;
                      return (sl(e) && !t) || Th(e, 1)
                        ? (i = n).push.apply(i, Eh(e))
                        : n.push(e);
                    }) || n
                  );
                })(e, t)
              : Th(e)
              ? Sh.call(e, 0)
              : e
              ? [e]
              : []
            : Sh.call(Uc.querySelectorAll(e), 0);
        },
        Ah = function (e) {
          return e.sort(function () {
            return 0.5 - Math.random();
          });
        },
        Lh = function (e) {
          if (cl(e)) return e;
          var t = ul(e) ? e : { each: e },
            n = nu(t.ease),
            i = t.from || 0,
            r = parseFloat(t.base) || 0,
            a = {},
            o = i > 0 && i < 1,
            s = isNaN(i) || o,
            c = t.axis,
            l = i,
            h = i;
          return (
            sl(i)
              ? (l = h = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
              : !o && s && ((l = i[0]), (h = i[1])),
            function (e, o, u) {
              var p,
                d,
                f,
                m,
                g,
                v,
                y,
                _,
                w,
                x = (u || t).length,
                b = a[x];
              if (!b) {
                if (!(w = "auto" === t.grid ? 0 : (t.grid || [1, $c])[1])) {
                  for (
                    y = -$c;
                    y < (y = u[w++].getBoundingClientRect().left) && w < x;

                  );
                  w--;
                }
                for (
                  b = a[x] = [],
                    p = s ? Math.min(w, x) * l - 0.5 : i % w,
                    d = s ? (x * h) / w - 0.5 : (i / w) | 0,
                    y = 0,
                    _ = $c,
                    v = 0;
                  v < x;
                  v++
                )
                  (f = (v % w) - p),
                    (m = d - ((v / w) | 0)),
                    (b[v] = g =
                      c ? Math.abs("y" === c ? m : f) : rl(f * f + m * m)),
                    g > y && (y = g),
                    g < _ && (_ = g);
                "random" === i && Ah(b),
                  (b.max = y - _),
                  (b.min = _),
                  (b.v = x =
                    (parseFloat(t.amount) ||
                      parseFloat(t.each) *
                        (w > x
                          ? x - 1
                          : c
                          ? "y" === c
                            ? x / w
                            : w
                          : Math.max(w, x / w)) ||
                      0) * ("edges" === i ? -1 : 1)),
                  (b.b = x < 0 ? r - x : r),
                  (b.u = Mh(t.amount || t.each) || 0),
                  (n = n && x < 0 ? eu(n) : n);
              }
              return (
                (x = (b[e] - b.min) / b.max || 0),
                Gl(b.b + (n ? n(x) : x) * b.v) + b.u
              );
            }
          );
        },
        Ph = function (e) {
          var t = e < 1 ? Math.pow(10, (e + "").length - 2) : 1;
          return function (n) {
            var i = Math.round(parseFloat(n) / e) * e * t;
            return (i - (i % 1)) / t + (ll(n) ? 0 : Mh(n));
          };
        },
        Rh = function (e, t) {
          var n,
            i,
            r = gl(e);
          return (
            !r &&
              ul(e) &&
              ((n = r = e.radius || $c),
              e.values
                ? ((e = Eh(e.values)), (i = !ll(e[0])) && (n *= n))
                : (e = Ph(e.increment))),
            xh(
              t,
              r
                ? cl(e)
                  ? function (t) {
                      return (i = e(t)), Math.abs(i - t) <= n ? i : t;
                    }
                  : function (t) {
                      for (
                        var r,
                          a,
                          o = parseFloat(i ? t.x : t),
                          s = parseFloat(i ? t.y : 0),
                          c = $c,
                          l = 0,
                          h = e.length;
                        h--;

                      )
                        (r = i
                          ? (r = e[h].x - o) * r + (a = e[h].y - s) * a
                          : Math.abs(e[h] - o)) < c && ((c = r), (l = h));
                      return (
                        (l = !n || c <= n ? e[l] : t),
                        i || l === t || ll(t) ? l : l + Mh(t)
                      );
                    }
                : Ph(e)
            )
          );
        },
        kh = function (e, t, n, i) {
          return xh(gl(e) ? !t : !0 === n ? !!(n = 0) : !i, function () {
            return gl(e)
              ? e[~~(Math.random() * e.length)]
              : (n = n || 1e-5) &&
                  (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
                  Math.floor(
                    Math.round(
                      (e - n / 2 + Math.random() * (t - e + 0.99 * n)) / n
                    ) *
                      n *
                      i
                  ) / i;
          });
        },
        Ch = function (e, t, n) {
          return xh(n, function (n) {
            return e[~~t(n)];
          });
        },
        Oh = function (e) {
          for (var t, n, i, r, a = 0, o = ""; ~(t = e.indexOf("random(", a)); )
            (i = e.indexOf(")", t)),
              (r = "[" === e.charAt(t + 7)),
              (n = e.substr(t + 7, i - t - 7).match(r ? bl : vl)),
              (o +=
                e.substr(a, t - a) +
                kh(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)),
              (a = i + 1);
          return o + e.substr(a, e.length - a);
        },
        Nh = function (e, t, n, i, r) {
          var a = t - e,
            o = i - n;
          return xh(r, function (t) {
            return n + (((t - e) / a) * o || 0);
          });
        },
        Ih = function (e, t, n) {
          var i,
            r,
            a,
            o = e.labels,
            s = $c;
          for (i in o)
            (r = o[i] - t) < 0 == !!n &&
              r &&
              s > (r = Math.abs(r)) &&
              ((a = i), (s = r));
          return a;
        },
        Dh = function (e, t, n) {
          var i,
            r,
            a = e.vars,
            o = a[t];
          if (o)
            return (
              (i = a[t + "Params"]),
              (r = a.callbackScope || e),
              n && Cl.length && ql(),
              i ? o.apply(r, i) : o.call(r)
            );
        },
        jh = function (e) {
          return ih(e), e.progress() < 1 && Dh(e, "onInterrupt"), e;
        },
        Fh = function (e) {
          var t = (e = (!e.name && e.default) || e).name,
            n = cl(e),
            i =
              t && !n && e.init
                ? function () {
                    this._props = [];
                  }
                : e,
            r = {
              init: Rl,
              render: Au,
              add: pu,
              kill: Pu,
              modifier: Lu,
              rawVars: 0,
            },
            a = {
              targetTest: 0,
              get: 0,
              getSetter: Mu,
              aliases: {},
              register: 0,
            };
          if ((Jh(), e !== i)) {
            if (Nl[t]) return;
            Zl(i, Zl(eh(e, r), a)),
              Kl(i.prototype, Kl(r, eh(e, a))),
              (Nl[(i.prop = t)] = i),
              e.targetTest && (jl.push(i), (kl[t] = 1)),
              (t =
                ("css" === t
                  ? "CSS"
                  : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin");
          }
          Pl(t, i), e.register && e.register(Du, i, Cu);
        },
        Hh = 255,
        Bh = {
          aqua: [0, Hh, Hh],
          lime: [0, Hh, 0],
          silver: [192, 192, 192],
          black: [0, 0, 0],
          maroon: [128, 0, 0],
          teal: [0, 128, 128],
          blue: [0, 0, Hh],
          navy: [0, 0, 128],
          white: [Hh, Hh, Hh],
          olive: [128, 128, 0],
          yellow: [Hh, Hh, 0],
          orange: [Hh, 165, 0],
          gray: [128, 128, 128],
          purple: [128, 0, 128],
          green: [0, 128, 0],
          red: [Hh, 0, 0],
          pink: [Hh, 192, 203],
          cyan: [0, Hh, Hh],
          transparent: [Hh, Hh, Hh, 0],
        },
        zh = function (e, t, n) {
          return (
            ((6 * (e = e < 0 ? e + 1 : e > 1 ? e - 1 : e) < 1
              ? t + (n - t) * e * 6
              : e < 0.5
              ? n
              : 3 * e < 2
              ? t + (n - t) * (2 / 3 - e) * 6
              : t) *
              Hh +
              0.5) |
            0
          );
        },
        Uh = function (e, t, n) {
          var i,
            r,
            a,
            o,
            s,
            c,
            l,
            h,
            u,
            p,
            d = e ? (ll(e) ? [e >> 16, (e >> 8) & Hh, e & Hh] : 0) : Bh.black;
          if (!d) {
            if (
              ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), Bh[e])
            )
              d = Bh[e];
            else if ("#" === e.charAt(0)) {
              if (
                (e.length < 6 &&
                  ((i = e.charAt(1)),
                  (r = e.charAt(2)),
                  (a = e.charAt(3)),
                  (e =
                    "#" +
                    i +
                    i +
                    r +
                    r +
                    a +
                    a +
                    (5 === e.length ? e.charAt(4) + e.charAt(4) : ""))),
                9 === e.length)
              )
                return [
                  (d = parseInt(e.substr(1, 6), 16)) >> 16,
                  (d >> 8) & Hh,
                  d & Hh,
                  parseInt(e.substr(7), 16) / 255,
                ];
              d = [
                (e = parseInt(e.substr(1), 16)) >> 16,
                (e >> 8) & Hh,
                e & Hh,
              ];
            } else if ("hsl" === e.substr(0, 3))
              if (((d = p = e.match(vl)), t)) {
                if (~e.indexOf("="))
                  return (d = e.match(yl)), n && d.length < 4 && (d[3] = 1), d;
              } else
                (o = (+d[0] % 360) / 360),
                  (s = +d[1] / 100),
                  (i =
                    2 * (c = +d[2] / 100) -
                    (r = c <= 0.5 ? c * (s + 1) : c + s - c * s)),
                  d.length > 3 && (d[3] *= 1),
                  (d[0] = zh(o + 1 / 3, i, r)),
                  (d[1] = zh(o, i, r)),
                  (d[2] = zh(o - 1 / 3, i, r));
            else d = e.match(vl) || Bh.transparent;
            d = d.map(Number);
          }
          return (
            t &&
              !p &&
              ((i = d[0] / Hh),
              (r = d[1] / Hh),
              (a = d[2] / Hh),
              (c = ((l = Math.max(i, r, a)) + (h = Math.min(i, r, a))) / 2),
              l === h
                ? (o = s = 0)
                : ((u = l - h),
                  (s = c > 0.5 ? u / (2 - l - h) : u / (l + h)),
                  (o =
                    l === i
                      ? (r - a) / u + (r < a ? 6 : 0)
                      : l === r
                      ? (a - i) / u + 2
                      : (i - r) / u + 4),
                  (o *= 60)),
              (d[0] = ~~(o + 0.5)),
              (d[1] = ~~(100 * s + 0.5)),
              (d[2] = ~~(100 * c + 0.5))),
            n && d.length < 4 && (d[3] = 1),
            d
          );
        },
        Gh = function (e) {
          var t = [],
            n = [],
            i = -1;
          return (
            e.split(Vh).forEach(function (e) {
              var r = e.match(_l) || [];
              t.push.apply(t, r), n.push((i += r.length + 1));
            }),
            (t.c = n),
            t
          );
        },
        Wh = function (e, t, n) {
          var i,
            r,
            a,
            o,
            s = "",
            c = (e + s).match(Vh),
            l = t ? "hsla(" : "rgba(",
            h = 0;
          if (!c) return e;
          if (
            ((c = c.map(function (e) {
              return (
                (e = Uh(e, t, 1)) &&
                l +
                  (t
                    ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3]
                    : e.join(",")) +
                  ")"
              );
            })),
            n && ((a = Gh(e)), (i = n.c).join(s) !== a.c.join(s)))
          )
            for (o = (r = e.replace(Vh, "1").split(_l)).length - 1; h < o; h++)
              s +=
                r[h] +
                (~i.indexOf(h)
                  ? c.shift() || l + "0,0,0,0)"
                  : (a.length ? a : c.length ? c : n).shift());
          if (!r)
            for (o = (r = e.split(Vh)).length - 1; h < o; h++) s += r[h] + c[h];
          return s + r[o];
        },
        Vh = (function () {
          var e,
            t =
              "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
          for (e in Bh) t += "|" + e + "\\b";
          return new RegExp(t + ")", "gi");
        })(),
        qh = /hsl[a]?\(/,
        Xh = function (e) {
          var t,
            n = e.join(" ");
          if (((Vh.lastIndex = 0), Vh.test(n)))
            return (
              (t = qh.test(n)),
              (e[1] = Wh(e[1], t)),
              (e[0] = Wh(e[0], t, Gh(e[1]))),
              !0
            );
        },
        Yh = (function () {
          var e,
            t,
            n,
            i,
            r,
            a,
            o = Date.now,
            s = 500,
            c = 33,
            l = o(),
            h = l,
            u = 1e3 / 240,
            p = u,
            d = [],
            f = function n(f) {
              var m,
                g,
                v,
                y,
                _ = o() - h,
                w = !0 === f;
              if (
                (_ > s && (l += _ - c),
                ((m = (v = (h += _) - l) - p) > 0 || w) &&
                  ((y = ++i.frame),
                  (r = v - 1e3 * i.time),
                  (i.time = v /= 1e3),
                  (p += m + (m >= u ? 4 : u - m)),
                  (g = 1)),
                w || (e = t(n)),
                g)
              )
                for (a = 0; a < d.length; a++) d[a](v, r, y, f);
            };
          return (i = {
            time: 0,
            frame: 0,
            tick: function () {
              f(!0);
            },
            deltaRatio: function (e) {
              return r / (1e3 / (e || 60));
            },
            wake: function () {
              Gc &&
                (!zc &&
                  dl() &&
                  ((Bc = zc = window),
                  (Uc = Bc.document || {}),
                  (Sl.gsap = Du),
                  (Bc.gsapVersions || (Bc.gsapVersions = [])).push(Du.version),
                  El(Tl || Bc.GreenSockGlobals || (!Bc.gsap && Bc) || {}),
                  (n = Bc.requestAnimationFrame)),
                e && i.sleep(),
                (t =
                  n ||
                  function (e) {
                    return setTimeout(e, (p - 1e3 * i.time + 1) | 0);
                  }),
                (qc = 1),
                f(2));
            },
            sleep: function () {
              (n ? Bc.cancelAnimationFrame : clearTimeout)(e),
                (qc = 0),
                (t = Rl);
            },
            lagSmoothing: function (e, t) {
              (s = e || 1e8), (c = Math.min(t, s, 0));
            },
            fps: function (e) {
              (u = 1e3 / (e || 240)), (p = 1e3 * i.time + u);
            },
            add: function (e) {
              d.indexOf(e) < 0 && d.push(e), Jh();
            },
            remove: function (e) {
              var t;
              ~(t = d.indexOf(e)) && d.splice(t, 1) && a >= t && a--;
            },
            _listeners: d,
          });
        })(),
        Jh = function () {
          return !qc && Yh.wake();
        },
        Zh = {},
        Qh = /^[\d.\-M][\d.\-,\s]/,
        Kh = /["']/g,
        $h = function (e) {
          for (
            var t,
              n,
              i,
              r = {},
              a = e.substr(1, e.length - 3).split(":"),
              o = a[0],
              s = 1,
              c = a.length;
            s < c;
            s++
          )
            (n = a[s]),
              (t = s !== c - 1 ? n.lastIndexOf(",") : n.length),
              (i = n.substr(0, t)),
              (r[o] = isNaN(i) ? i.replace(Kh, "").trim() : +i),
              (o = n.substr(t + 1).trim());
          return r;
        },
        eu = function (e) {
          return function (t) {
            return 1 - e(1 - t);
          };
        },
        tu = function e(t, n) {
          for (var i, r = t._first; r; )
            r instanceof lu
              ? e(r, n)
              : !r.vars.yoyoEase ||
                (r._yoyo && r._repeat) ||
                r._yoyo === n ||
                (r.timeline
                  ? e(r.timeline, n)
                  : ((i = r._ease),
                    (r._ease = r._yEase),
                    (r._yEase = i),
                    (r._yoyo = n))),
              (r = r._next);
        },
        nu = function (e, t) {
          return (
            (e &&
              (cl(e)
                ? e
                : Zh[e] ||
                  (function (e) {
                    var t,
                      n,
                      i,
                      r,
                      a = (e + "").split("("),
                      o = Zh[a[0]];
                    return o && a.length > 1 && o.config
                      ? o.config.apply(
                          null,
                          ~e.indexOf("{")
                            ? [$h(a[1])]
                            : ((t = e),
                              (n = t.indexOf("(") + 1),
                              (i = t.indexOf(")")),
                              (r = t.indexOf("(", n)),
                              t.substring(
                                n,
                                ~r && r < i ? t.indexOf(")", i + 1) : i
                              ))
                                .split(",")
                                .map(Yl)
                        )
                      : Zh._CE && Qh.test(e)
                      ? Zh._CE("", e)
                      : o;
                  })(e))) ||
            t
          );
        },
        iu = function (e, t, n, i) {
          void 0 === n &&
            (n = function (e) {
              return 1 - t(1 - e);
            }),
            void 0 === i &&
              (i = function (e) {
                return e < 0.5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2;
              });
          var r,
            a = { easeIn: t, easeOut: n, easeInOut: i };
          return (
            Ul(e, function (e) {
              for (var t in ((Zh[e] = Sl[e] = a),
              (Zh[(r = e.toLowerCase())] = n),
              a))
                Zh[
                  r +
                    ("easeIn" === t
                      ? ".in"
                      : "easeOut" === t
                      ? ".out"
                      : ".inOut")
                ] = Zh[e + "." + t] = a[t];
            }),
            a
          );
        },
        ru = function (e) {
          return function (t) {
            return t < 0.5
              ? (1 - e(1 - 2 * t)) / 2
              : 0.5 + e(2 * (t - 0.5)) / 2;
          };
        },
        au = function e(t, n, i) {
          var r = n >= 1 ? n : 1,
            a = (i || (t ? 0.3 : 0.45)) / (n < 1 ? n : 1),
            o = (a / tl) * (Math.asin(1 / r) || 0),
            s = function (e) {
              return 1 === e
                ? 1
                : r * Math.pow(2, -10 * e) * ol((e - o) * a) + 1;
            },
            c =
              "out" === t
                ? s
                : "in" === t
                ? function (e) {
                    return 1 - s(1 - e);
                  }
                : ru(s);
          return (
            (a = tl / a),
            (c.config = function (n, i) {
              return e(t, n, i);
            }),
            c
          );
        },
        ou = function e(t, n) {
          void 0 === n && (n = 1.70158);
          var i = function (e) {
              return e ? --e * e * ((n + 1) * e + n) + 1 : 0;
            },
            r =
              "out" === t
                ? i
                : "in" === t
                ? function (e) {
                    return 1 - i(1 - e);
                  }
                : ru(i);
          return (
            (r.config = function (n) {
              return e(t, n);
            }),
            r
          );
        };
      Ul("Linear,Quad,Cubic,Quart,Quint,Strong", function (e, t) {
        var n = t < 5 ? t + 1 : t;
        iu(
          e + ",Power" + (n - 1),
          t
            ? function (e) {
                return Math.pow(e, n);
              }
            : function (e) {
                return e;
              },
          function (e) {
            return 1 - Math.pow(1 - e, n);
          },
          function (e) {
            return e < 0.5
              ? Math.pow(2 * e, n) / 2
              : 1 - Math.pow(2 * (1 - e), n) / 2;
          }
        );
      }),
        (Zh.Linear.easeNone = Zh.none = Zh.Linear.easeIn),
        iu("Elastic", au("in"), au("out"), au()),
        (Xc = 7.5625),
        (Jc = 1 / (Yc = 2.75)),
        iu(
          "Bounce",
          function (e) {
            return 1 - Zc(1 - e);
          },
          (Zc = function (e) {
            return e < Jc
              ? Xc * e * e
              : e < 0.7272727272727273
              ? Xc * Math.pow(e - 1.5 / Yc, 2) + 0.75
              : e < 0.9090909090909092
              ? Xc * (e -= 2.25 / Yc) * e + 0.9375
              : Xc * Math.pow(e - 2.625 / Yc, 2) + 0.984375;
          })
        ),
        iu("Expo", function (e) {
          return e ? Math.pow(2, 10 * (e - 1)) : 0;
        }),
        iu("Circ", function (e) {
          return -(rl(1 - e * e) - 1);
        }),
        iu("Sine", function (e) {
          return 1 === e ? 1 : 1 - al(e * nl);
        }),
        iu("Back", ou("in"), ou("out"), ou()),
        (Zh.SteppedEase =
          Zh.steps =
          Sl.SteppedEase =
            {
              config: function (e, t) {
                void 0 === e && (e = 1);
                var n = 1 / e,
                  i = e + (t ? 0 : 1),
                  r = t ? 1 : 0;
                return function (e) {
                  return (((i * bh(0, 0.99999999, e)) | 0) + r) * n;
                };
              },
            }),
        (Kc.ease = Zh["quad.out"]),
        Ul(
          "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
          function (e) {
            return (Fl += e + "," + e + "Params,");
          }
        );
      var su = function (e, t) {
          (this.id = il++),
            (e._gsap = this),
            (this.target = e),
            (this.harness = t),
            (this.get = t ? t.get : zl),
            (this.set = t ? t.getSetter : Mu);
        },
        cu = (function () {
          function e(e, t) {
            var n = e.parent || Hc;
            (this.vars = e),
              (this._delay = +e.delay || 0),
              (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) &&
                ((this._rDelay = e.repeatDelay || 0),
                (this._yoyo = !!e.yoyo || !!e.yoyoEase)),
              (this._ts = 1),
              vh(this, +e.duration, 1, 1),
              (this.data = e.data),
              qc || Yh.wake(),
              n && dh(n, this, t || 0 === t ? t : n._time, 1),
              e.reversed && this.reverse(),
              e.paused && this.paused(!0);
          }
          var t = e.prototype;
          return (
            (t.delay = function (e) {
              return e || 0 === e
                ? (this.parent &&
                    this.parent.smoothChildTiming &&
                    this.startTime(this._start + e - this._delay),
                  (this._delay = e),
                  this)
                : this._delay;
            }),
            (t.duration = function (e) {
              return arguments.length
                ? this.totalDuration(
                    this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e
                  )
                : this.totalDuration() && this._dur;
            }),
            (t.totalDuration = function (e) {
              return arguments.length
                ? ((this._dirty = 0),
                  vh(
                    this,
                    this._repeat < 0
                      ? e
                      : (e - this._repeat * this._rDelay) / (this._repeat + 1)
                  ))
                : this._tDur;
            }),
            (t.totalTime = function (e, t) {
              if ((Jh(), !arguments.length)) return this._tTime;
              var n = this._dp;
              if (n && n.smoothChildTiming && this._ts) {
                for (uh(this, e), !n._dp || n.parent || ph(n, this); n.parent; )
                  n.parent._time !==
                    n._start +
                      (n._ts >= 0
                        ? n._tTime / n._ts
                        : (n.totalDuration() - n._tTime) / -n._ts) &&
                    n.totalTime(n._tTime, !0),
                    (n = n.parent);
                !this.parent &&
                  this._dp.autoRemoveChildren &&
                  ((this._ts > 0 && e < this._tDur) ||
                    (this._ts < 0 && e > 0) ||
                    (!this._tDur && !e)) &&
                  dh(this._dp, this, this._start - this._delay);
              }
              return (
                (this._tTime !== e ||
                  (!this._dur && !t) ||
                  (this._initted && Math.abs(this._zTime) === el) ||
                  (!e && !this._initted && (this.add || this._ptLookup))) &&
                  (this._ts || (this._pTime = e), Xl(this, e, t)),
                this
              );
            }),
            (t.time = function (e, t) {
              return arguments.length
                ? this.totalTime(
                    Math.min(this.totalDuration(), e + sh(this)) % this._dur ||
                      (e ? this._dur : 0),
                    t
                  )
                : this._time;
            }),
            (t.totalProgress = function (e, t) {
              return arguments.length
                ? this.totalTime(this.totalDuration() * e, t)
                : this.totalDuration()
                ? Math.min(1, this._tTime / this._tDur)
                : this.ratio;
            }),
            (t.progress = function (e, t) {
              return arguments.length
                ? this.totalTime(
                    this.duration() *
                      (!this._yoyo || 1 & this.iteration() ? e : 1 - e) +
                      sh(this),
                    t
                  )
                : this.duration()
                ? Math.min(1, this._time / this._dur)
                : this.ratio;
            }),
            (t.iteration = function (e, t) {
              var n = this.duration() + this._rDelay;
              return arguments.length
                ? this.totalTime(this._time + (e - 1) * n, t)
                : this._repeat
                ? ch(this._tTime, n) + 1
                : 1;
            }),
            (t.timeScale = function (e) {
              if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
              if (this._rts === e) return this;
              var t =
                this.parent && this._ts
                  ? lh(this.parent._time, this)
                  : this._tTime;
              return (
                (this._rts = +e || 0),
                (this._ts = this._ps || -1e-8 === e ? 0 : this._rts),
                ah(this.totalTime(bh(-this._delay, this._tDur, t), !0))
              );
            }),
            (t.paused = function (e) {
              return arguments.length
                ? (this._ps !== e &&
                    ((this._ps = e),
                    e
                      ? ((this._pTime =
                          this._tTime ||
                          Math.max(-this._delay, this.rawTime())),
                        (this._ts = this._act = 0))
                      : (Jh(),
                        (this._ts = this._rts),
                        this.totalTime(
                          this.parent && !this.parent.smoothChildTiming
                            ? this.rawTime()
                            : this._tTime || this._pTime,
                          1 === this.progress() &&
                            (this._tTime -= el) &&
                            Math.abs(this._zTime) !== el
                        ))),
                  this)
                : this._ps;
            }),
            (t.startTime = function (e) {
              if (arguments.length) {
                this._start = e;
                var t = this.parent || this._dp;
                return (
                  t &&
                    (t._sort || !this.parent) &&
                    dh(t, this, e - this._delay),
                  this
                );
              }
              return this._start;
            }),
            (t.endTime = function (e) {
              return (
                this._start +
                (pl(e) ? this.totalDuration() : this.duration()) /
                  Math.abs(this._ts)
              );
            }),
            (t.rawTime = function (e) {
              var t = this.parent || this._dp;
              return t
                ? e &&
                  (!this._ts ||
                    (this._repeat && this._time && this.totalProgress() < 1))
                  ? this._tTime % (this._dur + this._rDelay)
                  : this._ts
                  ? lh(t.rawTime(e), this)
                  : this._tTime
                : this._tTime;
            }),
            (t.globalTime = function (e) {
              for (var t = this, n = arguments.length ? e : t.rawTime(); t; )
                (n = t._start + n / (t._ts || 1)), (t = t._dp);
              return n;
            }),
            (t.repeat = function (e) {
              return arguments.length
                ? ((this._repeat = e === 1 / 0 ? -2 : e), yh(this))
                : -2 === this._repeat
                ? 1 / 0
                : this._repeat;
            }),
            (t.repeatDelay = function (e) {
              return arguments.length
                ? ((this._rDelay = e), yh(this))
                : this._rDelay;
            }),
            (t.yoyo = function (e) {
              return arguments.length ? ((this._yoyo = e), this) : this._yoyo;
            }),
            (t.seek = function (e, t) {
              return this.totalTime(wh(this, e), pl(t));
            }),
            (t.restart = function (e, t) {
              return this.play().totalTime(e ? -this._delay : 0, pl(t));
            }),
            (t.play = function (e, t) {
              return null != e && this.seek(e, t), this.reversed(!1).paused(!1);
            }),
            (t.reverse = function (e, t) {
              return (
                null != e && this.seek(e || this.totalDuration(), t),
                this.reversed(!0).paused(!1)
              );
            }),
            (t.pause = function (e, t) {
              return null != e && this.seek(e, t), this.paused(!0);
            }),
            (t.resume = function () {
              return this.paused(!1);
            }),
            (t.reversed = function (e) {
              return arguments.length
                ? (!!e !== this.reversed() &&
                    this.timeScale(-this._rts || (e ? -1e-8 : 0)),
                  this)
                : this._rts < 0;
            }),
            (t.invalidate = function () {
              return (
                (this._initted = this._act = 0), (this._zTime = -1e-8), this
              );
            }),
            (t.isActive = function () {
              var e,
                t = this.parent || this._dp,
                n = this._start;
              return !(
                t &&
                !(
                  this._ts &&
                  this._initted &&
                  t.isActive() &&
                  (e = t.rawTime(!0)) >= n &&
                  e < this.endTime(!0) - el
                )
              );
            }),
            (t.eventCallback = function (e, t, n) {
              var i = this.vars;
              return arguments.length > 1
                ? (t
                    ? ((i[e] = t),
                      n && (i[e + "Params"] = n),
                      "onUpdate" === e && (this._onUpdate = t))
                    : delete i[e],
                  this)
                : i[e];
            }),
            (t.then = function (e) {
              var t = this;
              return new Promise(function (n) {
                var i = cl(e) ? e : Jl,
                  r = function () {
                    var e = t.then;
                    (t.then = null),
                      cl(i) &&
                        (i = i(t)) &&
                        (i.then || i === t) &&
                        (t.then = e),
                      n(i),
                      (t.then = e);
                  };
                (t._initted && 1 === t.totalProgress() && t._ts >= 0) ||
                (!t._tTime && t._ts < 0)
                  ? r()
                  : (t._prom = r);
              });
            }),
            (t.kill = function () {
              jh(this);
            }),
            e
          );
        })();
      Zl(cu.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1,
      });
      var lu = (function (e) {
        function t(t, n) {
          var i;
          return (
            void 0 === t && (t = {}),
            ((i = e.call(this, t, n) || this).labels = {}),
            (i.smoothChildTiming = !!t.smoothChildTiming),
            (i.autoRemoveChildren = !!t.autoRemoveChildren),
            (i._sort = pl(t.sortChildren)),
            i.parent && ph(i.parent, Dc(i)),
            t.scrollTrigger && fh(Dc(i), t.scrollTrigger),
            i
          );
        }
        jc(t, e);
        var n = t.prototype;
        return (
          (n.to = function (e, t, n) {
            return (
              new yu(
                e,
                Vl(arguments, 0, this),
                wh(this, ll(t) ? arguments[3] : n)
              ),
              this
            );
          }),
          (n.from = function (e, t, n) {
            return (
              new yu(
                e,
                Vl(arguments, 1, this),
                wh(this, ll(t) ? arguments[3] : n)
              ),
              this
            );
          }),
          (n.fromTo = function (e, t, n, i) {
            return (
              new yu(
                e,
                Vl(arguments, 2, this),
                wh(this, ll(t) ? arguments[4] : i)
              ),
              this
            );
          }),
          (n.set = function (e, t, n) {
            return (
              (t.duration = 0),
              (t.parent = this),
              th(t).repeatDelay || (t.repeat = 0),
              (t.immediateRender = !!t.immediateRender),
              new yu(e, t, wh(this, n), 1),
              this
            );
          }),
          (n.call = function (e, t, n) {
            return dh(this, yu.delayedCall(0, e, t), wh(this, n));
          }),
          (n.staggerTo = function (e, t, n, i, r, a, o) {
            return (
              (n.duration = t),
              (n.stagger = n.stagger || i),
              (n.onComplete = a),
              (n.onCompleteParams = o),
              (n.parent = this),
              new yu(e, n, wh(this, r)),
              this
            );
          }),
          (n.staggerFrom = function (e, t, n, i, r, a, o) {
            return (
              (n.runBackwards = 1),
              (th(n).immediateRender = pl(n.immediateRender)),
              this.staggerTo(e, t, n, i, r, a, o)
            );
          }),
          (n.staggerFromTo = function (e, t, n, i, r, a, o, s) {
            return (
              (i.startAt = n),
              (th(i).immediateRender = pl(i.immediateRender)),
              this.staggerTo(e, t, i, r, a, o, s)
            );
          }),
          (n.render = function (e, t, n) {
            var i,
              r,
              a,
              o,
              s,
              c,
              l,
              h,
              u,
              p,
              d,
              f,
              m = this._time,
              g = this._dirty ? this.totalDuration() : this._tDur,
              v = this._dur,
              y = this !== Hc && e > g - el && e >= 0 ? g : e < el ? 0 : e,
              _ = this._zTime < 0 != e < 0 && (this._initted || !v);
            if (y !== this._tTime || n || _) {
              if (
                (m !== this._time &&
                  v &&
                  ((y += this._time - m), (e += this._time - m)),
                (i = y),
                (u = this._start),
                (c = !(h = this._ts)),
                _ && (v || (m = this._zTime), (e || !t) && (this._zTime = e)),
                this._repeat)
              ) {
                if (
                  ((d = this._yoyo),
                  (s = v + this._rDelay),
                  this._repeat < -1 && e < 0)
                )
                  return this.totalTime(100 * s + e, t, n);
                if (
                  ((i = Gl(y % s)),
                  y === g
                    ? ((o = this._repeat), (i = v))
                    : ((o = ~~(y / s)) && o === y / s && ((i = v), o--),
                      i > v && (i = v)),
                  (p = ch(this._tTime, s)),
                  !m && this._tTime && p !== o && (p = o),
                  d && 1 & o && ((i = v - i), (f = 1)),
                  o !== p && !this._lock)
                ) {
                  var w = d && 1 & p,
                    x = w === (d && 1 & o);
                  if (
                    (o < p && (w = !w),
                    (m = w ? 0 : v),
                    (this._lock = 1),
                    (this.render(m || (f ? 0 : Gl(o * s)), t, !v)._lock = 0),
                    !t && this.parent && Dh(this, "onRepeat"),
                    this.vars.repeatRefresh &&
                      !f &&
                      (this.invalidate()._lock = 1),
                    m !== this._time || c !== !this._ts)
                  )
                    return this;
                  if (
                    ((v = this._dur),
                    (g = this._tDur),
                    x &&
                      ((this._lock = 2),
                      (m = w ? v : -1e-4),
                      this.render(m, !0),
                      this.vars.repeatRefresh && !f && this.invalidate()),
                    (this._lock = 0),
                    !this._ts && !c)
                  )
                    return this;
                  tu(this, f);
                }
              }
              if (
                (this._hasPause &&
                  !this._forcing &&
                  this._lock < 2 &&
                  (l = (function (e, t, n) {
                    var i;
                    if (n > t)
                      for (i = e._first; i && i._start <= n; ) {
                        if (!i._dur && "isPause" === i.data && i._start > t)
                          return i;
                        i = i._next;
                      }
                    else
                      for (i = e._last; i && i._start >= n; ) {
                        if (!i._dur && "isPause" === i.data && i._start < t)
                          return i;
                        i = i._prev;
                      }
                  })(this, Gl(m), Gl(i))) &&
                  (y -= i - (i = l._start)),
                (this._tTime = y),
                (this._time = i),
                (this._act = !h),
                this._initted ||
                  ((this._onUpdate = this.vars.onUpdate),
                  (this._initted = 1),
                  (this._zTime = e),
                  (m = 0)),
                !m && (i || (!v && e >= 0)) && !t && Dh(this, "onStart"),
                i >= m && e >= 0)
              )
                for (r = this._first; r; ) {
                  if (
                    ((a = r._next),
                    (r._act || i >= r._start) && r._ts && l !== r)
                  ) {
                    if (r.parent !== this) return this.render(e, t, n);
                    if (
                      (r.render(
                        r._ts > 0
                          ? (i - r._start) * r._ts
                          : (r._dirty ? r.totalDuration() : r._tDur) +
                              (i - r._start) * r._ts,
                        t,
                        n
                      ),
                      i !== this._time || (!this._ts && !c))
                    ) {
                      (l = 0), a && (y += this._zTime = -1e-8);
                      break;
                    }
                  }
                  r = a;
                }
              else {
                r = this._last;
                for (var b = e < 0 ? e : i; r; ) {
                  if (
                    ((a = r._prev), (r._act || b <= r._end) && r._ts && l !== r)
                  ) {
                    if (r.parent !== this) return this.render(e, t, n);
                    if (
                      (r.render(
                        r._ts > 0
                          ? (b - r._start) * r._ts
                          : (r._dirty ? r.totalDuration() : r._tDur) +
                              (b - r._start) * r._ts,
                        t,
                        n
                      ),
                      i !== this._time || (!this._ts && !c))
                    ) {
                      (l = 0), a && (y += this._zTime = b ? -1e-8 : el);
                      break;
                    }
                  }
                  r = a;
                }
              }
              if (
                l &&
                !t &&
                (this.pause(),
                (l.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1),
                this._ts)
              )
                return (this._start = u), hh(this), this.render(e, t, n);
              this._onUpdate && !t && Dh(this, "onUpdate", !0),
                ((y === g && g >= this.totalDuration()) || (!y && m)) &&
                  ((u !== this._start && Math.abs(h) === Math.abs(this._ts)) ||
                    this._lock ||
                    ((e || !v) &&
                      ((y === g && this._ts > 0) || (!y && this._ts < 0)) &&
                      ih(this, 1),
                    t ||
                      (e < 0 && !m) ||
                      (!y && !m) ||
                      (Dh(
                        this,
                        y === g ? "onComplete" : "onReverseComplete",
                        !0
                      ),
                      this._prom &&
                        !(y < g && this.timeScale() > 0) &&
                        this._prom())));
            }
            return this;
          }),
          (n.add = function (e, t) {
            var n = this;
            if ((ll(t) || (t = wh(this, t)), !(e instanceof cu))) {
              if (gl(e))
                return (
                  e.forEach(function (e) {
                    return n.add(e, t);
                  }),
                  this
                );
              if (sl(e)) return this.addLabel(e, t);
              if (!cl(e)) return this;
              e = yu.delayedCall(0, e);
            }
            return this !== e ? dh(this, e, t) : this;
          }),
          (n.getChildren = function (e, t, n, i) {
            void 0 === e && (e = !0),
              void 0 === t && (t = !0),
              void 0 === n && (n = !0),
              void 0 === i && (i = -$c);
            for (var r = [], a = this._first; a; )
              a._start >= i &&
                (a instanceof yu
                  ? t && r.push(a)
                  : (n && r.push(a),
                    e && r.push.apply(r, a.getChildren(!0, t, n)))),
                (a = a._next);
            return r;
          }),
          (n.getById = function (e) {
            for (var t = this.getChildren(1, 1, 1), n = t.length; n--; )
              if (t[n].vars.id === e) return t[n];
          }),
          (n.remove = function (e) {
            return sl(e)
              ? this.removeLabel(e)
              : cl(e)
              ? this.killTweensOf(e)
              : (nh(this, e),
                e === this._recent && (this._recent = this._last),
                rh(this));
          }),
          (n.totalTime = function (t, n) {
            return arguments.length
              ? ((this._forcing = 1),
                !this._dp &&
                  this._ts &&
                  (this._start = Gl(
                    Yh.time -
                      (this._ts > 0
                        ? t / this._ts
                        : (this.totalDuration() - t) / -this._ts)
                  )),
                e.prototype.totalTime.call(this, t, n),
                (this._forcing = 0),
                this)
              : this._tTime;
          }),
          (n.addLabel = function (e, t) {
            return (this.labels[e] = wh(this, t)), this;
          }),
          (n.removeLabel = function (e) {
            return delete this.labels[e], this;
          }),
          (n.addPause = function (e, t, n) {
            var i = yu.delayedCall(0, t || Rl, n);
            return (
              (i.data = "isPause"),
              (this._hasPause = 1),
              dh(this, i, wh(this, e))
            );
          }),
          (n.removePause = function (e) {
            var t = this._first;
            for (e = wh(this, e); t; )
              t._start === e && "isPause" === t.data && ih(t), (t = t._next);
          }),
          (n.killTweensOf = function (e, t, n) {
            for (var i = this.getTweensOf(e, n), r = i.length; r--; )
              hu !== i[r] && i[r].kill(e, t);
            return this;
          }),
          (n.getTweensOf = function (e, t) {
            for (var n, i = [], r = Eh(e), a = this._first, o = ll(t); a; )
              a instanceof yu
                ? Wl(a._targets, r) &&
                  (o
                    ? (!hu || (a._initted && a._ts)) &&
                      a.globalTime(0) <= t &&
                      a.globalTime(a.totalDuration()) > t
                    : !t || a.isActive()) &&
                  i.push(a)
                : (n = a.getTweensOf(r, t)).length && i.push.apply(i, n),
                (a = a._next);
            return i;
          }),
          (n.tweenTo = function (e, t) {
            t = t || {};
            var n = this,
              i = wh(n, e),
              r = t,
              a = r.startAt,
              o = r.onStart,
              s = r.onStartParams,
              c = r.immediateRender,
              l = yu.to(
                n,
                Zl(
                  {
                    ease: "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: i,
                    overwrite: "auto",
                    duration:
                      t.duration ||
                      Math.abs(
                        (i - (a && "time" in a ? a.time : n._time)) /
                          n.timeScale()
                      ) ||
                      el,
                    onStart: function () {
                      n.pause();
                      var e =
                        t.duration || Math.abs((i - n._time) / n.timeScale());
                      l._dur !== e && vh(l, e, 0, 1).render(l._time, !0, !0),
                        o && o.apply(l, s || []);
                    },
                  },
                  t
                )
              );
            return c ? l.render(0) : l;
          }),
          (n.tweenFromTo = function (e, t, n) {
            return this.tweenTo(t, Zl({ startAt: { time: wh(this, e) } }, n));
          }),
          (n.recent = function () {
            return this._recent;
          }),
          (n.nextLabel = function (e) {
            return void 0 === e && (e = this._time), Ih(this, wh(this, e));
          }),
          (n.previousLabel = function (e) {
            return void 0 === e && (e = this._time), Ih(this, wh(this, e), 1);
          }),
          (n.currentLabel = function (e) {
            return arguments.length
              ? this.seek(e, !0)
              : this.previousLabel(this._time + el);
          }),
          (n.shiftChildren = function (e, t, n) {
            void 0 === n && (n = 0);
            for (var i, r = this._first, a = this.labels; r; )
              r._start >= n && ((r._start += e), (r._end += e)), (r = r._next);
            if (t) for (i in a) a[i] >= n && (a[i] += e);
            return rh(this);
          }),
          (n.invalidate = function () {
            var t = this._first;
            for (this._lock = 0; t; ) t.invalidate(), (t = t._next);
            return e.prototype.invalidate.call(this);
          }),
          (n.clear = function (e) {
            void 0 === e && (e = !0);
            for (var t, n = this._first; n; )
              (t = n._next), this.remove(n), (n = t);
            return (
              this._dp && (this._time = this._tTime = this._pTime = 0),
              e && (this.labels = {}),
              rh(this)
            );
          }),
          (n.totalDuration = function (e) {
            var t,
              n,
              i,
              r = 0,
              a = this,
              o = a._last,
              s = $c;
            if (arguments.length)
              return a.timeScale(
                (a._repeat < 0 ? a.duration() : a.totalDuration()) /
                  (a.reversed() ? -e : e)
              );
            if (a._dirty) {
              for (i = a.parent; o; )
                (t = o._prev),
                  o._dirty && o.totalDuration(),
                  (n = o._start) > s && a._sort && o._ts && !a._lock
                    ? ((a._lock = 1), (dh(a, o, n - o._delay, 1)._lock = 0))
                    : (s = n),
                  n < 0 &&
                    o._ts &&
                    ((r -= n),
                    ((!i && !a._dp) || (i && i.smoothChildTiming)) &&
                      ((a._start += n / a._ts),
                      (a._time -= n),
                      (a._tTime -= n)),
                    a.shiftChildren(-n, !1, -Infinity),
                    (s = 0)),
                  o._end > r && o._ts && (r = o._end),
                  (o = t);
              vh(a, a === Hc && a._time > r ? a._time : r, 1, 1),
                (a._dirty = 0);
            }
            return a._tDur;
          }),
          (t.updateRoot = function (e) {
            if (
              (Hc._ts && (Xl(Hc, lh(e, Hc)), (Wc = Yh.frame)), Yh.frame >= Dl)
            ) {
              Dl += Qc.autoSleep || 120;
              var t = Hc._first;
              if ((!t || !t._ts) && Qc.autoSleep && Yh._listeners.length < 2) {
                for (; t && !t._ts; ) t = t._next;
                t || Yh.sleep();
              }
            }
          }),
          t
        );
      })(cu);
      Zl(lu.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
      var hu,
        uu = function (e, t, n, i, r, a, o) {
          var s,
            c,
            l,
            h,
            u,
            p,
            d,
            f,
            m = new Cu(this._pt, e, t, 0, 1, Eu, null, r),
            g = 0,
            v = 0;
          for (
            m.b = n,
              m.e = i,
              n += "",
              (d = ~(i += "").indexOf("random(")) && (i = Oh(i)),
              a && (a((f = [n, i]), e, t), (n = f[0]), (i = f[1])),
              c = n.match(wl) || [];
            (s = wl.exec(i));

          )
            (h = s[0]),
              (u = i.substring(g, s.index)),
              l ? (l = (l + 1) % 5) : "rgba(" === u.substr(-5) && (l = 1),
              h !== c[v++] &&
                ((p = parseFloat(c[v - 1]) || 0),
                (m._pt = {
                  _next: m._pt,
                  p: u || 1 === v ? u : ",",
                  s: p,
                  c:
                    "=" === h.charAt(1)
                      ? parseFloat(h.substr(2)) * ("-" === h.charAt(0) ? -1 : 1)
                      : parseFloat(h) - p,
                  m: l && l < 4 ? Math.round : 0,
                }),
                (g = wl.lastIndex));
          return (
            (m.c = g < i.length ? i.substring(g, i.length) : ""),
            (m.fp = o),
            (xl.test(i) || d) && (m.e = 0),
            (this._pt = m),
            m
          );
        },
        pu = function (e, t, n, i, r, a, o, s, c) {
          cl(i) && (i = i(r || 0, e, a));
          var l,
            h = e[t],
            u =
              "get" !== n
                ? n
                : cl(h)
                ? c
                  ? e[
                      t.indexOf("set") || !cl(e["get" + t.substr(3)])
                        ? t
                        : "get" + t.substr(3)
                    ](c)
                  : e[t]()
                : h,
            p = cl(h) ? (c ? xu : wu) : _u;
          if (
            (sl(i) &&
              (~i.indexOf("random(") && (i = Oh(i)),
              "=" === i.charAt(1) &&
                (i =
                  parseFloat(u) +
                  parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) +
                  (Mh(u) || 0))),
            u !== i)
          )
            return isNaN(u * i)
              ? (!h && !(t in e) && Al(t, i),
                uu.call(this, e, t, u, i, p, s || Qc.stringFilter, c))
              : ((l = new Cu(
                  this._pt,
                  e,
                  t,
                  +u || 0,
                  i - (u || 0),
                  "boolean" == typeof h ? Tu : Su,
                  0,
                  p
                )),
                c && (l.fp = c),
                o && l.modifier(o, this, e),
                (this._pt = l));
        },
        du = function (e, t, n, i, r, a) {
          var o, s, c, l;
          if (
            Nl[e] &&
            !1 !==
              (o = new Nl[e]()).init(
                r,
                o.rawVars
                  ? t[e]
                  : (function (e, t, n, i, r) {
                      if (
                        (cl(e) && (e = mu(e, r, t, n, i)),
                        !ul(e) || (e.style && e.nodeType) || gl(e) || ml(e))
                      )
                        return sl(e) ? mu(e, r, t, n, i) : e;
                      var a,
                        o = {};
                      for (a in e) o[a] = mu(e[a], r, t, n, i);
                      return o;
                    })(t[e], i, r, a, n),
                n,
                i,
                a
              ) &&
            ((n._pt = s =
              new Cu(n._pt, r, e, 0, 1, o.render, o, 0, o.priority)),
            n !== Vc)
          )
            for (
              c = n._ptLookup[n._targets.indexOf(r)], l = o._props.length;
              l--;

            )
              c[o._props[l]] = s;
          return o;
        },
        fu = function e(t, n) {
          var i,
            r,
            a,
            o,
            s,
            c,
            l,
            h,
            u,
            p,
            d,
            f,
            m,
            g = t.vars,
            v = g.ease,
            y = g.startAt,
            _ = g.immediateRender,
            w = g.lazy,
            x = g.onUpdate,
            b = g.onUpdateParams,
            M = g.callbackScope,
            S = g.runBackwards,
            T = g.yoyoEase,
            E = g.keyframes,
            A = g.autoRevert,
            L = t._dur,
            P = t._startAt,
            R = t._targets,
            k = t.parent,
            C = k && "nested" === k.data ? k.parent._targets : R,
            O = "auto" === t._overwrite && !Fc,
            N = t.timeline;
          if (
            (N && (!E || !v) && (v = "none"),
            (t._ease = nu(v, Kc.ease)),
            (t._yEase = T ? eu(nu(!0 === T ? v : T, Kc.ease)) : 0),
            T &&
              t._yoyo &&
              !t._repeat &&
              ((T = t._yEase), (t._yEase = t._ease), (t._ease = T)),
            !N)
          ) {
            if (
              ((f = (h = R[0] ? Bl(R[0]).harness : 0) && g[h.prop]),
              (i = eh(g, kl)),
              P && P.render(-1, !0).kill(),
              y)
            ) {
              if (
                (ih(
                  (t._startAt = yu.set(
                    R,
                    Zl(
                      {
                        data: "isStart",
                        overwrite: !1,
                        parent: k,
                        immediateRender: !0,
                        lazy: pl(w),
                        startAt: null,
                        delay: 0,
                        onUpdate: x,
                        onUpdateParams: b,
                        callbackScope: M,
                        stagger: 0,
                      },
                      y
                    )
                  ))
                ),
                _)
              )
                if (n > 0) A || (t._startAt = 0);
                else if (L && !(n < 0 && P)) return void (n && (t._zTime = n));
            } else if (S && L)
              if (P) !A && (t._startAt = 0);
              else if (
                (n && (_ = !1),
                (a = Zl(
                  {
                    overwrite: !1,
                    data: "isFromStart",
                    lazy: _ && pl(w),
                    immediateRender: _,
                    stagger: 0,
                    parent: k,
                  },
                  i
                )),
                f && (a[h.prop] = f),
                ih((t._startAt = yu.set(R, a))),
                _)
              ) {
                if (!n) return;
              } else e(t._startAt, el);
            for (
              t._pt = 0, w = (L && pl(w)) || (w && !L), r = 0;
              r < R.length;
              r++
            ) {
              if (
                ((l = (s = R[r])._gsap || Hl(R)[r]._gsap),
                (t._ptLookup[r] = p = {}),
                Ol[l.id] && Cl.length && ql(),
                (d = C === R ? r : C.indexOf(s)),
                h &&
                  !1 !== (u = new h()).init(s, f || i, t, d, C) &&
                  ((t._pt = o =
                    new Cu(t._pt, s, u.name, 0, 1, u.render, u, 0, u.priority)),
                  u._props.forEach(function (e) {
                    p[e] = o;
                  }),
                  u.priority && (c = 1)),
                !h || f)
              )
                for (a in i)
                  Nl[a] && (u = du(a, i, t, d, s, C))
                    ? u.priority && (c = 1)
                    : (p[a] = o =
                        pu.call(t, s, a, "get", i[a], d, C, 0, g.stringFilter));
              t._op && t._op[r] && t.kill(s, t._op[r]),
                O &&
                  t._pt &&
                  ((hu = t),
                  Hc.killTweensOf(s, p, t.globalTime(0)),
                  (m = !t.parent),
                  (hu = 0)),
                t._pt && w && (Ol[l.id] = 1);
            }
            c && ku(t), t._onInit && t._onInit(t);
          }
          (t._from = !N && !!g.runBackwards),
            (t._onUpdate = x),
            (t._initted = (!t._op || t._pt) && !m);
        },
        mu = function (e, t, n, i, r) {
          return cl(e)
            ? e.call(t, n, i, r)
            : sl(e) && ~e.indexOf("random(")
            ? Oh(e)
            : e;
        },
        gu = Fl + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
        vu = (gu + ",id,stagger,delay,duration,paused,scrollTrigger").split(
          ","
        ),
        yu = (function (e) {
          function t(t, n, i, r) {
            var a;
            "number" == typeof n && ((i.duration = n), (n = i), (i = null));
            var o,
              s,
              c,
              l,
              h,
              u,
              p,
              d,
              f = (a = e.call(this, r ? n : th(n), i) || this).vars,
              m = f.duration,
              g = f.delay,
              v = f.immediateRender,
              y = f.stagger,
              _ = f.overwrite,
              w = f.keyframes,
              x = f.defaults,
              b = f.scrollTrigger,
              M = f.yoyoEase,
              S = a.parent,
              T = (gl(t) || ml(t) ? ll(t[0]) : "length" in n) ? [t] : Eh(t);
            if (
              ((a._targets = T.length
                ? Hl(T)
                : Ll(
                    "GSAP target " + t + " not found. https://greensock.com",
                    !Qc.nullTargetWarn
                  ) || []),
              (a._ptLookup = []),
              (a._overwrite = _),
              w || y || fl(m) || fl(g))
            ) {
              if (
                ((n = a.vars),
                (o = a.timeline =
                  new lu({ data: "nested", defaults: x || {} })).kill(),
                (o.parent = o._dp = Dc(a)),
                (o._start = 0),
                w)
              )
                Zl(o.vars.defaults, { ease: "none" }),
                  w.forEach(function (e) {
                    return o.to(T, e, ">");
                  });
              else {
                if (((l = T.length), (p = y ? Lh(y) : Rl), ul(y)))
                  for (h in y) ~gu.indexOf(h) && (d || (d = {}), (d[h] = y[h]));
                for (s = 0; s < l; s++) {
                  for (h in ((c = {}), n)) vu.indexOf(h) < 0 && (c[h] = n[h]);
                  (c.stagger = 0),
                    M && (c.yoyoEase = M),
                    d && Kl(c, d),
                    (u = T[s]),
                    (c.duration = +mu(m, Dc(a), s, u, T)),
                    (c.delay = (+mu(g, Dc(a), s, u, T) || 0) - a._delay),
                    !y &&
                      1 === l &&
                      c.delay &&
                      ((a._delay = g = c.delay),
                      (a._start += g),
                      (c.delay = 0)),
                    o.to(u, c, p(s, u, T));
                }
                o.duration() ? (m = g = 0) : (a.timeline = 0);
              }
              m || a.duration((m = o.duration()));
            } else a.timeline = 0;
            return (
              !0 !== _ || Fc || ((hu = Dc(a)), Hc.killTweensOf(T), (hu = 0)),
              S && ph(S, Dc(a)),
              (v ||
                (!m &&
                  !w &&
                  a._start === Gl(S._time) &&
                  pl(v) &&
                  oh(Dc(a)) &&
                  "nested" !== S.data)) &&
                ((a._tTime = -1e-8), a.render(Math.max(0, -g))),
              b && fh(Dc(a), b),
              a
            );
          }
          jc(t, e);
          var n = t.prototype;
          return (
            (n.render = function (e, t, n) {
              var i,
                r,
                a,
                o,
                s,
                c,
                l,
                h,
                u,
                p = this._time,
                d = this._tDur,
                f = this._dur,
                m = e > d - el && e >= 0 ? d : e < el ? 0 : e;
              if (f) {
                if (
                  m !== this._tTime ||
                  !e ||
                  n ||
                  (!this._initted && this._tTime) ||
                  (this._startAt && this._zTime < 0 != e < 0)
                ) {
                  if (((i = m), (h = this.timeline), this._repeat)) {
                    if (((o = f + this._rDelay), this._repeat < -1 && e < 0))
                      return this.totalTime(100 * o + e, t, n);
                    if (
                      ((i = Gl(m % o)),
                      m === d
                        ? ((a = this._repeat), (i = f))
                        : ((a = ~~(m / o)) && a === m / o && ((i = f), a--),
                          i > f && (i = f)),
                      (c = this._yoyo && 1 & a) &&
                        ((u = this._yEase), (i = f - i)),
                      (s = ch(this._tTime, o)),
                      i === p && !n && this._initted)
                    )
                      return this;
                    a !== s &&
                      (h && this._yEase && tu(h, c),
                      !this.vars.repeatRefresh ||
                        c ||
                        this._lock ||
                        ((this._lock = n = 1),
                        (this.render(Gl(o * a), !0).invalidate()._lock = 0)));
                  }
                  if (!this._initted) {
                    if (mh(this, e < 0 ? e : i, n, t))
                      return (this._tTime = 0), this;
                    if (f !== this._dur) return this.render(e, t, n);
                  }
                  for (
                    this._tTime = m,
                      this._time = i,
                      !this._act &&
                        this._ts &&
                        ((this._act = 1), (this._lazy = 0)),
                      this.ratio = l = (u || this._ease)(i / f),
                      this._from && (this.ratio = l = 1 - l),
                      i && !p && !t && Dh(this, "onStart"),
                      r = this._pt;
                    r;

                  )
                    r.r(l, r.d), (r = r._next);
                  (h &&
                    h.render(e < 0 ? e : !i && c ? -1e-8 : h._dur * l, t, n)) ||
                    (this._startAt && (this._zTime = e)),
                    this._onUpdate &&
                      !t &&
                      (e < 0 && this._startAt && this._startAt.render(e, !0, n),
                      Dh(this, "onUpdate")),
                    this._repeat &&
                      a !== s &&
                      this.vars.onRepeat &&
                      !t &&
                      this.parent &&
                      Dh(this, "onRepeat"),
                    (m !== this._tDur && m) ||
                      this._tTime !== m ||
                      (e < 0 &&
                        this._startAt &&
                        !this._onUpdate &&
                        this._startAt.render(e, !0, !0),
                      (e || !f) &&
                        ((m === this._tDur && this._ts > 0) ||
                          (!m && this._ts < 0)) &&
                        ih(this, 1),
                      t ||
                        (e < 0 && !p) ||
                        (!m && !p) ||
                        (Dh(
                          this,
                          m === d ? "onComplete" : "onReverseComplete",
                          !0
                        ),
                        this._prom &&
                          !(m < d && this.timeScale() > 0) &&
                          this._prom()));
                }
              } else
                !(function (e, t, n, i) {
                  var r,
                    a,
                    o,
                    s = e.ratio,
                    c =
                      t < 0 ||
                      (!t &&
                        ((!e._start && gh(e)) ||
                          ((e._ts < 0 || e._dp._ts < 0) &&
                            "isFromStart" !== e.data &&
                            "isStart" !== e.data)))
                        ? 0
                        : 1,
                    l = e._rDelay,
                    h = 0;
                  if (
                    (l &&
                      e._repeat &&
                      ((h = bh(0, e._tDur, t)),
                      (a = ch(h, l)),
                      (o = ch(e._tTime, l)),
                      e._yoyo && 1 & a && (c = 1 - c),
                      a !== o &&
                        ((s = 1 - c),
                        e.vars.repeatRefresh && e._initted && e.invalidate())),
                    c !== s || i || e._zTime === el || (!t && e._zTime))
                  ) {
                    if (!e._initted && mh(e, t, i, n)) return;
                    for (
                      o = e._zTime,
                        e._zTime = t || (n ? el : 0),
                        n || (n = t && !o),
                        e.ratio = c,
                        e._from && (c = 1 - c),
                        e._time = 0,
                        e._tTime = h,
                        n || Dh(e, "onStart"),
                        r = e._pt;
                      r;

                    )
                      r.r(c, r.d), (r = r._next);
                    e._startAt && t < 0 && e._startAt.render(t, !0, !0),
                      e._onUpdate && !n && Dh(e, "onUpdate"),
                      h && e._repeat && !n && e.parent && Dh(e, "onRepeat"),
                      (t >= e._tDur || t < 0) &&
                        e.ratio === c &&
                        (c && ih(e, 1),
                        n ||
                          (Dh(e, c ? "onComplete" : "onReverseComplete", !0),
                          e._prom && e._prom()));
                  } else e._zTime || (e._zTime = t);
                })(this, e, t, n);
              return this;
            }),
            (n.targets = function () {
              return this._targets;
            }),
            (n.invalidate = function () {
              return (
                (this._pt =
                  this._op =
                  this._startAt =
                  this._onUpdate =
                  this._lazy =
                  this.ratio =
                    0),
                (this._ptLookup = []),
                this.timeline && this.timeline.invalidate(),
                e.prototype.invalidate.call(this)
              );
            }),
            (n.kill = function (e, t) {
              if ((void 0 === t && (t = "all"), !(e || (t && "all" !== t))))
                return (
                  (this._lazy = this._pt = 0), this.parent ? jh(this) : this
                );
              if (this.timeline) {
                var n = this.timeline.totalDuration();
                return (
                  this.timeline.killTweensOf(
                    e,
                    t,
                    hu && !0 !== hu.vars.overwrite
                  )._first || jh(this),
                  this.parent &&
                    n !== this.timeline.totalDuration() &&
                    vh(this, (this._dur * this.timeline._tDur) / n, 0, 1),
                  this
                );
              }
              var i,
                r,
                a,
                o,
                s,
                c,
                l,
                h = this._targets,
                u = e ? Eh(e) : h,
                p = this._ptLookup,
                d = this._pt;
              if (
                (!t || "all" === t) &&
                (function (e, t) {
                  for (
                    var n = e.length, i = n === t.length;
                    i && n-- && e[n] === t[n];

                  );
                  return n < 0;
                })(h, u)
              )
                return "all" === t && (this._pt = 0), jh(this);
              for (
                i = this._op = this._op || [],
                  "all" !== t &&
                    (sl(t) &&
                      ((s = {}),
                      Ul(t, function (e) {
                        return (s[e] = 1);
                      }),
                      (t = s)),
                    (t = (function (e, t) {
                      var n,
                        i,
                        r,
                        a,
                        o = e[0] ? Bl(e[0]).harness : 0,
                        s = o && o.aliases;
                      if (!s) return t;
                      for (i in ((n = Kl({}, t)), s))
                        if ((i in n))
                          for (r = (a = s[i].split(",")).length; r--; )
                            n[a[r]] = n[i];
                      return n;
                    })(h, t))),
                  l = h.length;
                l--;

              )
                if (~u.indexOf(h[l]))
                  for (s in ((r = p[l]),
                  "all" === t
                    ? ((i[l] = t), (o = r), (a = {}))
                    : ((a = i[l] = i[l] || {}), (o = t)),
                  o))
                    (c = r && r[s]) &&
                      (("kill" in c.d && !0 !== c.d.kill(s)) ||
                        nh(this, c, "_pt"),
                      delete r[s]),
                      "all" !== a && (a[s] = 1);
              return this._initted && !this._pt && d && jh(this), this;
            }),
            (t.to = function (e, n) {
              return new t(e, n, arguments[2]);
            }),
            (t.from = function (e, n) {
              return new t(e, Vl(arguments, 1));
            }),
            (t.delayedCall = function (e, n, i, r) {
              return new t(n, 0, {
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: e,
                onComplete: n,
                onReverseComplete: n,
                onCompleteParams: i,
                onReverseCompleteParams: i,
                callbackScope: r,
              });
            }),
            (t.fromTo = function (e, n, i) {
              return new t(e, Vl(arguments, 2));
            }),
            (t.set = function (e, n) {
              return (
                (n.duration = 0), n.repeatDelay || (n.repeat = 0), new t(e, n)
              );
            }),
            (t.killTweensOf = function (e, t, n) {
              return Hc.killTweensOf(e, t, n);
            }),
            t
          );
        })(cu);
      Zl(yu.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0,
      }),
        Ul("staggerTo,staggerFrom,staggerFromTo", function (e) {
          yu[e] = function () {
            var t = new lu(),
              n = Sh.call(arguments, 0);
            return (
              n.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, n)
            );
          };
        });
      var _u = function (e, t, n) {
          return (e[t] = n);
        },
        wu = function (e, t, n) {
          return e[t](n);
        },
        xu = function (e, t, n, i) {
          return e[t](i.fp, n);
        },
        bu = function (e, t, n) {
          return e.setAttribute(t, n);
        },
        Mu = function (e, t) {
          return cl(e[t]) ? wu : hl(e[t]) && e.setAttribute ? bu : _u;
        },
        Su = function (e, t) {
          return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4, t);
        },
        Tu = function (e, t) {
          return t.set(t.t, t.p, !!(t.s + t.c * e), t);
        },
        Eu = function (e, t) {
          var n = t._pt,
            i = "";
          if (!e && t.b) i = t.b;
          else if (1 === e && t.e) i = t.e;
          else {
            for (; n; )
              (i =
                n.p +
                (n.m
                  ? n.m(n.s + n.c * e)
                  : Math.round(1e4 * (n.s + n.c * e)) / 1e4) +
                i),
                (n = n._next);
            i += t.c;
          }
          t.set(t.t, t.p, i, t);
        },
        Au = function (e, t) {
          for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
        },
        Lu = function (e, t, n, i) {
          for (var r, a = this._pt; a; )
            (r = a._next), a.p === i && a.modifier(e, t, n), (a = r);
        },
        Pu = function (e) {
          for (var t, n, i = this._pt; i; )
            (n = i._next),
              (i.p === e && !i.op) || i.op === e
                ? nh(this, i, "_pt")
                : i.dep || (t = 1),
              (i = n);
          return !t;
        },
        Ru = function (e, t, n, i) {
          i.mSet(e, t, i.m.call(i.tween, n, i.mt), i);
        },
        ku = function (e) {
          for (var t, n, i, r, a = e._pt; a; ) {
            for (t = a._next, n = i; n && n.pr > a.pr; ) n = n._next;
            (a._prev = n ? n._prev : r) ? (a._prev._next = a) : (i = a),
              (a._next = n) ? (n._prev = a) : (r = a),
              (a = t);
          }
          e._pt = i;
        },
        Cu = (function () {
          function e(e, t, n, i, r, a, o, s, c) {
            (this.t = t),
              (this.s = i),
              (this.c = r),
              (this.p = n),
              (this.r = a || Su),
              (this.d = o || this),
              (this.set = s || _u),
              (this.pr = c || 0),
              (this._next = e),
              e && (e._prev = this);
          }
          return (
            (e.prototype.modifier = function (e, t, n) {
              (this.mSet = this.mSet || this.set),
                (this.set = Ru),
                (this.m = e),
                (this.mt = n),
                (this.tween = t);
            }),
            e
          );
        })();
      Ul(
        Fl +
          "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
        function (e) {
          return (kl[e] = 1);
        }
      ),
        (Sl.TweenMax = Sl.TweenLite = yu),
        (Sl.TimelineLite = Sl.TimelineMax = lu),
        (Hc = new lu({
          sortChildren: !1,
          defaults: Kc,
          autoRemoveChildren: !0,
          id: "root",
          smoothChildTiming: !0,
        })),
        (Qc.stringFilter = Xh);
      var Ou = {
        registerPlugin: function () {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          t.forEach(function (e) {
            return Fh(e);
          });
        },
        timeline: function (e) {
          return new lu(e);
        },
        getTweensOf: function (e, t) {
          return Hc.getTweensOf(e, t);
        },
        getProperty: function (e, t, n, i) {
          sl(e) && (e = Eh(e)[0]);
          var r = Bl(e || {}).get,
            a = n ? Jl : Yl;
          return (
            "native" === n && (n = ""),
            e
              ? t
                ? a(((Nl[t] && Nl[t].get) || r)(e, t, n, i))
                : function (t, n, i) {
                    return a(((Nl[t] && Nl[t].get) || r)(e, t, n, i));
                  }
              : e
          );
        },
        quickSetter: function (e, t, n) {
          if ((e = Eh(e)).length > 1) {
            var i = e.map(function (e) {
                return Du.quickSetter(e, t, n);
              }),
              r = i.length;
            return function (e) {
              for (var t = r; t--; ) i[t](e);
            };
          }
          e = e[0] || {};
          var a = Nl[t],
            o = Bl(e),
            s = (o.harness && (o.harness.aliases || {})[t]) || t,
            c = a
              ? function (t) {
                  var i = new a();
                  (Vc._pt = 0),
                    i.init(e, n ? t + n : t, Vc, 0, [e]),
                    i.render(1, i),
                    Vc._pt && Au(1, Vc);
                }
              : o.set(e, s);
          return a
            ? c
            : function (t) {
                return c(e, s, n ? t + n : t, o, 1);
              };
        },
        isTweening: function (e) {
          return Hc.getTweensOf(e, !0).length > 0;
        },
        defaults: function (e) {
          return e && e.ease && (e.ease = nu(e.ease, Kc.ease)), $l(Kc, e || {});
        },
        config: function (e) {
          return $l(Qc, e || {});
        },
        registerEffect: function (e) {
          var t = e.name,
            n = e.effect,
            i = e.plugins,
            r = e.defaults,
            a = e.extendTimeline;
          (i || "").split(",").forEach(function (e) {
            return (
              e &&
              !Nl[e] &&
              !Sl[e] &&
              Ll(t + " effect requires " + e + " plugin.")
            );
          }),
            (Il[t] = function (e, t, i) {
              return n(Eh(e), Zl(t || {}, r), i);
            }),
            a &&
              (lu.prototype[t] = function (e, n, i) {
                return this.add(Il[t](e, ul(n) ? n : (i = n) && {}, this), i);
              });
        },
        registerEase: function (e, t) {
          Zh[e] = nu(t);
        },
        parseEase: function (e, t) {
          return arguments.length ? nu(e, t) : Zh;
        },
        getById: function (e) {
          return Hc.getById(e);
        },
        exportRoot: function (e, t) {
          void 0 === e && (e = {});
          var n,
            i,
            r = new lu(e);
          for (
            r.smoothChildTiming = pl(e.smoothChildTiming),
              Hc.remove(r),
              r._dp = 0,
              r._time = r._tTime = Hc._time,
              n = Hc._first;
            n;

          )
            (i = n._next),
              (!t &&
                !n._dur &&
                n instanceof yu &&
                n.vars.onComplete === n._targets[0]) ||
                dh(r, n, n._start - n._delay),
              (n = i);
          return dh(Hc, r, 0), r;
        },
        utils: {
          wrap: function e(t, n, i) {
            var r = n - t;
            return gl(t)
              ? Ch(t, e(0, t.length), n)
              : xh(i, function (e) {
                  return ((r + ((e - t) % r)) % r) + t;
                });
          },
          wrapYoyo: function e(t, n, i) {
            var r = n - t,
              a = 2 * r;
            return gl(t)
              ? Ch(t, e(0, t.length - 1), n)
              : xh(i, function (e) {
                  return (
                    t + ((e = (a + ((e - t) % a)) % a || 0) > r ? a - e : e)
                  );
                });
          },
          distribute: Lh,
          random: kh,
          snap: Rh,
          normalize: function (e, t, n) {
            return Nh(e, t, 0, 1, n);
          },
          getUnit: Mh,
          clamp: function (e, t, n) {
            return xh(n, function (n) {
              return bh(e, t, n);
            });
          },
          splitColor: Uh,
          toArray: Eh,
          mapRange: Nh,
          pipe: function () {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            return function (e) {
              return t.reduce(function (e, t) {
                return t(e);
              }, e);
            };
          },
          unitize: function (e, t) {
            return function (n) {
              return e(parseFloat(n)) + (t || Mh(n));
            };
          },
          interpolate: function e(t, n, i, r) {
            var a = isNaN(t + n)
              ? 0
              : function (e) {
                  return (1 - e) * t + e * n;
                };
            if (!a) {
              var o,
                s,
                c,
                l,
                h,
                u = sl(t),
                p = {};
              if ((!0 === i && (r = 1) && (i = null), u))
                (t = { p: t }), (n = { p: n });
              else if (gl(t) && !gl(n)) {
                for (c = [], l = t.length, h = l - 2, s = 1; s < l; s++)
                  c.push(e(t[s - 1], t[s]));
                l--,
                  (a = function (e) {
                    e *= l;
                    var t = Math.min(h, ~~e);
                    return c[t](e - t);
                  }),
                  (i = n);
              } else r || (t = Kl(gl(t) ? [] : {}, t));
              if (!c) {
                for (o in n) pu.call(p, t, o, "get", n[o]);
                a = function (e) {
                  return Au(e, p) || (u ? t.p : t);
                };
              }
            }
            return xh(i, a);
          },
          shuffle: Ah,
        },
        install: El,
        effects: Il,
        ticker: Yh,
        updateRoot: lu.updateRoot,
        plugins: Nl,
        globalTimeline: Hc,
        core: {
          PropTween: Cu,
          globals: Pl,
          Tween: yu,
          Timeline: lu,
          Animation: cu,
          getCache: Bl,
          _removeLinkedListItem: nh,
          suppressOverwrites: function (e) {
            return (Fc = e);
          },
        },
      };
      Ul("to,from,fromTo,delayedCall,set,killTweensOf", function (e) {
        return (Ou[e] = yu[e]);
      }),
        Yh.add(lu.updateRoot),
        (Vc = Ou.to({}, { duration: 0 }));
      var Nu = function (e, t) {
          for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
            n = n._next;
          return n;
        },
        Iu = function (e, t) {
          return {
            name: e,
            rawVars: 1,
            init: function (e, n, i) {
              i._onInit = function (e) {
                var i, r;
                if (
                  (sl(n) &&
                    ((i = {}),
                    Ul(n, function (e) {
                      return (i[e] = 1);
                    }),
                    (n = i)),
                  t)
                ) {
                  for (r in ((i = {}), n)) i[r] = t(n[r]);
                  n = i;
                }
                !(function (e, t) {
                  var n,
                    i,
                    r,
                    a = e._targets;
                  for (n in t)
                    for (i = a.length; i--; )
                      (r = e._ptLookup[i][n]) &&
                        (r = r.d) &&
                        (r._pt && (r = Nu(r, n)),
                        r && r.modifier && r.modifier(t[n], e, a[i], n));
                })(e, n);
              };
            },
          };
        },
        Du =
          Ou.registerPlugin(
            {
              name: "attr",
              init: function (e, t, n, i, r) {
                var a, o;
                for (a in t)
                  (o = this.add(
                    e,
                    "setAttribute",
                    (e.getAttribute(a) || 0) + "",
                    t[a],
                    i,
                    r,
                    0,
                    0,
                    a
                  )) && (o.op = a),
                    this._props.push(a);
              },
            },
            {
              name: "endArray",
              init: function (e, t) {
                for (var n = t.length; n--; ) this.add(e, n, e[n] || 0, t[n]);
              },
            },
            Iu("roundProps", Ph),
            Iu("modifiers"),
            Iu("snap", Rh)
          ) || Ou;
      (yu.version = lu.version = Du.version = "3.6.0"),
        (Gc = 1),
        dl() && Jh(),
        Zh.Power0,
        Zh.Power1,
        Zh.Power2,
        Zh.Power3,
        Zh.Power4,
        Zh.Linear,
        Zh.Quad,
        Zh.Cubic,
        Zh.Quart,
        Zh.Quint,
        Zh.Strong,
        Zh.Elastic,
        Zh.Back,
        Zh.SteppedEase,
        Zh.Bounce,
        Zh.Sine,
        Zh.Expo,
        Zh.Circ;
      var ju,
        Fu,
        Hu,
        Bu,
        zu,
        Uu,
        Gu,
        Wu,
        Vu = {},
        qu = 180 / Math.PI,
        Xu = Math.PI / 180,
        Yu = Math.atan2,
        Ju = /([A-Z])/g,
        Zu = /(?:left|right|width|margin|padding|x)/i,
        Qu = /[\s,\(]\S/,
        Ku = {
          autoAlpha: "opacity,visibility",
          scale: "scaleX,scaleY",
          alpha: "opacity",
        },
        $u = function (e, t) {
          return t.set(
            t.t,
            t.p,
            Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u,
            t
          );
        },
        ep = function (e, t) {
          return t.set(
            t.t,
            t.p,
            1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u,
            t
          );
        },
        tp = function (e, t) {
          return t.set(
            t.t,
            t.p,
            e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b,
            t
          );
        },
        np = function (e, t) {
          var n = t.s + t.c * e;
          t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
        },
        ip = function (e, t) {
          return t.set(t.t, t.p, e ? t.e : t.b, t);
        },
        rp = function (e, t) {
          return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t);
        },
        ap = function (e, t, n) {
          return (e.style[t] = n);
        },
        op = function (e, t, n) {
          return e.style.setProperty(t, n);
        },
        sp = function (e, t, n) {
          return (e._gsap[t] = n);
        },
        cp = function (e, t, n) {
          return (e._gsap.scaleX = e._gsap.scaleY = n);
        },
        lp = function (e, t, n, i, r) {
          var a = e._gsap;
          (a.scaleX = a.scaleY = n), a.renderTransform(r, a);
        },
        hp = function (e, t, n, i, r) {
          var a = e._gsap;
          (a[t] = n), a.renderTransform(r, a);
        },
        up = "transform",
        pp = up + "Origin",
        dp = function (e, t) {
          var n = Fu.createElementNS
            ? Fu.createElementNS(
                (t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
                e
              )
            : Fu.createElement(e);
          return n.style ? n : Fu.createElement(e);
        },
        fp = function e(t, n, i) {
          var r = getComputedStyle(t);
          return (
            r[n] ||
            r.getPropertyValue(n.replace(Ju, "-$1").toLowerCase()) ||
            r.getPropertyValue(n) ||
            (!i && e(t, gp(n) || n, 1)) ||
            ""
          );
        },
        mp = "O,Moz,ms,Ms,Webkit".split(","),
        gp = function (e, t, n) {
          var i = (t || zu).style,
            r = 5;
          if (e in i && !n) return e;
          for (
            e = e.charAt(0).toUpperCase() + e.substr(1);
            r-- && !(mp[r] + e in i);

          );
          return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? mp[r] : "") + e;
        },
        vp = function () {
          "undefined" != typeof window &&
            window.document &&
            ((ju = window),
            (Fu = ju.document),
            (Hu = Fu.documentElement),
            (zu = dp("div") || { style: {} }),
            (Uu = dp("div")),
            (up = gp(up)),
            (pp = up + "Origin"),
            (zu.style.cssText =
              "border-width:0;line-height:0;position:absolute;padding:0"),
            (Wu = !!gp("perspective")),
            (Bu = 1));
        },
        yp = function e(t) {
          var n,
            i = dp(
              "svg",
              (this.ownerSVGElement &&
                this.ownerSVGElement.getAttribute("xmlns")) ||
                "http://www.w3.org/2000/svg"
            ),
            r = this.parentNode,
            a = this.nextSibling,
            o = this.style.cssText;
          if (
            (Hu.appendChild(i),
            i.appendChild(this),
            (this.style.display = "block"),
            t)
          )
            try {
              (n = this.getBBox()),
                (this._gsapBBox = this.getBBox),
                (this.getBBox = e);
            } catch (e) {}
          else this._gsapBBox && (n = this._gsapBBox());
          return (
            r && (a ? r.insertBefore(this, a) : r.appendChild(this)),
            Hu.removeChild(i),
            (this.style.cssText = o),
            n
          );
        },
        _p = function (e, t) {
          for (var n = t.length; n--; )
            if (e.hasAttribute(t[n])) return e.getAttribute(t[n]);
        },
        wp = function (e) {
          var t;
          try {
            t = e.getBBox();
          } catch (n) {
            t = yp.call(e, !0);
          }
          return (
            (t && (t.width || t.height)) ||
              e.getBBox === yp ||
              (t = yp.call(e, !0)),
            !t || t.width || t.x || t.y
              ? t
              : {
                  x: +_p(e, ["x", "cx", "x1"]) || 0,
                  y: +_p(e, ["y", "cy", "y1"]) || 0,
                  width: 0,
                  height: 0,
                }
          );
        },
        xp = function (e) {
          return !(!e.getCTM || (e.parentNode && !e.ownerSVGElement) || !wp(e));
        },
        bp = function (e, t) {
          if (t) {
            var n = e.style;
            t in Vu && t !== pp && (t = up),
              n.removeProperty
                ? (("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6)) ||
                    (t = "-" + t),
                  n.removeProperty(t.replace(Ju, "-$1").toLowerCase()))
                : n.removeAttribute(t);
          }
        },
        Mp = function (e, t, n, i, r, a) {
          var o = new Cu(e._pt, t, n, 0, 1, a ? rp : ip);
          return (e._pt = o), (o.b = i), (o.e = r), e._props.push(n), o;
        },
        Sp = { deg: 1, rad: 1, turn: 1 },
        Tp = function e(t, n, i, r) {
          var a,
            o,
            s,
            c,
            l = parseFloat(i) || 0,
            h = (i + "").trim().substr((l + "").length) || "px",
            u = zu.style,
            p = Zu.test(n),
            d = "svg" === t.tagName.toLowerCase(),
            f = (d ? "client" : "offset") + (p ? "Width" : "Height"),
            m = 100,
            g = "px" === r,
            v = "%" === r;
          return r === h || !l || Sp[r] || Sp[h]
            ? l
            : ("px" !== h && !g && (l = e(t, n, i, "px")),
              (c = t.getCTM && xp(t)),
              (!v && "%" !== h) || (!Vu[n] && !~n.indexOf("adius"))
                ? ((u[p ? "width" : "height"] = m + (g ? h : r)),
                  (o =
                    ~n.indexOf("adius") || ("em" === r && t.appendChild && !d)
                      ? t
                      : t.parentNode),
                  c && (o = (t.ownerSVGElement || {}).parentNode),
                  (o && o !== Fu && o.appendChild) || (o = Fu.body),
                  (s = o._gsap) && v && s.width && p && s.time === Yh.time
                    ? Gl((l / s.width) * m)
                    : ((v || "%" === h) && (u.position = fp(t, "position")),
                      o === t && (u.position = "static"),
                      o.appendChild(zu),
                      (a = zu[f]),
                      o.removeChild(zu),
                      (u.position = "absolute"),
                      p &&
                        v &&
                        (((s = Bl(o)).time = Yh.time), (s.width = o[f])),
                      Gl(g ? (a * l) / m : a && l ? (m / a) * l : 0)))
                : ((a = c ? t.getBBox()[p ? "width" : "height"] : t[f]),
                  Gl(v ? (l / a) * m : (l / 100) * a)));
        },
        Ep = function (e, t, n, i) {
          var r;
          return (
            Bu || vp(),
            t in Ku &&
              "transform" !== t &&
              ~(t = Ku[t]).indexOf(",") &&
              (t = t.split(",")[0]),
            Vu[t] && "transform" !== t
              ? ((r = jp(e, i)),
                (r =
                  "transformOrigin" !== t
                    ? r[t]
                    : Fp(fp(e, pp)) + " " + r.zOrigin + "px"))
              : (!(r = e.style[t]) ||
                  "auto" === r ||
                  i ||
                  ~(r + "").indexOf("calc(")) &&
                (r =
                  (Rp[t] && Rp[t](e, t, n)) ||
                  fp(e, t) ||
                  zl(e, t) ||
                  ("opacity" === t ? 1 : 0)),
            n && !~(r + "").trim().indexOf(" ") ? Tp(e, t, r, n) + n : r
          );
        },
        Ap = function (e, t, n, i) {
          if (!n || "none" === n) {
            var r = gp(t, e, 1),
              a = r && fp(e, r, 1);
            a && a !== n
              ? ((t = r), (n = a))
              : "borderColor" === t && (n = fp(e, "borderTopColor"));
          }
          var o,
            s,
            c,
            l,
            h,
            u,
            p,
            d,
            f,
            m,
            g,
            v,
            y = new Cu(this._pt, e.style, t, 0, 1, Eu),
            _ = 0,
            w = 0;
          if (
            ((y.b = n),
            (y.e = i),
            (n += ""),
            "auto" == (i += "") &&
              ((e.style[t] = i), (i = fp(e, t) || i), (e.style[t] = n)),
            Xh((o = [n, i])),
            (i = o[1]),
            (c = (n = o[0]).match(_l) || []),
            (i.match(_l) || []).length)
          ) {
            for (; (s = _l.exec(i)); )
              (p = s[0]),
                (f = i.substring(_, s.index)),
                h
                  ? (h = (h + 1) % 5)
                  : ("rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5)) ||
                    (h = 1),
                p !== (u = c[w++] || "") &&
                  ((l = parseFloat(u) || 0),
                  (g = u.substr((l + "").length)),
                  (v = "=" === p.charAt(1) ? +(p.charAt(0) + "1") : 0) &&
                    (p = p.substr(2)),
                  (d = parseFloat(p)),
                  (m = p.substr((d + "").length)),
                  (_ = _l.lastIndex - m.length),
                  m ||
                    ((m = m || Qc.units[t] || g),
                    _ === i.length && ((i += m), (y.e += m))),
                  g !== m && (l = Tp(e, t, u, m) || 0),
                  (y._pt = {
                    _next: y._pt,
                    p: f || 1 === w ? f : ",",
                    s: l,
                    c: v ? v * d : d - l,
                    m: (h && h < 4) || "zIndex" === t ? Math.round : 0,
                  }));
            y.c = _ < i.length ? i.substring(_, i.length) : "";
          } else y.r = "display" === t && "none" === i ? rp : ip;
          return xl.test(i) && (y.e = 0), (this._pt = y), y;
        },
        Lp = {
          top: "0%",
          bottom: "100%",
          left: "0%",
          right: "100%",
          center: "50%",
        },
        Pp = function (e, t) {
          if (t.tween && t.tween._time === t.tween._dur) {
            var n,
              i,
              r,
              a = t.t,
              o = a.style,
              s = t.u,
              c = a._gsap;
            if ("all" === s || !0 === s) (o.cssText = ""), (i = 1);
            else
              for (r = (s = s.split(",")).length; --r > -1; )
                (n = s[r]),
                  Vu[n] && ((i = 1), (n = "transformOrigin" === n ? pp : up)),
                  bp(a, n);
            i &&
              (bp(a, up),
              c &&
                (c.svg && a.removeAttribute("transform"),
                jp(a, 1),
                (c.uncache = 1)));
          }
        },
        Rp = {
          clearProps: function (e, t, n, i, r) {
            if ("isFromStart" !== r.data) {
              var a = (e._pt = new Cu(e._pt, t, n, 0, 0, Pp));
              return (
                (a.u = i), (a.pr = -10), (a.tween = r), e._props.push(n), 1
              );
            }
          },
        },
        kp = [1, 0, 0, 1, 0, 0],
        Cp = {},
        Op = function (e) {
          return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e;
        },
        Np = function (e) {
          var t = fp(e, up);
          return Op(t) ? kp : t.substr(7).match(yl).map(Gl);
        },
        Ip = function (e, t) {
          var n,
            i,
            r,
            a,
            o = e._gsap || Bl(e),
            s = e.style,
            c = Np(e);
          return o.svg && e.getAttribute("transform")
            ? "1,0,0,1,0,0" ===
              (c = [
                (r = e.transform.baseVal.consolidate().matrix).a,
                r.b,
                r.c,
                r.d,
                r.e,
                r.f,
              ]).join(",")
              ? kp
              : c
            : (c !== kp ||
                e.offsetParent ||
                e === Hu ||
                o.svg ||
                ((r = s.display),
                (s.display = "block"),
                ((n = e.parentNode) && e.offsetParent) ||
                  ((a = 1), (i = e.nextSibling), Hu.appendChild(e)),
                (c = Np(e)),
                r ? (s.display = r) : bp(e, "display"),
                a &&
                  (i
                    ? n.insertBefore(e, i)
                    : n
                    ? n.appendChild(e)
                    : Hu.removeChild(e))),
              t && c.length > 6 ? [c[0], c[1], c[4], c[5], c[12], c[13]] : c);
        },
        Dp = function (e, t, n, i, r, a) {
          var o,
            s,
            c,
            l = e._gsap,
            h = r || Ip(e, !0),
            u = l.xOrigin || 0,
            p = l.yOrigin || 0,
            d = l.xOffset || 0,
            f = l.yOffset || 0,
            m = h[0],
            g = h[1],
            v = h[2],
            y = h[3],
            _ = h[4],
            w = h[5],
            x = t.split(" "),
            b = parseFloat(x[0]) || 0,
            M = parseFloat(x[1]) || 0;
          n
            ? h !== kp &&
              (s = m * y - g * v) &&
              ((c = b * (-g / s) + M * (m / s) - (m * w - g * _) / s),
              (b = b * (y / s) + M * (-v / s) + (v * w - y * _) / s),
              (M = c))
            : ((b =
                (o = wp(e)).x + (~x[0].indexOf("%") ? (b / 100) * o.width : b)),
              (M =
                o.y +
                (~(x[1] || x[0]).indexOf("%") ? (M / 100) * o.height : M))),
            i || (!1 !== i && l.smooth)
              ? ((_ = b - u),
                (w = M - p),
                (l.xOffset = d + (_ * m + w * v) - _),
                (l.yOffset = f + (_ * g + w * y) - w))
              : (l.xOffset = l.yOffset = 0),
            (l.xOrigin = b),
            (l.yOrigin = M),
            (l.smooth = !!i),
            (l.origin = t),
            (l.originIsAbsolute = !!n),
            (e.style[pp] = "0px 0px"),
            a &&
              (Mp(a, l, "xOrigin", u, b),
              Mp(a, l, "yOrigin", p, M),
              Mp(a, l, "xOffset", d, l.xOffset),
              Mp(a, l, "yOffset", f, l.yOffset)),
            e.setAttribute("data-svg-origin", b + " " + M);
        },
        jp = function (e, t) {
          var n = e._gsap || new su(e);
          if ("x" in n && !t && !n.uncache) return n;
          var i,
            r,
            a,
            o,
            s,
            c,
            l,
            h,
            u,
            p,
            d,
            f,
            m,
            g,
            v,
            y,
            _,
            w,
            x,
            b,
            M,
            S,
            T,
            E,
            A,
            L,
            P,
            R,
            k,
            C,
            O,
            N,
            I = e.style,
            D = n.scaleX < 0,
            j = "px",
            F = "deg",
            H = fp(e, pp) || "0";
          return (
            (i = r = a = c = l = h = u = p = d = 0),
            (o = s = 1),
            (n.svg = !(!e.getCTM || !xp(e))),
            (g = Ip(e, n.svg)),
            n.svg &&
              ((E = !n.uncache && e.getAttribute("data-svg-origin")),
              Dp(e, E || H, !!E || n.originIsAbsolute, !1 !== n.smooth, g)),
            (f = n.xOrigin || 0),
            (m = n.yOrigin || 0),
            g !== kp &&
              ((w = g[0]),
              (x = g[1]),
              (b = g[2]),
              (M = g[3]),
              (i = S = g[4]),
              (r = T = g[5]),
              6 === g.length
                ? ((o = Math.sqrt(w * w + x * x)),
                  (s = Math.sqrt(M * M + b * b)),
                  (c = w || x ? Yu(x, w) * qu : 0),
                  (u = b || M ? Yu(b, M) * qu + c : 0) &&
                    (s *= Math.cos(u * Xu)),
                  n.svg &&
                    ((i -= f - (f * w + m * b)), (r -= m - (f * x + m * M))))
                : ((N = g[6]),
                  (C = g[7]),
                  (P = g[8]),
                  (R = g[9]),
                  (k = g[10]),
                  (O = g[11]),
                  (i = g[12]),
                  (r = g[13]),
                  (a = g[14]),
                  (l = (v = Yu(N, k)) * qu),
                  v &&
                    ((E = S * (y = Math.cos(-v)) + P * (_ = Math.sin(-v))),
                    (A = T * y + R * _),
                    (L = N * y + k * _),
                    (P = S * -_ + P * y),
                    (R = T * -_ + R * y),
                    (k = N * -_ + k * y),
                    (O = C * -_ + O * y),
                    (S = E),
                    (T = A),
                    (N = L)),
                  (h = (v = Yu(-b, k)) * qu),
                  v &&
                    ((y = Math.cos(-v)),
                    (O = M * (_ = Math.sin(-v)) + O * y),
                    (w = E = w * y - P * _),
                    (x = A = x * y - R * _),
                    (b = L = b * y - k * _)),
                  (c = (v = Yu(x, w)) * qu),
                  v &&
                    ((E = w * (y = Math.cos(v)) + x * (_ = Math.sin(v))),
                    (A = S * y + T * _),
                    (x = x * y - w * _),
                    (T = T * y - S * _),
                    (w = E),
                    (S = A)),
                  l &&
                    Math.abs(l) + Math.abs(c) > 359.9 &&
                    ((l = c = 0), (h = 180 - h)),
                  (o = Gl(Math.sqrt(w * w + x * x + b * b))),
                  (s = Gl(Math.sqrt(T * T + N * N))),
                  (v = Yu(S, T)),
                  (u = Math.abs(v) > 2e-4 ? v * qu : 0),
                  (d = O ? 1 / (O < 0 ? -O : O) : 0)),
              n.svg &&
                ((E = e.getAttribute("transform")),
                (n.forceCSS =
                  e.setAttribute("transform", "") || !Op(fp(e, up))),
                E && e.setAttribute("transform", E))),
            Math.abs(u) > 90 &&
              Math.abs(u) < 270 &&
              (D
                ? ((o *= -1),
                  (u += c <= 0 ? 180 : -180),
                  (c += c <= 0 ? 180 : -180))
                : ((s *= -1), (u += u <= 0 ? 180 : -180))),
            (n.x =
              i -
              ((n.xPercent =
                i &&
                (n.xPercent ||
                  (Math.round(e.offsetWidth / 2) === Math.round(-i) ? -50 : 0)))
                ? (e.offsetWidth * n.xPercent) / 100
                : 0) +
              j),
            (n.y =
              r -
              ((n.yPercent =
                r &&
                (n.yPercent ||
                  (Math.round(e.offsetHeight / 2) === Math.round(-r)
                    ? -50
                    : 0)))
                ? (e.offsetHeight * n.yPercent) / 100
                : 0) +
              j),
            (n.z = a + j),
            (n.scaleX = Gl(o)),
            (n.scaleY = Gl(s)),
            (n.rotation = Gl(c) + F),
            (n.rotationX = Gl(l) + F),
            (n.rotationY = Gl(h) + F),
            (n.skewX = u + F),
            (n.skewY = p + F),
            (n.transformPerspective = d + j),
            (n.zOrigin = parseFloat(H.split(" ")[2]) || 0) && (I[pp] = Fp(H)),
            (n.xOffset = n.yOffset = 0),
            (n.force3D = Qc.force3D),
            (n.renderTransform = n.svg ? Vp : Wu ? Wp : Bp),
            (n.uncache = 0),
            n
          );
        },
        Fp = function (e) {
          return (e = e.split(" "))[0] + " " + e[1];
        },
        Hp = function (e, t, n) {
          var i = Mh(t);
          return Gl(parseFloat(t) + parseFloat(Tp(e, "x", n + "px", i))) + i;
        },
        Bp = function (e, t) {
          (t.z = "0px"),
            (t.rotationY = t.rotationX = "0deg"),
            (t.force3D = 0),
            Wp(e, t);
        },
        zp = "0deg",
        Up = "0px",
        Gp = ") ",
        Wp = function (e, t) {
          var n = t || this,
            i = n.xPercent,
            r = n.yPercent,
            a = n.x,
            o = n.y,
            s = n.z,
            c = n.rotation,
            l = n.rotationY,
            h = n.rotationX,
            u = n.skewX,
            p = n.skewY,
            d = n.scaleX,
            f = n.scaleY,
            m = n.transformPerspective,
            g = n.force3D,
            v = n.target,
            y = n.zOrigin,
            _ = "",
            w = ("auto" === g && e && 1 !== e) || !0 === g;
          if (y && (h !== zp || l !== zp)) {
            var x,
              b = parseFloat(l) * Xu,
              M = Math.sin(b),
              S = Math.cos(b);
            (b = parseFloat(h) * Xu),
              (x = Math.cos(b)),
              (a = Hp(v, a, M * x * -y)),
              (o = Hp(v, o, -Math.sin(b) * -y)),
              (s = Hp(v, s, S * x * -y + y));
          }
          m !== Up && (_ += "perspective(" + m + Gp),
            (i || r) && (_ += "translate(" + i + "%, " + r + "%) "),
            (w || a !== Up || o !== Up || s !== Up) &&
              (_ +=
                s !== Up || w
                  ? "translate3d(" + a + ", " + o + ", " + s + ") "
                  : "translate(" + a + ", " + o + Gp),
            c !== zp && (_ += "rotate(" + c + Gp),
            l !== zp && (_ += "rotateY(" + l + Gp),
            h !== zp && (_ += "rotateX(" + h + Gp),
            (u === zp && p === zp) || (_ += "skew(" + u + ", " + p + Gp),
            (1 === d && 1 === f) || (_ += "scale(" + d + ", " + f + Gp),
            (v.style[up] = _ || "translate(0, 0)");
        },
        Vp = function (e, t) {
          var n,
            i,
            r,
            a,
            o,
            s = t || this,
            c = s.xPercent,
            l = s.yPercent,
            h = s.x,
            u = s.y,
            p = s.rotation,
            d = s.skewX,
            f = s.skewY,
            m = s.scaleX,
            g = s.scaleY,
            v = s.target,
            y = s.xOrigin,
            _ = s.yOrigin,
            w = s.xOffset,
            x = s.yOffset,
            b = s.forceCSS,
            M = parseFloat(h),
            S = parseFloat(u);
          (p = parseFloat(p)),
            (d = parseFloat(d)),
            (f = parseFloat(f)) && ((d += f = parseFloat(f)), (p += f)),
            p || d
              ? ((p *= Xu),
                (d *= Xu),
                (n = Math.cos(p) * m),
                (i = Math.sin(p) * m),
                (r = Math.sin(p - d) * -g),
                (a = Math.cos(p - d) * g),
                d &&
                  ((f *= Xu),
                  (o = Math.tan(d - f)),
                  (r *= o = Math.sqrt(1 + o * o)),
                  (a *= o),
                  f &&
                    ((o = Math.tan(f)),
                    (n *= o = Math.sqrt(1 + o * o)),
                    (i *= o))),
                (n = Gl(n)),
                (i = Gl(i)),
                (r = Gl(r)),
                (a = Gl(a)))
              : ((n = m), (a = g), (i = r = 0)),
            ((M && !~(h + "").indexOf("px")) ||
              (S && !~(u + "").indexOf("px"))) &&
              ((M = Tp(v, "x", h, "px")), (S = Tp(v, "y", u, "px"))),
            (y || _ || w || x) &&
              ((M = Gl(M + y - (y * n + _ * r) + w)),
              (S = Gl(S + _ - (y * i + _ * a) + x))),
            (c || l) &&
              ((o = v.getBBox()),
              (M = Gl(M + (c / 100) * o.width)),
              (S = Gl(S + (l / 100) * o.height))),
            (o =
              "matrix(" +
              n +
              "," +
              i +
              "," +
              r +
              "," +
              a +
              "," +
              M +
              "," +
              S +
              ")"),
            v.setAttribute("transform", o),
            b && (v.style[up] = o);
        },
        qp = function (e, t, n, i, r, a) {
          var o,
            s,
            c = 360,
            l = sl(r),
            h = parseFloat(r) * (l && ~r.indexOf("rad") ? qu : 1),
            u = a ? h * a : h - i,
            p = i + u + "deg";
          return (
            l &&
              ("short" === (o = r.split("_")[1]) &&
                (u %= c) != u % 180 &&
                (u += u < 0 ? c : -360),
              "cw" === o && u < 0
                ? (u = ((u + 36e9) % c) - ~~(u / c) * c)
                : "ccw" === o &&
                  u > 0 &&
                  (u = ((u - 36e9) % c) - ~~(u / c) * c)),
            (e._pt = s = new Cu(e._pt, t, n, i, u, ep)),
            (s.e = p),
            (s.u = "deg"),
            e._props.push(n),
            s
          );
        },
        Xp = function (e, t, n) {
          var i,
            r,
            a,
            o,
            s,
            c,
            l,
            h = Uu.style,
            u = n._gsap;
          for (r in ((h.cssText =
            getComputedStyle(n).cssText + ";position:absolute;display:block;"),
          (h[up] = t),
          Fu.body.appendChild(Uu),
          (i = jp(Uu, 1)),
          Vu))
            (a = u[r]) !== (o = i[r]) &&
              "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 &&
              ((s = Mh(a) !== (l = Mh(o)) ? Tp(n, r, a, l) : parseFloat(a)),
              (c = parseFloat(o)),
              (e._pt = new Cu(e._pt, u, r, s, c - s, $u)),
              (e._pt.u = l || 0),
              e._props.push(r));
          Fu.body.removeChild(Uu);
        };
      Ul("padding,margin,Width,Radius", function (e, t) {
        var n = "Top",
          i = "Right",
          r = "Bottom",
          a = "Left",
          o = (t < 3 ? [n, i, r, a] : [n + a, n + i, r + i, r + a]).map(
            function (n) {
              return t < 2 ? e + n : "border" + n + e;
            }
          );
        Rp[t > 1 ? "border" + e : e] = function (e, t, n, i, r) {
          var a, s;
          if (arguments.length < 4)
            return (
              (a = o.map(function (t) {
                return Ep(e, t, n);
              })),
              5 === (s = a.join(" ")).split(a[0]).length ? a[0] : s
            );
          (a = (i + "").split(" ")),
            (s = {}),
            o.forEach(function (e, t) {
              return (s[e] = a[t] = a[t] || a[((t - 1) / 2) | 0]);
            }),
            e.init(t, s, r);
        };
      });
      var Yp,
        Jp,
        Zp = {
          name: "css",
          register: vp,
          targetTest: function (e) {
            return e.style && e.nodeType;
          },
          init: function (e, t, n, i, r) {
            var a,
              o,
              s,
              c,
              l,
              h,
              u,
              p,
              d,
              f,
              m,
              g,
              v,
              y,
              _,
              w,
              x,
              b,
              M,
              S = this._props,
              T = e.style,
              E = n.vars.startAt;
            for (u in (Bu || vp(), t))
              if (
                "autoRound" !== u &&
                ((o = t[u]), !Nl[u] || !du(u, t, n, i, e, r))
              )
                if (
                  ((l = typeof o),
                  (h = Rp[u]),
                  "function" === l && (l = typeof (o = o.call(n, i, e, r))),
                  "string" === l && ~o.indexOf("random(") && (o = Oh(o)),
                  h)
                )
                  h(this, e, u, o, n) && (_ = 1);
                else if ("--" === u.substr(0, 2))
                  (a = (getComputedStyle(e).getPropertyValue(u) + "").trim()),
                    (o += ""),
                    (p = Mh(a)),
                    (d = Mh(o))
                      ? p !== d && (a = Tp(e, u, a, d) + d)
                      : p && (o += p),
                    this.add(T, "setProperty", a, o, i, r, 0, 0, u);
                else if ("undefined" !== l) {
                  if (
                    (E && u in E
                      ? ((a =
                          "function" == typeof E[u]
                            ? E[u].call(n, i, e, r)
                            : E[u]),
                        u in Qc.units && !Mh(a) && (a += Qc.units[u]),
                        "=" === (a + "").charAt(1) && (a = Ep(e, u)))
                      : (a = Ep(e, u)),
                    (c = parseFloat(a)),
                    (f =
                      "string" === l && "=" === o.charAt(1)
                        ? +(o.charAt(0) + "1")
                        : 0) && (o = o.substr(2)),
                    (s = parseFloat(o)),
                    u in Ku &&
                      ("autoAlpha" === u &&
                        (1 === c &&
                          "hidden" === Ep(e, "visibility") &&
                          s &&
                          (c = 0),
                        Mp(
                          this,
                          T,
                          "visibility",
                          c ? "inherit" : "hidden",
                          s ? "inherit" : "hidden",
                          !s
                        )),
                      "scale" !== u &&
                        "transform" !== u &&
                        ~(u = Ku[u]).indexOf(",") &&
                        (u = u.split(",")[0])),
                    (m = u in Vu))
                  )
                    if (
                      (g ||
                        (((v = e._gsap).renderTransform && !t.parseTransform) ||
                          jp(e, t.parseTransform),
                        (y = !1 !== t.smoothOrigin && v.smooth),
                        ((g = this._pt =
                          new Cu(
                            this._pt,
                            T,
                            up,
                            0,
                            1,
                            v.renderTransform,
                            v,
                            0,
                            -1
                          )).dep = 1)),
                      "scale" === u)
                    )
                      (this._pt = new Cu(
                        this._pt,
                        v,
                        "scaleY",
                        v.scaleY,
                        f ? f * s : s - v.scaleY
                      )),
                        S.push("scaleY", u),
                        (u += "X");
                    else {
                      if ("transformOrigin" === u) {
                        (x = void 0),
                          (b = void 0),
                          (M = void 0),
                          (b = (x = (w = o).split(" "))[0]),
                          (M = x[1] || "50%"),
                          ("top" !== b &&
                            "bottom" !== b &&
                            "left" !== M &&
                            "right" !== M) ||
                            ((w = b), (b = M), (M = w)),
                          (x[0] = Lp[b] || b),
                          (x[1] = Lp[M] || M),
                          (o = x.join(" ")),
                          v.svg
                            ? Dp(e, o, 0, y, 0, this)
                            : ((d = parseFloat(o.split(" ")[2]) || 0) !==
                                v.zOrigin &&
                                Mp(this, v, "zOrigin", v.zOrigin, d),
                              Mp(this, T, u, Fp(a), Fp(o)));
                        continue;
                      }
                      if ("svgOrigin" === u) {
                        Dp(e, o, 1, y, 0, this);
                        continue;
                      }
                      if (u in Cp) {
                        qp(this, v, u, c, o, f);
                        continue;
                      }
                      if ("smoothOrigin" === u) {
                        Mp(this, v, "smooth", v.smooth, o);
                        continue;
                      }
                      if ("force3D" === u) {
                        v[u] = o;
                        continue;
                      }
                      if ("transform" === u) {
                        Xp(this, o, e);
                        continue;
                      }
                    }
                  else u in T || (u = gp(u) || u);
                  if (
                    m ||
                    ((s || 0 === s) && (c || 0 === c) && !Qu.test(o) && u in T)
                  )
                    s || (s = 0),
                      (p = (a + "").substr((c + "").length)) !==
                        (d = Mh(o) || (u in Qc.units ? Qc.units[u] : p)) &&
                        (c = Tp(e, u, a, d)),
                      (this._pt = new Cu(
                        this._pt,
                        m ? v : T,
                        u,
                        c,
                        f ? f * s : s - c,
                        m ||
                        ("px" !== d && "zIndex" !== u) ||
                        !1 === t.autoRound
                          ? $u
                          : np
                      )),
                      (this._pt.u = d || 0),
                      p !== d && ((this._pt.b = a), (this._pt.r = tp));
                  else if (u in T) Ap.call(this, e, u, a, o);
                  else {
                    if (!(u in e)) {
                      Al(u, o);
                      continue;
                    }
                    this.add(e, u, e[u], o, i, r);
                  }
                  S.push(u);
                }
            _ && ku(this);
          },
          get: Ep,
          aliases: Ku,
          getSetter: function (e, t, n) {
            var i = Ku[t];
            return (
              i && i.indexOf(",") < 0 && (t = i),
              t in Vu && t !== pp && (e._gsap.x || Ep(e, "x"))
                ? n && Gu === n
                  ? "scale" === t
                    ? cp
                    : sp
                  : (Gu = n || {}) && ("scale" === t ? lp : hp)
                : e.style && !hl(e.style[t])
                ? ap
                : ~t.indexOf("-")
                ? op
                : Mu(e, t)
            );
          },
          core: { _removeProperty: bp, _getMatrix: Ip },
        };
      (Du.utils.checkPrefix = gp),
        (Jp = Ul(
          "x,y,z,scale,scaleX,scaleY,xPercent,yPercent" +
            "," +
            (Yp = "rotation,rotationX,rotationY,skewX,skewY") +
            ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
          function (e) {
            Vu[e] = 1;
          }
        )),
        Ul(Yp, function (e) {
          (Qc.units[e] = "deg"), (Cp[e] = 1);
        }),
        (Ku[Jp[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Yp),
        Ul(
          "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
          function (e) {
            var t = e.split(":");
            Ku[t[1]] = Jp[t[0]];
          }
        ),
        Ul(
          "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
          function (e) {
            Qc.units[e] = "px";
          }
        ),
        Du.registerPlugin(Zp);
      var Qp,
        Kp,
        $p,
        ed,
        td,
        nd,
        id,
        rd,
        ad,
        od,
        sd,
        cd,
        ld,
        hd,
        ud,
        pd,
        dd,
        fd,
        md,
        gd,
        vd,
        yd,
        _d,
        wd,
        xd,
        bd,
        Md,
        Sd = Du.registerPlugin(Zp) || Du,
        Td = (Sd.core.Tween, 1),
        Ed = [],
        Ad = [],
        Ld = Date.now,
        Pd = Ld(),
        Rd = 0,
        kd = 1,
        Cd = function (e) {
          return e;
        },
        Od = function () {
          return "undefined" != typeof window;
        },
        Nd = function () {
          return Qp || (Od() && (Qp = window.gsap) && Qp.registerPlugin && Qp);
        },
        Id = function (e) {
          return !!~id.indexOf(e);
        },
        Dd = function (e, t) {
          return ~Ed.indexOf(e) && Ed[Ed.indexOf(e) + 1][t];
        },
        jd = function (e, t) {
          var n = t.s,
            i = t.sc,
            r = Ad.indexOf(e),
            a = i === af.sc ? 1 : 2;
          return (
            !~r && (r = Ad.push(e) - 1),
            Ad[r + a] ||
              (Ad[r + a] =
                Dd(e, n) ||
                (Id(e)
                  ? i
                  : function (t) {
                      return arguments.length ? (e[n] = t) : e[n];
                    }))
          );
        },
        Fd = function (e) {
          return (
            Dd(e, "getBoundingClientRect") ||
            (Id(e)
              ? function () {
                  return (
                    (Wf.width = $p.innerWidth), (Wf.height = $p.innerHeight), Wf
                  );
                }
              : function () {
                  return cf(e);
                })
          );
        },
        Hd = function (e, t) {
          var n = t.s,
            i = t.d2,
            r = t.d,
            a = t.a;
          return (n = "scroll" + i) && (a = Dd(e, n))
            ? a() - Fd(e)()[r]
            : Id(e)
            ? Math.max(td[n], nd[n]) -
              ($p["inner" + i] || td["client" + i] || nd["client" + i])
            : e[n] - e["offset" + i];
        },
        Bd = function (e, t) {
          for (var n = 0; n < vd.length; n += 3)
            (!t || ~t.indexOf(vd[n + 1])) && e(vd[n], vd[n + 1], vd[n + 2]);
        },
        zd = function (e) {
          return "string" == typeof e;
        },
        Ud = function (e) {
          return "function" == typeof e;
        },
        Gd = function (e) {
          return "number" == typeof e;
        },
        Wd = function (e) {
          return "object" == typeof e;
        },
        Vd = function (e) {
          return Ud(e) && e();
        },
        qd = function (e, t) {
          return function () {
            var n = Vd(e),
              i = Vd(t);
            return function () {
              Vd(n), Vd(i);
            };
          };
        },
        Xd = Math.abs,
        Yd = "left",
        Jd = "right",
        Zd = "bottom",
        Qd = "width",
        Kd = "height",
        $d = "padding",
        ef = "margin",
        tf = "Width",
        nf = "px",
        rf = {
          s: "scrollLeft",
          p: Yd,
          p2: "Left",
          os: Jd,
          os2: "Right",
          d: Qd,
          d2: tf,
          a: "x",
          sc: function (e) {
            return arguments.length
              ? $p.scrollTo(e, af.sc())
              : $p.pageXOffset ||
                  ed.scrollLeft ||
                  td.scrollLeft ||
                  nd.scrollLeft ||
                  0;
          },
        },
        af = {
          s: "scrollTop",
          p: "top",
          p2: "Top",
          os: Zd,
          os2: "Bottom",
          d: Kd,
          d2: "Height",
          a: "y",
          op: rf,
          sc: function (e) {
            return arguments.length
              ? $p.scrollTo(rf.sc(), e)
              : $p.pageYOffset ||
                  ed.scrollTop ||
                  td.scrollTop ||
                  nd.scrollTop ||
                  0;
          },
        },
        of = function (e) {
          return $p.getComputedStyle(e);
        },
        sf = function (e, t) {
          for (var n in t) n in e || (e[n] = t[n]);
          return e;
        },
        cf = function (e, t) {
          var n =
              t &&
              "matrix(1, 0, 0, 1, 0, 0)" !== of(e)[dd] &&
              Qp.to(e, {
                x: 0,
                y: 0,
                xPercent: 0,
                yPercent: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                scale: 1,
                skewX: 0,
                skewY: 0,
              }).progress(1),
            i = e.getBoundingClientRect();
          return n && n.progress(0).kill(), i;
        },
        lf = function (e, t) {
          var n = t.d2;
          return e["offset" + n] || e["client" + n] || 0;
        },
        hf = function (e) {
          var t,
            n = [],
            i = e.labels,
            r = e.duration();
          for (t in i) n.push(i[t] / r);
          return n;
        },
        uf = function (e, t, n, i) {
          return n.split(",").forEach(function (n) {
            return e(t, n, i);
          });
        },
        pf = function (e, t, n) {
          return e.addEventListener(t, n, { passive: !0 });
        },
        df = function (e, t, n) {
          return e.removeEventListener(t, n);
        },
        ff = {
          startColor: "green",
          endColor: "red",
          indent: 0,
          fontSize: "16px",
          fontWeight: "normal",
        },
        mf = { toggleActions: "play", anticipatePin: 0 },
        gf = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 },
        vf = function (e, t) {
          if (zd(e)) {
            var n = e.indexOf("="),
              i = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0;
            ~n &&
              (e.indexOf("%") > n && (i *= t / 100), (e = e.substr(0, n - 1))),
              (e =
                i +
                (e in gf
                  ? gf[e] * t
                  : ~e.indexOf("%")
                  ? (parseFloat(e) * t) / 100
                  : parseFloat(e) || 0));
          }
          return e;
        },
        yf = function (e, t, n, i, r, a, o) {
          var s = r.startColor,
            c = r.endColor,
            l = r.fontSize,
            h = r.indent,
            u = r.fontWeight,
            p = ed.createElement("div"),
            d = Id(n) || "fixed" === Dd(n, "pinType"),
            f = -1 !== e.indexOf("scroller"),
            m = d ? nd : n,
            g = -1 !== e.indexOf("start"),
            v = g ? s : c,
            y =
              "border-color:" +
              v +
              ";font-size:" +
              l +
              ";color:" +
              v +
              ";font-weight:" +
              u +
              ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
          return (
            (y += "position:" + (f && d ? "fixed;" : "absolute;")),
            (f || !d) &&
              (y += (i === af ? Jd : Zd) + ":" + (a + parseFloat(h)) + "px;"),
            o &&
              (y +=
                "box-sizing:border-box;text-align:left;width:" +
                o.offsetWidth +
                "px;"),
            (p._isStart = g),
            p.setAttribute("class", "gsap-marker-" + e),
            (p.style.cssText = y),
            (p.innerText = t || 0 === t ? e + "-" + t : e),
            m.children[0] ? m.insertBefore(p, m.children[0]) : m.appendChild(p),
            (p._offset = p["offset" + i.op.d2]),
            _f(p, 0, i, g),
            p
          );
        },
        _f = function (e, t, n, i) {
          var r = { display: "block" },
            a = n[i ? "os2" : "p2"],
            o = n[i ? "p2" : "os2"];
          (e._isFlipped = i),
            (r[n.a + "Percent"] = i ? -100 : 0),
            (r[n.a] = i ? "1px" : 0),
            (r["border" + a + tf] = 1),
            (r["border" + o + tf] = 0),
            (r[n.p] = t + "px"),
            Qp.set(e, r);
        },
        wf = [],
        xf = {},
        bf = function () {
          return od || (od = ad(jf));
        },
        Mf = function () {
          od || ((od = ad(jf)), Rd || Rf("scrollStart"), (Rd = Ld()));
        },
        Sf = function () {
          return !ud && !wd && !ed.fullscreenElement && rd.restart(!0);
        },
        Tf = {},
        Ef = [],
        Af = [],
        Lf = function (e) {
          var t,
            n = Qp.ticker.frame,
            i = [],
            r = 0;
          if (Md !== n || Td) {
            for (Of(); r < Af.length; r += 4)
              (t = $p.matchMedia(Af[r]).matches) !== Af[r + 3] &&
                ((Af[r + 3] = t),
                t ? i.push(r) : Of(1, Af[r]) || (Ud(Af[r + 2]) && Af[r + 2]()));
            for (Cf(), r = 0; r < i.length; r++)
              (t = i[r]), (bd = Af[t]), (Af[t + 2] = Af[t + 1](e));
            (bd = 0), Kp && Nf(0, 1), (Md = n), Rf("matchMedia");
          }
        },
        Pf = function e() {
          return df(Jf, "scrollEnd", e) || Nf(!0);
        },
        Rf = function (e) {
          return (
            (Tf[e] &&
              Tf[e].map(function (e) {
                return e();
              })) ||
            Ef
          );
        },
        kf = [],
        Cf = function (e) {
          for (var t = 0; t < kf.length; t += 4)
            (e && kf[t + 3] !== e) ||
              ((kf[t].style.cssText = kf[t + 1]), (kf[t + 2].uncache = 1));
        },
        Of = function (e, t) {
          var n;
          for (fd = 0; fd < wf.length; fd++)
            (n = wf[fd]),
              (t && n.media !== t) ||
                (e
                  ? n.kill(1)
                  : (n.scroll.rec || (n.scroll.rec = n.scroll()), n.revert()));
          Cf(t), t || Rf("revert");
        },
        Nf = function (e, t) {
          if (!Rd || e) {
            var n = Rf("refreshInit");
            for (yd && Jf.sort(), t || Of(), fd = 0; fd < wf.length; fd++)
              wf[fd].refresh();
            for (
              n.forEach(function (e) {
                return e && e.render && e.render(-1);
              }),
                fd = wf.length;
              fd--;

            )
              wf[fd].scroll.rec = 0;
            rd.pause(), Rf("refresh");
          } else pf(Jf, "scrollEnd", Pf);
        },
        If = 0,
        Df = 1,
        jf = function () {
          var e = wf.length,
            t = Ld(),
            n = t - Pd >= 50,
            i = e && wf[0].scroll();
          if (
            ((Df = If > i ? -1 : 1),
            (If = i),
            n &&
              (Rd && !pd && t - Rd > 200 && ((Rd = 0), Rf("scrollEnd")),
              (ld = Pd),
              (Pd = t)),
            Df < 0)
          ) {
            for (fd = e; fd--; ) wf[fd] && wf[fd].update(0, n);
            Df = 1;
          } else for (fd = 0; fd < e; fd++) wf[fd] && wf[fd].update(0, n);
          od = 0;
        },
        Ff = [
          Yd,
          "top",
          Zd,
          Jd,
          "marginBottom",
          "marginRight",
          "marginTop",
          "marginLeft",
          "display",
          "flexShrink",
          "float",
          "zIndex",
        ],
        Hf = Ff.concat([
          Qd,
          Kd,
          "boxSizing",
          "maxWidth",
          "maxHeight",
          "position",
          ef,
          $d,
          "paddingTop",
          "paddingRight",
          "paddingBottom",
          "paddingLeft",
        ]),
        Bf = function (e, t, n, i) {
          if (e.parentNode !== t) {
            for (var r, a = Ff.length, o = t.style, s = e.style; a--; )
              o[(r = Ff[a])] = n[r];
            (o.position = "absolute" === n.position ? "absolute" : "relative"),
              "inline" === n.display && (o.display = "inline-block"),
              (s.bottom = s.right = "auto"),
              (o.overflow = "visible"),
              (o.boxSizing = "border-box"),
              (o.width = lf(e, rf) + nf),
              (o.height = lf(e, af) + nf),
              (o.padding = s.margin = s.top = s.left = "0"),
              Uf(i),
              (s.width = s.maxWidth = n.width),
              (s.height = s.maxHeight = n.height),
              (s.padding = n.padding),
              e.parentNode.insertBefore(t, e),
              t.appendChild(e);
          }
        },
        zf = /([A-Z])/g,
        Uf = function (e) {
          if (e) {
            var t,
              n,
              i = e.t.style,
              r = e.length,
              a = 0;
            for (
              (e.t._gsap || Qp.core.getCache(e.t)).uncache = 1;
              a < r;
              a += 2
            )
              (n = e[a + 1]),
                (t = e[a]),
                n
                  ? (i[t] = n)
                  : i[t] &&
                    i.removeProperty(t.replace(zf, "-$1").toLowerCase());
          }
        },
        Gf = function (e) {
          for (var t = Hf.length, n = e.style, i = [], r = 0; r < t; r++)
            i.push(Hf[r], n[Hf[r]]);
          return (i.t = e), i;
        },
        Wf = { left: 0, top: 0 },
        Vf = function (e, t, n, i, r, a, o, s, c, l, h, u) {
          if (
            (Ud(e) && (e = e(s)),
            zd(e) &&
              "max" === e.substr(0, 3) &&
              (e = u + ("=" === e.charAt(4) ? vf("0" + e.substr(3), n) : 0)),
            Gd(e))
          )
            o && _f(o, n, i, !0);
          else {
            Ud(t) && (t = t(s));
            var p,
              d,
              f,
              m = sd(t)[0] || nd,
              g = cf(m) || {},
              v = e.split(" ");
            (g && (g.left || g.top)) ||
              "none" !== of(m).display ||
              ((f = m.style.display),
              (m.style.display = "block"),
              (g = cf(m)),
              f ? (m.style.display = f) : m.style.removeProperty("display")),
              (p = vf(v[0], g[i.d])),
              (d = vf(v[1] || "0", n)),
              (e = g[i.p] - c[i.p] - l + p + r - d),
              o && _f(o, d, i, n - d < 20 || (o._isStart && d > 20)),
              (n -= n - d);
          }
          if (a) {
            var y = e + n,
              _ = a._isStart;
            (u = "scroll" + i.d2),
              _f(
                a,
                y,
                i,
                (_ && y > 20) ||
                  (!_ &&
                    (h ? Math.max(nd[u], td[u]) : a.parentNode[u]) <= y + 1)
              ),
              h &&
                ((c = cf(o)),
                h && (a.style[i.op.p] = c[i.op.p] - i.op.m - a._offset + nf));
          }
          return Math.round(e);
        },
        qf = /(?:webkit|moz|length|cssText|inset)/i,
        Xf = function (e, t, n, i) {
          if (e.parentNode !== t) {
            var r,
              a,
              o = e.style;
            if (t === nd) {
              for (r in ((e._stOrig = o.cssText), (a = of(e))))
                +r ||
                  qf.test(r) ||
                  !a[r] ||
                  "string" != typeof o[r] ||
                  "0" === r ||
                  (o[r] = a[r]);
              (o.top = n), (o.left = i);
            } else o.cssText = e._stOrig;
            (Qp.core.getCache(e).uncache = 1), t.appendChild(e);
          }
        },
        Yf = function (e, t) {
          var n,
            i,
            r = jd(e, t),
            a = "_scroll" + t.p2,
            o = function t(o, s, c, l, h) {
              var u = t.tween,
                p = s.onComplete,
                d = {};
              return (
                u && u.kill(),
                (n = Math.round(c)),
                (s[a] = o),
                (s.modifiers = d),
                (d[a] = function (e) {
                  return (
                    (e = Math.round(r())) !== n &&
                    e !== i &&
                    Math.abs(e - n) > 2
                      ? (u.kill(), (t.tween = 0))
                      : (e = c + l * u.ratio + h * u.ratio * u.ratio),
                    (i = n),
                    (n = Math.round(e))
                  );
                }),
                (s.onComplete = function () {
                  (t.tween = 0), p && p.call(u);
                }),
                (u = t.tween = Qp.to(e, s))
              );
            };
          return (
            (e[a] = r),
            e.addEventListener("mousewheel", function () {
              return o.tween && o.tween.kill() && (o.tween = 0);
            }),
            o
          );
        };
      rf.op = af;
      var Jf = (function () {
        function e(t, n) {
          Kp ||
            e.register(Qp) ||
            console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
            this.init(t, n);
        }
        return (
          (e.prototype.init = function (t, n) {
            if (
              ((this.progress = this.start = 0), this.vars && this.kill(1), kd)
            ) {
              var i,
                r,
                a,
                o,
                s,
                c,
                l,
                h,
                u,
                p,
                d,
                f,
                m,
                g,
                v,
                y,
                _,
                w,
                x,
                b,
                M,
                S,
                T,
                E,
                A,
                L,
                P,
                R,
                k,
                C,
                O,
                N,
                I,
                D,
                j,
                F,
                H,
                B,
                z,
                U = (t = sf(
                  zd(t) || Gd(t) || t.nodeType ? { trigger: t } : t,
                  mf
                )).horizontal
                  ? rf
                  : af,
                G = t,
                W = G.onUpdate,
                V = G.toggleClass,
                q = G.id,
                X = G.onToggle,
                Y = G.onRefresh,
                J = G.scrub,
                Z = G.trigger,
                Q = G.pin,
                K = G.pinSpacing,
                $ = G.invalidateOnRefresh,
                ee = G.anticipatePin,
                te = G.onScrubComplete,
                ne = G.onSnapComplete,
                ie = G.once,
                re = G.snap,
                ae = G.pinReparent,
                oe = !J && 0 !== J,
                se = sd(t.scroller || $p)[0],
                ce = Qp.core.getCache(se),
                le = Id(se),
                he =
                  "pinType" in t
                    ? "fixed" === t.pinType
                    : le || "fixed" === Dd(se, "pinType"),
                ue = [t.onEnter, t.onLeave, t.onEnterBack, t.onLeaveBack],
                pe = oe && t.toggleActions.split(" "),
                de = "markers" in t ? t.markers : mf.markers,
                fe = le ? 0 : parseFloat(of(se)["border" + U.p2 + tf]) || 0,
                me = this,
                ge =
                  t.onRefreshInit &&
                  function () {
                    return t.onRefreshInit(me);
                  },
                ve = (function (e, t, n) {
                  var i = n.d,
                    r = n.d2,
                    a = n.a;
                  return (a = Dd(e, "getBoundingClientRect"))
                    ? function () {
                        return a()[i];
                      }
                    : function () {
                        return (t ? $p["inner" + r] : e["client" + r]) || 0;
                      };
                })(se, le, U),
                ye = (function (e, t) {
                  return !t || ~Ed.indexOf(e)
                    ? Fd(e)
                    : function () {
                        return Wf;
                      };
                })(se, le);
              (me.media = bd),
                (ee *= 45),
                wf.push(me),
                (me.scroller = se),
                (me.scroll = jd(se, U)),
                (s = me.scroll()),
                (me.vars = t),
                (n = n || t.animation),
                "refreshPriority" in t && (yd = 1),
                (ce.tweenScroll = ce.tweenScroll || {
                  top: Yf(se, af),
                  left: Yf(se, rf),
                }),
                (me.tweenTo = i = ce.tweenScroll[U.p]),
                n &&
                  ((n.vars.lazy = !1),
                  n._initted ||
                    (!1 !== n.vars.immediateRender &&
                      !1 !== t.immediateRender &&
                      n.render(0, !0, !0)),
                  (me.animation = n.pause()),
                  (n.scrollTrigger = me),
                  (N = Gd(J) && J) &&
                    (O = Qp.to(n, {
                      ease: "power3",
                      duration: N,
                      onComplete: function () {
                        return te && te(me);
                      },
                    })),
                  (k = 0),
                  q || (q = n.vars.id)),
                re &&
                  (Wd(re) || (re = { snapTo: re }),
                  "scrollBehavior" in nd.style &&
                    Qp.set(le ? [nd, td] : se, { scrollBehavior: "auto" }),
                  (a = Ud(re.snapTo)
                    ? re.snapTo
                    : "labels" === re.snapTo
                    ? (function (e) {
                        return function (t) {
                          return Qp.utils.snap(hf(e), t);
                        };
                      })(n)
                    : "labelsDirectional" === re.snapTo
                    ? ((B = n),
                      function (e, t) {
                        var n,
                          i = hf(B);
                        if (
                          (i.sort(function (e, t) {
                            return e - t;
                          }),
                          t.direction > 0)
                        ) {
                          for (n = 0; n < i.length; n++)
                            if (i[n] >= e) return i[n];
                          return i.pop();
                        }
                        for (n = i.length; n--; ) if (i[n] <= e) return i[n];
                        return i[0];
                      })
                    : Qp.utils.snap(re.snapTo)),
                  (I = re.duration || { min: 0.1, max: 2 }),
                  (I = Wd(I) ? cd(I.min, I.max) : cd(I, I)),
                  (D = Qp.delayedCall(re.delay || N / 2 || 0.1, function () {
                    if (Math.abs(me.getVelocity()) < 10 && !pd) {
                      var e = n && !oe ? n.totalProgress() : me.progress,
                        t = ((e - C) / (Ld() - ld)) * 1e3 || 0,
                        r = (Xd(t / 2) * t) / 0.185,
                        o = e + r,
                        s = cd(0, 1, a(o, me)),
                        c = me.scroll(),
                        u = Math.round(l + s * g),
                        p = i.tween;
                      if (c <= h && c >= l && u !== c) {
                        if (p && !p._initted && p.data <= Math.abs(u - c))
                          return;
                        i(
                          u,
                          {
                            duration: I(
                              Xd(
                                (0.185 * Math.max(Xd(o - e), Xd(s - e))) /
                                  t /
                                  0.05 || 0
                              )
                            ),
                            ease: re.ease || "power3",
                            data: Math.abs(u - c),
                            onComplete: function () {
                              (k = C =
                                n && !oe ? n.totalProgress() : me.progress),
                                ne && ne(me);
                            },
                          },
                          c,
                          r * g,
                          u - c - r * g
                        );
                      }
                    } else me.isActive && D.restart(!0);
                  }).pause())),
                q && (xf[q] = me),
                (Z = me.trigger = sd(Z || Q)[0]),
                (Q = !0 === Q ? Z : sd(Q)[0]),
                zd(V) && (V = { targets: Z, className: V }),
                Q &&
                  (!1 === K ||
                    K === ef ||
                    (K = !(!K && "flex" === of(Q.parentNode).display) && $d),
                  (me.pin = Q),
                  !1 !== t.force3D && Qp.set(Q, { force3D: !0 }),
                  (r = Qp.core.getCache(Q)).spacer
                    ? (v = r.pinState)
                    : ((r.spacer = w = ed.createElement("div")),
                      w.setAttribute(
                        "class",
                        "pin-spacer" + (q ? " pin-spacer-" + q : "")
                      ),
                      (r.pinState = v = Gf(Q))),
                  (me.spacer = w = r.spacer),
                  (R = of(Q)),
                  (E = R[K + U.os2]),
                  (b = Qp.getProperty(Q)),
                  (M = Qp.quickSetter(Q, U.a, nf)),
                  Bf(Q, w, R),
                  (_ = Gf(Q))),
                de &&
                  ((m = Wd(de) ? sf(de, ff) : ff),
                  (d = yf("scroller-start", q, se, U, m, 0)),
                  (f = yf("scroller-end", q, se, U, m, 0, d)),
                  (x = d["offset" + U.op.d2]),
                  (u = yf("start", q, se, U, m, x)),
                  (p = yf("end", q, se, U, m, x)),
                  he ||
                    (((z = le ? nd : se).style.position =
                      "absolute" === of(z).position ? "absolute" : "relative"),
                    Qp.set([d, f], { force3D: !0 }),
                    (L = Qp.quickSetter(d, U.a, nf)),
                    (P = Qp.quickSetter(f, U.a, nf)))),
                (me.revert = function (e) {
                  var t = !1 !== e || !me.enabled,
                    i = ud;
                  t !== o &&
                    (t &&
                      ((F = Math.max(me.scroll(), me.scroll.rec || 0)),
                      (j = me.progress),
                      (H = n && n.progress())),
                    u &&
                      [u, p, d, f].forEach(function (e) {
                        return (e.style.display = t ? "none" : "block");
                      }),
                    t && (ud = 1),
                    me.update(t),
                    (ud = i),
                    Q &&
                      (t
                        ? (function (e, t, n) {
                            if ((Uf(n), e.parentNode === t)) {
                              var i = t.parentNode;
                              i && (i.insertBefore(e, t), i.removeChild(t));
                            }
                          })(Q, w, v)
                        : (!ae || !me.isActive) && Bf(Q, w, of(Q), A)),
                    (o = t));
                }),
                (me.refresh = function (i) {
                  if (!ud && me.enabled)
                    if (Q && i && Rd) pf(e, "scrollEnd", Pf);
                    else {
                      (ud = 1),
                        O && O.pause(),
                        $ && n && n.progress(0).invalidate(),
                        o || me.revert();
                      for (
                        var r,
                          a,
                          m,
                          x,
                          M,
                          E,
                          L,
                          P,
                          R,
                          k = ve(),
                          C = ye(),
                          N = Hd(se, U),
                          I = 0,
                          D = 0,
                          B = t.end,
                          z = t.endTrigger || Z,
                          G =
                            t.start ||
                            (0 !== t.start && Z ? (Q ? "0 0" : "0 100%") : 0),
                          W = (Z && Math.max(0, wf.indexOf(me))) || 0,
                          V = W;
                        V--;

                      )
                        (L = wf[V].pin) &&
                          (L === Z || L === Q) &&
                          wf[V].revert();
                      for (
                        l =
                          Vf(G, Z, k, U, me.scroll(), u, d, me, C, fe, he, N) ||
                          (Q ? -0.001 : 0),
                          Ud(B) && (B = B(me)),
                          zd(B) &&
                            !B.indexOf("+=") &&
                            (~B.indexOf(" ")
                              ? (B = (zd(G) ? G.split(" ")[0] : "") + B)
                              : ((I = vf(B.substr(2), k)),
                                (B = zd(G) ? G : l + I),
                                (z = Z))),
                          h =
                            Math.max(
                              l,
                              Vf(
                                B || (z ? "100% 0" : N),
                                z,
                                k,
                                U,
                                me.scroll() + I,
                                p,
                                f,
                                me,
                                C,
                                fe,
                                he,
                                N
                              )
                            ) || -0.001,
                          g = h - l || ((l -= 0.01) && 0.001),
                          I = 0,
                          V = W;
                        V--;

                      )
                        (L = (E = wf[V]).pin) &&
                          E.start - E._pinPush < l &&
                          ((r = E.end - E.start),
                          L === Z && (I += r),
                          L === Q && (D += r));
                      if (
                        ((l += I),
                        (h += I),
                        (me._pinPush = D),
                        u &&
                          I &&
                          (((r = {})[U.a] = "+=" + I), Qp.set([u, p], r)),
                        Q)
                      )
                        (r = of(Q)),
                          (x = U === af),
                          (m = me.scroll()),
                          (S = parseFloat(b(U.a)) + D),
                          !N &&
                            h > 1 &&
                            ((le ? nd : se).style["overflow-" + U.a] =
                              "scroll"),
                          Bf(Q, w, r),
                          (_ = Gf(Q)),
                          (a = cf(Q, !0)),
                          (P = he && jd(se, x ? rf : af)()),
                          K &&
                            (((A = [K + U.os2, g + D + nf]).t = w),
                            (V = K === $d ? lf(Q, U) + g + D : 0) &&
                              A.push(U.d, V + nf),
                            Uf(A),
                            he && me.scroll(F)),
                          he &&
                            (((M = {
                              top: a.top + (x ? m - l : P) + nf,
                              left: a.left + (x ? P : m - l) + nf,
                              boxSizing: "border-box",
                              position: "fixed",
                            }).width = M.maxWidth =
                              Math.ceil(a.width) + nf),
                            (M.height = M.maxHeight = Math.ceil(a.height) + nf),
                            (M.margin =
                              M.marginTop =
                              M.marginRight =
                              M.marginBottom =
                              M.marginLeft =
                                "0"),
                            (M.padding = r.padding),
                            (M.paddingTop = r.paddingTop),
                            (M.paddingRight = r.paddingRight),
                            (M.paddingBottom = r.paddingBottom),
                            (M.paddingLeft = r.paddingLeft),
                            (y = (function (e, t, n) {
                              for (
                                var i, r = [], a = e.length, o = n ? 8 : 0;
                                o < a;
                                o += 2
                              )
                                (i = e[o]), r.push(i, i in t ? t[i] : e[o + 1]);
                              return (r.t = e.t), r;
                            })(v, M, ae))),
                          n
                            ? ((R = n._initted),
                              _d(1),
                              n.progress(1, !0),
                              (T = b(U.a) - S + g + D),
                              g !== T && y.splice(y.length - 2, 2),
                              n.progress(0, !0),
                              R || n.invalidate(),
                              _d(0))
                            : (T = g);
                      else if (Z && me.scroll())
                        for (a = Z.parentNode; a && a !== nd; )
                          a._pinOffset &&
                            ((l -= a._pinOffset), (h -= a._pinOffset)),
                            (a = a.parentNode);
                      for (V = 0; V < W; V++)
                        (E = wf[V].pin) &&
                          (E === Z || E === Q) &&
                          wf[V].revert(!1);
                      (me.start = l),
                        (me.end = h),
                        (s = c = me.scroll()) < F && me.scroll(F),
                        me.revert(!1),
                        (ud = 0),
                        n &&
                          oe &&
                          n._initted &&
                          n.progress(H, !0).render(n.time(), !0, !0),
                        j !== me.progress &&
                          (O && n.totalProgress(j, !0),
                          (me.progress = j),
                          me.update()),
                        Q && K && (w._pinOffset = Math.round(me.progress * T)),
                        Y && Y(me);
                    }
                }),
                (me.getVelocity = function () {
                  return ((me.scroll() - c) / (Ld() - ld)) * 1e3 || 0;
                }),
                (me.update = function (e, t) {
                  var r,
                    a,
                    o,
                    u,
                    p,
                    f = me.scroll(),
                    m = e ? 0 : (f - l) / g,
                    v = m < 0 ? 0 : m > 1 ? 1 : m || 0,
                    x = me.progress;
                  if (
                    (t &&
                      ((c = s),
                      (s = f),
                      re && ((C = k), (k = n && !oe ? n.totalProgress() : v))),
                    ee &&
                      !v &&
                      Q &&
                      !ud &&
                      !Td &&
                      Rd &&
                      l < f + ((f - c) / (Ld() - ld)) * ee &&
                      (v = 1e-4),
                    v !== x && me.enabled)
                  ) {
                    if (
                      ((u =
                        (p =
                          (r = me.isActive = !!v && v < 1) != (!!x && x < 1)) ||
                        !!v != !!x),
                      (me.direction = v > x ? 1 : -1),
                      (me.progress = v),
                      oe ||
                        (!O || ud || Td
                          ? n && n.totalProgress(v, !!ud)
                          : ((O.vars.totalProgress = v),
                            O.invalidate().restart())),
                      Q)
                    )
                      if ((e && K && (w.style[K + U.os2] = E), he)) {
                        if (u) {
                          if (
                            ((o =
                              !e && v > x && h + 1 > f && f + 1 >= Hd(se, U)),
                            ae)
                          )
                            if (e || (!r && !o)) Xf(Q, w);
                            else {
                              var b = cf(Q, !0),
                                A = f - l;
                              Xf(
                                Q,
                                nd,
                                b.top + (U === af ? A : 0) + nf,
                                b.left + (U === af ? 0 : A) + nf
                              );
                            }
                          Uf(r || o ? y : _),
                            (T !== g && v < 1 && r) ||
                              M(S + (1 !== v || o ? 0 : T));
                        }
                      } else M(S + T * v);
                    re && !i.tween && !ud && !Td && D.restart(!0),
                      V &&
                        (p || (ie && v && (v < 1 || !xd))) &&
                        sd(V.targets).forEach(function (e) {
                          return e.classList[r || ie ? "add" : "remove"](
                            V.className
                          );
                        }),
                      W && !oe && !e && W(me),
                      u && !ud
                        ? ((a = v && !x ? 0 : 1 === v ? 1 : 1 === x ? 2 : 3),
                          oe &&
                            ((o =
                              (!p && "none" !== pe[a + 1] && pe[a + 1]) ||
                              pe[a]),
                            n &&
                              ("complete" === o || "reset" === o || o in n) &&
                              ("complete" === o
                                ? n.pause().totalProgress(1)
                                : "reset" === o
                                ? n.restart(!0).pause()
                                : n[o]()),
                            W && W(me)),
                          (!p && xd) ||
                            (X && p && X(me),
                            ue[a] && ue[a](me),
                            ie && (1 === v ? me.kill(!1, 1) : (ue[a] = 0)),
                            p || (ue[(a = 1 === v ? 1 : 3)] && ue[a](me))))
                        : oe && W && !ud && W(me);
                  }
                  P && (L(f + (d._isFlipped ? 1 : 0)), P(f));
                }),
                (me.enable = function () {
                  me.enabled ||
                    ((me.enabled = !0),
                    pf(se, "resize", Sf),
                    pf(se, "scroll", Mf),
                    ge && pf(e, "refreshInit", ge),
                    n && n.add
                      ? Qp.delayedCall(0.01, function () {
                          return l || h || me.refresh();
                        }) &&
                        (g = 0.01) &&
                        (l = h = 0)
                      : me.refresh());
                }),
                (me.disable = function (t, n) {
                  if (
                    me.enabled &&
                    (!1 !== t && me.revert(),
                    (me.enabled = me.isActive = !1),
                    n || (O && O.pause()),
                    (F = 0),
                    r && (r.uncache = 1),
                    ge && df(e, "refreshInit", ge),
                    D &&
                      (D.pause(), i.tween && i.tween.kill() && (i.tween = 0)),
                    !le)
                  ) {
                    for (var a = wf.length; a--; )
                      if (wf[a].scroller === se && wf[a] !== me) return;
                    df(se, "resize", Sf), df(se, "scroll", Mf);
                  }
                }),
                (me.kill = function (e, t) {
                  me.disable(e, t), q && delete xf[q];
                  var i = wf.indexOf(me);
                  wf.splice(i, 1),
                    i === fd && Df > 0 && fd--,
                    n &&
                      ((n.scrollTrigger = null),
                      e && n.render(-1),
                      t || n.kill()),
                    u &&
                      [u, p, d, f].forEach(function (e) {
                        return e.parentNode.removeChild(e);
                      }),
                    Q &&
                      (r && (r.uncache = 1),
                      (i = 0),
                      wf.forEach(function (e) {
                        return e.pin === Q && i++;
                      }),
                      i || (r.spacer = 0));
                }),
                me.enable();
            } else this.update = this.refresh = this.kill = Cd;
          }),
          (e.register = function (t) {
            if (
              !Kp &&
              ((Qp = t || Nd()),
              Od() &&
                window.document &&
                (($p = window),
                (ed = document),
                (td = ed.documentElement),
                (nd = ed.body)),
              Qp &&
                ((sd = Qp.utils.toArray),
                (cd = Qp.utils.clamp),
                (_d = Qp.core.suppressOverwrites || Cd),
                Qp.core.globals("ScrollTrigger", e),
                nd))
            ) {
              (ad =
                $p.requestAnimationFrame ||
                function (e) {
                  return setTimeout(e, 16);
                }),
                pf($p, "mousewheel", Mf),
                (id = [$p, ed, td, nd]),
                pf(ed, "scroll", Mf);
              var n,
                i = nd.style,
                r = i.borderTop;
              (i.borderTop = "1px solid #000"),
                (n = cf(nd)),
                (af.m = Math.round(n.top + af.sc()) || 0),
                (rf.m = Math.round(n.left + rf.sc()) || 0),
                r ? (i.borderTop = r) : i.removeProperty("border-top"),
                (hd = setInterval(bf, 200)),
                Qp.delayedCall(0.5, function () {
                  return (Td = 0);
                }),
                pf(ed, "touchcancel", Cd),
                pf(nd, "touchstart", Cd),
                uf(pf, ed, "pointerdown,touchstart,mousedown", function () {
                  return (pd = 1);
                }),
                uf(pf, ed, "pointerup,touchend,mouseup", function () {
                  return (pd = 0);
                }),
                (dd = Qp.utils.checkPrefix("transform")),
                Hf.push(dd),
                (Kp = Ld()),
                (rd = Qp.delayedCall(0.2, Nf).pause()),
                (vd = [
                  ed,
                  "visibilitychange",
                  function () {
                    var e = $p.innerWidth,
                      t = $p.innerHeight;
                    ed.hidden
                      ? ((md = e), (gd = t))
                      : (md === e && gd === t) || Sf();
                  },
                  ed,
                  "DOMContentLoaded",
                  Nf,
                  $p,
                  "load",
                  function () {
                    return Rd || Nf();
                  },
                  $p,
                  "resize",
                  Sf,
                ]),
                Bd(pf);
            }
            return Kp;
          }),
          (e.defaults = function (e) {
            for (var t in e) mf[t] = e[t];
          }),
          (e.kill = function () {
            (kd = 0),
              wf.slice(0).forEach(function (e) {
                return e.kill(1);
              });
          }),
          (e.config = function (e) {
            "limitCallbacks" in e && (xd = !!e.limitCallbacks);
            var t = e.syncInterval;
            (t && clearInterval(hd)) || ((hd = t) && setInterval(bf, t)),
              "autoRefreshEvents" in e &&
                (Bd(df) || Bd(pf, e.autoRefreshEvents || "none"),
                (wd = -1 === (e.autoRefreshEvents + "").indexOf("resize")));
          }),
          (e.scrollerProxy = function (e, t) {
            var n = sd(e)[0],
              i = Ad.indexOf(n),
              r = Id(n);
            ~i && Ad.splice(i, r ? 6 : 2),
              r ? Ed.unshift($p, t, nd, t, td, t) : Ed.unshift(n, t);
          }),
          (e.matchMedia = function (e) {
            var t, n, i, r, a;
            for (n in e)
              (i = Af.indexOf(n)),
                (r = e[n]),
                (bd = n),
                "all" === n
                  ? r()
                  : (t = $p.matchMedia(n)) &&
                    (t.matches && (a = r()),
                    ~i
                      ? ((Af[i + 1] = qd(Af[i + 1], r)),
                        (Af[i + 2] = qd(Af[i + 2], a)))
                      : ((i = Af.length),
                        Af.push(n, r, a),
                        t.addListener
                          ? t.addListener(Lf)
                          : t.addEventListener("change", Lf)),
                    (Af[i + 3] = t.matches)),
                (bd = 0);
            return Af;
          }),
          (e.clearMatchMedia = function (e) {
            e || (Af.length = 0), (e = Af.indexOf(e)) >= 0 && Af.splice(e, 4);
          }),
          e
        );
      })();
      (Jf.version = "3.6.0"),
        (Jf.saveStyles = function (e) {
          return e
            ? sd(e).forEach(function (e) {
                if (e && e.style) {
                  var t = kf.indexOf(e);
                  t >= 0 && kf.splice(t, 4),
                    kf.push(e, e.style.cssText, Qp.core.getCache(e), bd);
                }
              })
            : kf;
        }),
        (Jf.revert = function (e, t) {
          return Of(!e, t);
        }),
        (Jf.create = function (e, t) {
          return new Jf(e, t);
        }),
        (Jf.refresh = function (e) {
          return e ? Sf() : Nf(!0);
        }),
        (Jf.update = jf),
        (Jf.maxScroll = function (e, t) {
          return Hd(e, t ? rf : af);
        }),
        (Jf.getScrollFunc = function (e, t) {
          return jd(sd(e)[0], t ? rf : af);
        }),
        (Jf.getById = function (e) {
          return xf[e];
        }),
        (Jf.getAll = function () {
          return wf.slice(0);
        }),
        (Jf.isScrolling = function () {
          return !!Rd;
        }),
        (Jf.addEventListener = function (e, t) {
          var n = Tf[e] || (Tf[e] = []);
          ~n.indexOf(t) || n.push(t);
        }),
        (Jf.removeEventListener = function (e, t) {
          var n = Tf[e],
            i = n && n.indexOf(t);
          i >= 0 && n.splice(i, 1);
        }),
        (Jf.batch = function (e, t) {
          var n,
            i = [],
            r = {},
            a = t.interval || 0.016,
            o = t.batchMax || 1e9,
            s = function (e, t) {
              var n = [],
                i = [],
                r = Qp.delayedCall(a, function () {
                  t(n, i), (n = []), (i = []);
                }).pause();
              return function (e) {
                n.length || r.restart(!0),
                  n.push(e.trigger),
                  i.push(e),
                  o <= n.length && r.progress(1);
              };
            };
          for (n in t)
            r[n] =
              "on" === n.substr(0, 2) && Ud(t[n]) && "onRefreshInit" !== n
                ? s(0, t[n])
                : t[n];
          return (
            Ud(o) &&
              ((o = o()),
              pf(Jf, "refresh", function () {
                return (o = t.batchMax());
              })),
            sd(e).forEach(function (e) {
              var t = {};
              for (n in r) t[n] = r[n];
              (t.trigger = e), i.push(Jf.create(t));
            }),
            i
          );
        }),
        (Jf.sort = function (e) {
          return wf.sort(
            e ||
              function (e, t) {
                return (
                  -1e6 * (e.vars.refreshPriority || 0) +
                  e.start -
                  (t.start + -1e6 * (t.vars.refreshPriority || 0))
                );
              }
          );
        }),
        Nd() && Qp.registerPlugin(Jf);
      var Zf = {
        uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
        vertexShader: [
          "varying vec2 vUv;",
          "void main() {",
          "\tvUv = uv;",
          "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
          "}",
        ].join("\n"),
        fragmentShader: [
          "uniform float opacity;",
          "uniform sampler2D tDiffuse;",
          "varying vec2 vUv;",
          "void main() {",
          "\tvec4 texel = texture2D( tDiffuse, vUv );",
          "\tgl_FragColor = opacity * texel;",
          "}",
        ].join("\n"),
      };
      function Qf() {
        (this.enabled = !0),
          (this.needsSwap = !0),
          (this.clear = !1),
          (this.renderToScreen = !1);
      }
      Object.assign(Qf.prototype, {
        setSize: function () {},
        render: function () {
          console.error(
            "THREE.Pass: .render() must be implemented in derived pass."
          );
        },
      }),
        (Qf.FullScreenQuad = (function () {
          var e = new Es(-1, 1, 1, -1, 0, 1),
            t = new Mn(2, 2),
            n = function (e) {
              this._mesh = new rn(t, e);
            };
          return (
            Object.defineProperty(n.prototype, "material", {
              get: function () {
                return this._mesh.material;
              },
              set: function (e) {
                this._mesh.material = e;
              },
            }),
            Object.assign(n.prototype, {
              dispose: function () {
                this._mesh.geometry.dispose();
              },
              render: function (t) {
                t.render(this._mesh, e);
              },
            }),
            n
          );
        })());
      var Kf = function (e, t) {
        Qf.call(this),
          (this.textureID = void 0 !== t ? t : "tDiffuse"),
          e instanceof hn
            ? ((this.uniforms = e.uniforms), (this.material = e))
            : e &&
              ((this.uniforms = ln.clone(e.uniforms)),
              (this.material = new hn({
                defines: Object.assign({}, e.defines),
                uniforms: this.uniforms,
                vertexShader: e.vertexShader,
                fragmentShader: e.fragmentShader,
              }))),
          (this.fsQuad = new Qf.FullScreenQuad(this.material));
      };
      Kf.prototype = Object.assign(Object.create(Qf.prototype), {
        constructor: Kf,
        render: function (e, t, n) {
          this.uniforms[this.textureID] &&
            (this.uniforms[this.textureID].value = n.texture),
            (this.fsQuad.material = this.material),
            this.renderToScreen
              ? (e.setRenderTarget(null), this.fsQuad.render(e))
              : (e.setRenderTarget(t),
                this.clear &&
                  e.clear(
                    e.autoClearColor,
                    e.autoClearDepth,
                    e.autoClearStencil
                  ),
                this.fsQuad.render(e));
        },
      });
      var $f = function (e, t) {
        Qf.call(this),
          (this.scene = e),
          (this.camera = t),
          (this.clear = !0),
          (this.needsSwap = !1),
          (this.inverse = !1);
      };
      $f.prototype = Object.assign(Object.create(Qf.prototype), {
        constructor: $f,
        render: function (e, t, n) {
          var i,
            r,
            a = e.getContext(),
            o = e.state;
          o.buffers.color.setMask(!1),
            o.buffers.depth.setMask(!1),
            o.buffers.color.setLocked(!0),
            o.buffers.depth.setLocked(!0),
            this.inverse ? ((i = 0), (r = 1)) : ((i = 1), (r = 0)),
            o.buffers.stencil.setTest(!0),
            o.buffers.stencil.setOp(a.REPLACE, a.REPLACE, a.REPLACE),
            o.buffers.stencil.setFunc(a.ALWAYS, i, 4294967295),
            o.buffers.stencil.setClear(r),
            o.buffers.stencil.setLocked(!0),
            e.setRenderTarget(n),
            this.clear && e.clear(),
            e.render(this.scene, this.camera),
            e.setRenderTarget(t),
            this.clear && e.clear(),
            e.render(this.scene, this.camera),
            o.buffers.color.setLocked(!1),
            o.buffers.depth.setLocked(!1),
            o.buffers.stencil.setLocked(!1),
            o.buffers.stencil.setFunc(a.EQUAL, 1, 4294967295),
            o.buffers.stencil.setOp(a.KEEP, a.KEEP, a.KEEP),
            o.buffers.stencil.setLocked(!0);
        },
      });
      var em = function () {
        Qf.call(this), (this.needsSwap = !1);
      };
      (em.prototype = Object.create(Qf.prototype)),
        Object.assign(em.prototype, {
          render: function (e) {
            e.state.buffers.stencil.setLocked(!1),
              e.state.buffers.stencil.setTest(!1);
          },
        });
      var tm = function (e, t) {
        if (((this.renderer = e), void 0 === t)) {
          var n = { minFilter: s, magFilter: s, format: m },
            i = e.getSize(new N());
          (this._pixelRatio = e.getPixelRatio()),
            (this._width = i.width),
            (this._height = i.height),
            ((t = new U(
              this._width * this._pixelRatio,
              this._height * this._pixelRatio,
              n
            )).texture.name = "EffectComposer.rt1");
        } else
          (this._pixelRatio = 1),
            (this._width = t.width),
            (this._height = t.height);
        (this.renderTarget1 = t),
          (this.renderTarget2 = t.clone()),
          (this.renderTarget2.texture.name = "EffectComposer.rt2"),
          (this.writeBuffer = this.renderTarget1),
          (this.readBuffer = this.renderTarget2),
          (this.renderToScreen = !0),
          (this.passes = []),
          void 0 === Zf &&
            console.error("THREE.EffectComposer relies on CopyShader"),
          void 0 === Kf &&
            console.error("THREE.EffectComposer relies on ShaderPass"),
          (this.copyPass = new Kf(Zf)),
          (this.clock = new Zs());
      };
      Object.assign(tm.prototype, {
        swapBuffers: function () {
          var e = this.readBuffer;
          (this.readBuffer = this.writeBuffer), (this.writeBuffer = e);
        },
        addPass: function (e) {
          this.passes.push(e),
            e.setSize(
              this._width * this._pixelRatio,
              this._height * this._pixelRatio
            );
        },
        insertPass: function (e, t) {
          this.passes.splice(t, 0, e),
            e.setSize(
              this._width * this._pixelRatio,
              this._height * this._pixelRatio
            );
        },
        removePass: function (e) {
          const t = this.passes.indexOf(e);
          -1 !== t && this.passes.splice(t, 1);
        },
        isLastEnabledPass: function (e) {
          for (var t = e + 1; t < this.passes.length; t++)
            if (this.passes[t].enabled) return !1;
          return !0;
        },
        render: function (e) {
          void 0 === e && (e = this.clock.getDelta());
          var t,
            n,
            i = this.renderer.getRenderTarget(),
            r = !1,
            a = this.passes.length;
          for (n = 0; n < a; n++)
            if (!1 !== (t = this.passes[n]).enabled) {
              if (
                ((t.renderToScreen =
                  this.renderToScreen && this.isLastEnabledPass(n)),
                t.render(
                  this.renderer,
                  this.writeBuffer,
                  this.readBuffer,
                  e,
                  r
                ),
                t.needsSwap)
              ) {
                if (r) {
                  var o = this.renderer.getContext(),
                    s = this.renderer.state.buffers.stencil;
                  s.setFunc(o.NOTEQUAL, 1, 4294967295),
                    this.copyPass.render(
                      this.renderer,
                      this.writeBuffer,
                      this.readBuffer,
                      e
                    ),
                    s.setFunc(o.EQUAL, 1, 4294967295);
                }
                this.swapBuffers();
              }
              void 0 !== $f &&
                (t instanceof $f ? (r = !0) : t instanceof em && (r = !1));
            }
          this.renderer.setRenderTarget(i);
        },
        reset: function (e) {
          if (void 0 === e) {
            var t = this.renderer.getSize(new N());
            (this._pixelRatio = this.renderer.getPixelRatio()),
              (this._width = t.width),
              (this._height = t.height),
              (e = this.renderTarget1.clone()).setSize(
                this._width * this._pixelRatio,
                this._height * this._pixelRatio
              );
          }
          this.renderTarget1.dispose(),
            this.renderTarget2.dispose(),
            (this.renderTarget1 = e),
            (this.renderTarget2 = e.clone()),
            (this.writeBuffer = this.renderTarget1),
            (this.readBuffer = this.renderTarget2);
        },
        setSize: function (e, t) {
          (this._width = e), (this._height = t);
          var n = this._width * this._pixelRatio,
            i = this._height * this._pixelRatio;
          this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
          for (var r = 0; r < this.passes.length; r++)
            this.passes[r].setSize(n, i);
        },
        setPixelRatio: function (e) {
          (this._pixelRatio = e), this.setSize(this._width, this._height);
        },
      });
      var nm = function () {
        (this.enabled = !0),
          (this.needsSwap = !0),
          (this.clear = !1),
          (this.renderToScreen = !1);
      };
      Object.assign(nm.prototype, {
        setSize: function () {},
        render: function () {
          console.error(
            "THREE.Pass: .render() must be implemented in derived pass."
          );
        },
      }),
        (nm.FullScreenQuad = (function () {
          var e = new Es(-1, 1, 1, -1, 0, 1),
            t = new Mn(2, 2),
            n = function (e) {
              this._mesh = new rn(t, e);
            };
          return (
            Object.defineProperty(n.prototype, "material", {
              get: function () {
                return this._mesh.material;
              },
              set: function (e) {
                this._mesh.material = e;
              },
            }),
            Object.assign(n.prototype, {
              dispose: function () {
                this._mesh.geometry.dispose();
              },
              render: function (t) {
                t.render(this._mesh, e);
              },
            }),
            n
          );
        })());
      var im = function (e, t, n, i, r) {
        Qf.call(this),
          (this.scene = e),
          (this.camera = t),
          (this.overrideMaterial = n),
          (this.clearColor = i),
          (this.clearAlpha = void 0 !== r ? r : 0),
          (this.clear = !0),
          (this.clearDepth = !1),
          (this.needsSwap = !1),
          (this._oldClearColor = new ut());
      };
      function rm(e, t) {
        if (!(e instanceof t))
          throw new TypeError("Cannot call a class as a function");
      }
      function am(e, t) {
        for (var n = 0; n < t.length; n++) {
          var i = t[n];
          (i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            "value" in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i);
        }
      }
      function om(e, t, n) {
        return t && am(e.prototype, t), n && am(e, n), e;
      }
      function sm(e, t, n) {
        return (
          t in e
            ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[t] = n),
          e
        );
      }
      function cm(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var i = Object.getOwnPropertySymbols(e);
          t &&
            (i = i.filter(function (t) {
              return Object.getOwnPropertyDescriptor(e, t).enumerable;
            })),
            n.push.apply(n, i);
        }
        return n;
      }
      function lm(e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = null != arguments[t] ? arguments[t] : {};
          t % 2
            ? cm(Object(n), !0).forEach(function (t) {
                sm(e, t, n[t]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : cm(Object(n)).forEach(function (t) {
                Object.defineProperty(
                  e,
                  t,
                  Object.getOwnPropertyDescriptor(n, t)
                );
              });
        }
        return e;
      }
      function hm(e, t) {
        if ("function" != typeof t && null !== t)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (e.prototype = Object.create(t && t.prototype, {
          constructor: { value: e, writable: !0, configurable: !0 },
        })),
          t && pm(e, t);
      }
      function um(e) {
        return (um = Object.setPrototypeOf
          ? Object.getPrototypeOf
          : function (e) {
              return e.__proto__ || Object.getPrototypeOf(e);
            })(e);
      }
      function pm(e, t) {
        return (pm =
          Object.setPrototypeOf ||
          function (e, t) {
            return (e.__proto__ = t), e;
          })(e, t);
      }
      function dm(e) {
        if (void 0 === e)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return e;
      }
      function fm(e, t) {
        return !t || ("object" != typeof t && "function" != typeof t)
          ? dm(e)
          : t;
      }
      function mm(e) {
        var t = (function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
            return (
              Date.prototype.toString.call(
                Reflect.construct(Date, [], function () {})
              ),
              !0
            );
          } catch (e) {
            return !1;
          }
        })();
        return function () {
          var n,
            i = um(e);
          if (t) {
            var r = um(this).constructor;
            n = Reflect.construct(i, arguments, r);
          } else n = i.apply(this, arguments);
          return fm(this, n);
        };
      }
      function gm(e, t, n) {
        return (gm =
          "undefined" != typeof Reflect && Reflect.get
            ? Reflect.get
            : function (e, t, n) {
                var i = (function (e, t) {
                  for (
                    ;
                    !Object.prototype.hasOwnProperty.call(e, t) &&
                    null !== (e = um(e));

                  );
                  return e;
                })(e, t);
                if (i) {
                  var r = Object.getOwnPropertyDescriptor(i, t);
                  return r.get ? r.get.call(n) : r.value;
                }
              })(e, t, n || e);
      }
      function vm(e, t) {
        return (
          (function (e) {
            if (Array.isArray(e)) return e;
          })(e) ||
          (function (e, t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) {
              var n = [],
                i = !0,
                r = !1,
                a = void 0;
              try {
                for (
                  var o, s = e[Symbol.iterator]();
                  !(i = (o = s.next()).done) &&
                  (n.push(o.value), !t || n.length !== t);
                  i = !0
                );
              } catch (e) {
                (r = !0), (a = e);
              } finally {
                try {
                  i || null == s.return || s.return();
                } finally {
                  if (r) throw a;
                }
              }
              return n;
            }
          })(e, t) ||
          _m(e, t) ||
          (function () {
            throw new TypeError(
              "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          })()
        );
      }
      function ym(e) {
        return (
          (function (e) {
            if (Array.isArray(e)) return wm(e);
          })(e) ||
          (function (e) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e))
              return Array.from(e);
          })(e) ||
          _m(e) ||
          (function () {
            throw new TypeError(
              "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          })()
        );
      }
      function _m(e, t) {
        if (e) {
          if ("string" == typeof e) return wm(e, t);
          var n = Object.prototype.toString.call(e).slice(8, -1);
          return (
            "Object" === n && e.constructor && (n = e.constructor.name),
            "Map" === n || "Set" === n
              ? Array.from(e)
              : "Arguments" === n ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              ? wm(e, t)
              : void 0
          );
        }
      }
      function wm(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];
        return i;
      }
      im.prototype = Object.assign(Object.create(Qf.prototype), {
        constructor: im,
        render: function (e, t, n) {
          var i,
            r,
            a = e.autoClear;
          (e.autoClear = !1),
            void 0 !== this.overrideMaterial &&
              ((r = this.scene.overrideMaterial),
              (this.scene.overrideMaterial = this.overrideMaterial)),
            this.clearColor &&
              (e.getClearColor(this._oldClearColor),
              (i = e.getClearAlpha()),
              e.setClearColor(this.clearColor, this.clearAlpha)),
            this.clearDepth && e.clearDepth(),
            e.setRenderTarget(this.renderToScreen ? null : n),
            this.clear &&
              e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
            e.render(this.scene, this.camera),
            this.clearColor && e.setClearColor(this._oldClearColor, i),
            void 0 !== this.overrideMaterial &&
              (this.scene.overrideMaterial = r),
            (e.autoClear = a);
        },
      });
      var xm = {
          el: document,
          name: "scroll",
          offset: [0, 0],
          repeat: !1,
          smooth: !1,
          direction: "vertical",
          gestureDirection: "vertical",
          reloadOnContextChange: !1,
          lerp: 0.1,
          class: "is-inview",
          scrollbarContainer: !1,
          scrollbarClass: "c-scrollbar",
          scrollingClass: "has-scroll-scrolling",
          draggingClass: "has-scroll-dragging",
          smoothClass: "has-scroll-smooth",
          initClass: "has-scroll-init",
          getSpeed: !1,
          getDirection: !1,
          scrollFromAnywhere: !1,
          multiplier: 1,
          firefoxMultiplier: 50,
          touchMultiplier: 2,
          resetNativeScroll: !0,
          tablet: {
            smooth: !1,
            direction: "vertical",
            gestureDirection: "vertical",
            breakpoint: 1024,
          },
          smartphone: {
            smooth: !1,
            direction: "vertical",
            gestureDirection: "vertical",
          },
        },
        bm = (function () {
          function e() {
            var t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
            rm(this, e),
              Object.assign(this, xm, t),
              (this.smartphone = xm.smartphone),
              t.smartphone && Object.assign(this.smartphone, t.smartphone),
              (this.tablet = xm.tablet),
              t.tablet && Object.assign(this.tablet, t.tablet),
              (this.namespace = "locomotive"),
              (this.html = document.documentElement),
              (this.windowHeight = window.innerHeight),
              (this.windowWidth = window.innerWidth),
              (this.windowMiddle = {
                x: this.windowWidth / 2,
                y: this.windowHeight / 2,
              }),
              (this.els = {}),
              (this.currentElements = {}),
              (this.listeners = {}),
              (this.hasScrollTicking = !1),
              (this.hasCallEventSet = !1),
              (this.checkScroll = this.checkScroll.bind(this)),
              (this.checkResize = this.checkResize.bind(this)),
              (this.checkEvent = this.checkEvent.bind(this)),
              (this.instance = {
                scroll: { x: 0, y: 0 },
                limit: { x: this.html.offsetHeight, y: this.html.offsetHeight },
                currentElements: this.currentElements,
              }),
              this.isMobile
                ? this.isTablet
                  ? (this.context = "tablet")
                  : (this.context = "smartphone")
                : (this.context = "desktop"),
              this.isMobile && (this.direction = this[this.context].direction),
              "horizontal" === this.direction
                ? (this.directionAxis = "x")
                : (this.directionAxis = "y"),
              this.getDirection && (this.instance.direction = null),
              this.getDirection && (this.instance.speed = 0),
              this.html.classList.add(this.initClass),
              window.addEventListener("resize", this.checkResize, !1);
          }
          return (
            om(e, [
              {
                key: "init",
                value: function () {
                  this.initEvents();
                },
              },
              {
                key: "checkScroll",
                value: function () {
                  this.dispatchScroll();
                },
              },
              {
                key: "checkResize",
                value: function () {
                  var e = this;
                  this.resizeTick ||
                    ((this.resizeTick = !0),
                    requestAnimationFrame(function () {
                      e.resize(), (e.resizeTick = !1);
                    }));
                },
              },
              { key: "resize", value: function () {} },
              {
                key: "checkContext",
                value: function () {
                  if (this.reloadOnContextChange) {
                    (this.isMobile =
                      /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                        navigator.userAgent
                      ) ||
                      ("MacIntel" === navigator.platform &&
                        navigator.maxTouchPoints > 1) ||
                      this.windowWidth < this.tablet.breakpoint),
                      (this.isTablet =
                        this.isMobile &&
                        this.windowWidth >= this.tablet.breakpoint);
                    var e = this.context;
                    this.isMobile
                      ? this.isTablet
                        ? (this.context = "tablet")
                        : (this.context = "smartphone")
                      : (this.context = "desktop"),
                      e != this.context &&
                        ("desktop" == e ? this.smooth : this[e].smooth) !=
                          ("desktop" == this.context
                            ? this.smooth
                            : this[this.context].smooth) &&
                        window.location.reload();
                  }
                },
              },
              {
                key: "initEvents",
                value: function () {
                  var e = this;
                  (this.scrollToEls = this.el.querySelectorAll(
                    "[data-".concat(this.name, "-to]")
                  )),
                    (this.setScrollTo = this.setScrollTo.bind(this)),
                    this.scrollToEls.forEach(function (t) {
                      t.addEventListener("click", e.setScrollTo, !1);
                    });
                },
              },
              {
                key: "setScrollTo",
                value: function (e) {
                  e.preventDefault(),
                    this.scrollTo(
                      e.currentTarget.getAttribute(
                        "data-".concat(this.name, "-href")
                      ) || e.currentTarget.getAttribute("href"),
                      {
                        offset: e.currentTarget.getAttribute(
                          "data-".concat(this.name, "-offset")
                        ),
                      }
                    );
                },
              },
              { key: "addElements", value: function () {} },
              {
                key: "detectElements",
                value: function (e) {
                  var t = this,
                    n = this.instance.scroll.y,
                    i = n + this.windowHeight,
                    r = this.instance.scroll.x,
                    a = r + this.windowWidth;
                  Object.entries(this.els).forEach(function (o) {
                    var s = vm(o, 2),
                      c = s[0],
                      l = s[1];
                    if (
                      (!l ||
                        (l.inView && !e) ||
                        ("horizontal" === t.direction
                          ? a >= l.left && r < l.right && t.setInView(l, c)
                          : i >= l.top && n < l.bottom && t.setInView(l, c)),
                      l && l.inView)
                    )
                      if ("horizontal" === t.direction) {
                        var h = l.right - l.left;
                        (l.progress =
                          (t.instance.scroll.x - (l.left - t.windowWidth)) /
                          (h + t.windowWidth)),
                          (a < l.left || r > l.right) && t.setOutOfView(l, c);
                      } else {
                        var u = l.bottom - l.top;
                        (l.progress =
                          (t.instance.scroll.y - (l.top - t.windowHeight)) /
                          (u + t.windowHeight)),
                          (i < l.top || n > l.bottom) && t.setOutOfView(l, c);
                      }
                  }),
                    (this.hasScrollTicking = !1);
                },
              },
              {
                key: "setInView",
                value: function (e, t) {
                  (this.els[t].inView = !0),
                    e.el.classList.add(e.class),
                    (this.currentElements[t] = e),
                    e.call &&
                      this.hasCallEventSet &&
                      (this.dispatchCall(e, "enter"),
                      e.repeat || (this.els[t].call = !1));
                },
              },
              {
                key: "setOutOfView",
                value: function (e, t) {
                  var n = this;
                  (this.els[t].inView = !1),
                    Object.keys(this.currentElements).forEach(function (e) {
                      e === t && delete n.currentElements[e];
                    }),
                    e.call &&
                      this.hasCallEventSet &&
                      this.dispatchCall(e, "exit"),
                    e.repeat && e.el.classList.remove(e.class);
                },
              },
              {
                key: "dispatchCall",
                value: function (e, t) {
                  (this.callWay = t),
                    (this.callValue = e.call.split(",").map(function (e) {
                      return e.trim();
                    })),
                    (this.callObj = e),
                    1 == this.callValue.length &&
                      (this.callValue = this.callValue[0]);
                  var n = new Event(this.namespace + "call");
                  this.el.dispatchEvent(n);
                },
              },
              {
                key: "dispatchScroll",
                value: function () {
                  var e = new Event(this.namespace + "scroll");
                  this.el.dispatchEvent(e);
                },
              },
              {
                key: "setEvents",
                value: function (e, t) {
                  this.listeners[e] || (this.listeners[e] = []);
                  var n = this.listeners[e];
                  n.push(t),
                    1 === n.length &&
                      this.el.addEventListener(
                        this.namespace + e,
                        this.checkEvent,
                        !1
                      ),
                    "call" === e &&
                      ((this.hasCallEventSet = !0), this.detectElements(!0));
                },
              },
              {
                key: "unsetEvents",
                value: function (e, t) {
                  if (this.listeners[e]) {
                    var n = this.listeners[e],
                      i = n.indexOf(t);
                    i < 0 ||
                      (n.splice(i, 1),
                      0 === n.index &&
                        this.el.removeEventListener(
                          this.namespace + e,
                          this.checkEvent,
                          !1
                        ));
                  }
                },
              },
              {
                key: "checkEvent",
                value: function (e) {
                  var t = this,
                    n = e.type.replace(this.namespace, ""),
                    i = this.listeners[n];
                  i &&
                    0 !== i.length &&
                    i.forEach(function (e) {
                      switch (n) {
                        case "scroll":
                          return e(t.instance);
                        case "call":
                          return e(t.callValue, t.callWay, t.callObj);
                        default:
                          return e();
                      }
                    });
                },
              },
              { key: "startScroll", value: function () {} },
              { key: "stopScroll", value: function () {} },
              {
                key: "setScroll",
                value: function (e, t) {
                  this.instance.scroll = { x: 0, y: 0 };
                },
              },
              {
                key: "destroy",
                value: function () {
                  var e = this;
                  window.removeEventListener("resize", this.checkResize, !1),
                    Object.keys(this.listeners).forEach(function (t) {
                      e.el.removeEventListener(
                        e.namespace + t,
                        e.checkEvent,
                        !1
                      );
                    }),
                    (this.listeners = {}),
                    this.scrollToEls.forEach(function (t) {
                      t.removeEventListener("click", e.setScrollTo, !1);
                    }),
                    this.html.classList.remove(this.initClass);
                },
              },
            ]),
            e
          );
        })(),
        Mm =
          "undefined" != typeof globalThis
            ? globalThis
            : "undefined" != typeof window
            ? window
            : void 0 !== __webpack_require__.g
            ? __webpack_require__.g
            : "undefined" != typeof self
            ? self
            : {};
      function Sm(e, t) {
        return e((t = { exports: {} }), t.exports), t.exports;
      }
      var Tm = Sm(function (e, t) {
          e.exports = {
            polyfill: function () {
              var e = window,
                t = document;
              if (
                !("scrollBehavior" in t.documentElement.style) ||
                !0 === e.__forceSmoothScrollPolyfill__
              ) {
                var n,
                  i = e.HTMLElement || e.Element,
                  r = {
                    scroll: e.scroll || e.scrollTo,
                    scrollBy: e.scrollBy,
                    elementScroll: i.prototype.scroll || s,
                    scrollIntoView: i.prototype.scrollIntoView,
                  },
                  a =
                    e.performance && e.performance.now
                      ? e.performance.now.bind(e.performance)
                      : Date.now,
                  o =
                    ((n = e.navigator.userAgent),
                    new RegExp(["MSIE ", "Trident/", "Edge/"].join("|")).test(n)
                      ? 1
                      : 0);
                (e.scroll = e.scrollTo =
                  function () {
                    void 0 !== arguments[0] &&
                      (!0 !== c(arguments[0])
                        ? f.call(
                            e,
                            t.body,
                            void 0 !== arguments[0].left
                              ? ~~arguments[0].left
                              : e.scrollX || e.pageXOffset,
                            void 0 !== arguments[0].top
                              ? ~~arguments[0].top
                              : e.scrollY || e.pageYOffset
                          )
                        : r.scroll.call(
                            e,
                            void 0 !== arguments[0].left
                              ? arguments[0].left
                              : "object" != typeof arguments[0]
                              ? arguments[0]
                              : e.scrollX || e.pageXOffset,
                            void 0 !== arguments[0].top
                              ? arguments[0].top
                              : void 0 !== arguments[1]
                              ? arguments[1]
                              : e.scrollY || e.pageYOffset
                          ));
                  }),
                  (e.scrollBy = function () {
                    void 0 !== arguments[0] &&
                      (c(arguments[0])
                        ? r.scrollBy.call(
                            e,
                            void 0 !== arguments[0].left
                              ? arguments[0].left
                              : "object" != typeof arguments[0]
                              ? arguments[0]
                              : 0,
                            void 0 !== arguments[0].top
                              ? arguments[0].top
                              : void 0 !== arguments[1]
                              ? arguments[1]
                              : 0
                          )
                        : f.call(
                            e,
                            t.body,
                            ~~arguments[0].left + (e.scrollX || e.pageXOffset),
                            ~~arguments[0].top + (e.scrollY || e.pageYOffset)
                          ));
                  }),
                  (i.prototype.scroll = i.prototype.scrollTo =
                    function () {
                      if (void 0 !== arguments[0])
                        if (!0 !== c(arguments[0])) {
                          var e = arguments[0].left,
                            t = arguments[0].top;
                          f.call(
                            this,
                            this,
                            void 0 === e ? this.scrollLeft : ~~e,
                            void 0 === t ? this.scrollTop : ~~t
                          );
                        } else {
                          if (
                            "number" == typeof arguments[0] &&
                            void 0 === arguments[1]
                          )
                            throw new SyntaxError(
                              "Value could not be converted"
                            );
                          r.elementScroll.call(
                            this,
                            void 0 !== arguments[0].left
                              ? ~~arguments[0].left
                              : "object" != typeof arguments[0]
                              ? ~~arguments[0]
                              : this.scrollLeft,
                            void 0 !== arguments[0].top
                              ? ~~arguments[0].top
                              : void 0 !== arguments[1]
                              ? ~~arguments[1]
                              : this.scrollTop
                          );
                        }
                    }),
                  (i.prototype.scrollBy = function () {
                    void 0 !== arguments[0] &&
                      (!0 !== c(arguments[0])
                        ? this.scroll({
                            left: ~~arguments[0].left + this.scrollLeft,
                            top: ~~arguments[0].top + this.scrollTop,
                            behavior: arguments[0].behavior,
                          })
                        : r.elementScroll.call(
                            this,
                            void 0 !== arguments[0].left
                              ? ~~arguments[0].left + this.scrollLeft
                              : ~~arguments[0] + this.scrollLeft,
                            void 0 !== arguments[0].top
                              ? ~~arguments[0].top + this.scrollTop
                              : ~~arguments[1] + this.scrollTop
                          ));
                  }),
                  (i.prototype.scrollIntoView = function () {
                    if (!0 !== c(arguments[0])) {
                      var n = p(this),
                        i = n.getBoundingClientRect(),
                        a = this.getBoundingClientRect();
                      n !== t.body
                        ? (f.call(
                            this,
                            n,
                            n.scrollLeft + a.left - i.left,
                            n.scrollTop + a.top - i.top
                          ),
                          "fixed" !== e.getComputedStyle(n).position &&
                            e.scrollBy({
                              left: i.left,
                              top: i.top,
                              behavior: "smooth",
                            }))
                        : e.scrollBy({
                            left: a.left,
                            top: a.top,
                            behavior: "smooth",
                          });
                    } else
                      r.scrollIntoView.call(
                        this,
                        void 0 === arguments[0] || arguments[0]
                      );
                  });
              }
              function s(e, t) {
                (this.scrollLeft = e), (this.scrollTop = t);
              }
              function c(e) {
                if (
                  null === e ||
                  "object" != typeof e ||
                  void 0 === e.behavior ||
                  "auto" === e.behavior ||
                  "instant" === e.behavior
                )
                  return !0;
                if ("object" == typeof e && "smooth" === e.behavior) return !1;
                throw new TypeError(
                  "behavior member of ScrollOptions " +
                    e.behavior +
                    " is not a valid value for enumeration ScrollBehavior."
                );
              }
              function l(e, t) {
                return "Y" === t
                  ? e.clientHeight + o < e.scrollHeight
                  : "X" === t
                  ? e.clientWidth + o < e.scrollWidth
                  : void 0;
              }
              function h(t, n) {
                var i = e.getComputedStyle(t, null)["overflow" + n];
                return "auto" === i || "scroll" === i;
              }
              function u(e) {
                var t = l(e, "Y") && h(e, "Y"),
                  n = l(e, "X") && h(e, "X");
                return t || n;
              }
              function p(e) {
                for (; e !== t.body && !1 === u(e); )
                  e = e.parentNode || e.host;
                return e;
              }
              function d(t) {
                var n,
                  i,
                  r,
                  o,
                  s = (a() - t.startTime) / 468;
                (o = s = s > 1 ? 1 : s),
                  (n = 0.5 * (1 - Math.cos(Math.PI * o))),
                  (i = t.startX + (t.x - t.startX) * n),
                  (r = t.startY + (t.y - t.startY) * n),
                  t.method.call(t.scrollable, i, r),
                  (i === t.x && r === t.y) ||
                    e.requestAnimationFrame(d.bind(e, t));
              }
              function f(n, i, o) {
                var c,
                  l,
                  h,
                  u,
                  p = a();
                n === t.body
                  ? ((c = e),
                    (l = e.scrollX || e.pageXOffset),
                    (h = e.scrollY || e.pageYOffset),
                    (u = r.scroll))
                  : ((c = n), (l = n.scrollLeft), (h = n.scrollTop), (u = s)),
                  d({
                    scrollable: c,
                    method: u,
                    startTime: p,
                    startX: l,
                    startY: h,
                    x: i,
                    y: o,
                  });
              }
            },
          };
        }),
        Em =
          (Tm.polyfill,
          (function (e) {
            hm(n, e);
            var t = mm(n);
            function n() {
              var e,
                i =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : {};
              return (
                rm(this, n),
                (e = t.call(this, i)).resetNativeScroll &&
                  (history.scrollRestoration &&
                    (history.scrollRestoration = "manual"),
                  window.scrollTo(0, 0)),
                window.addEventListener("scroll", e.checkScroll, !1),
                void 0 === window.smoothscrollPolyfill &&
                  ((window.smoothscrollPolyfill = Tm),
                  window.smoothscrollPolyfill.polyfill()),
                e
              );
            }
            return (
              om(n, [
                {
                  key: "init",
                  value: function () {
                    (this.instance.scroll.y = window.pageYOffset),
                      this.addElements(),
                      this.detectElements(),
                      gm(um(n.prototype), "init", this).call(this);
                  },
                },
                {
                  key: "checkScroll",
                  value: function () {
                    var e = this;
                    gm(um(n.prototype), "checkScroll", this).call(this),
                      this.getDirection && this.addDirection(),
                      this.getSpeed &&
                        (this.addSpeed(), (this.speedTs = Date.now())),
                      (this.instance.scroll.y = window.pageYOffset),
                      Object.entries(this.els).length &&
                        (this.hasScrollTicking ||
                          (requestAnimationFrame(function () {
                            e.detectElements();
                          }),
                          (this.hasScrollTicking = !0)));
                  },
                },
                {
                  key: "addDirection",
                  value: function () {
                    window.pageYOffset > this.instance.scroll.y
                      ? "down" !== this.instance.direction &&
                        (this.instance.direction = "down")
                      : window.pageYOffset < this.instance.scroll.y &&
                        "up" !== this.instance.direction &&
                        (this.instance.direction = "up");
                  },
                },
                {
                  key: "addSpeed",
                  value: function () {
                    window.pageYOffset != this.instance.scroll.y
                      ? (this.instance.speed =
                          (window.pageYOffset - this.instance.scroll.y) /
                          Math.max(1, Date.now() - this.speedTs))
                      : (this.instance.speed = 0);
                  },
                },
                {
                  key: "resize",
                  value: function () {
                    Object.entries(this.els).length &&
                      ((this.windowHeight = window.innerHeight),
                      this.updateElements());
                  },
                },
                {
                  key: "addElements",
                  value: function () {
                    var e = this;
                    (this.els = {}),
                      this.el
                        .querySelectorAll("[data-" + this.name + "]")
                        .forEach(function (t, n) {
                          t.getBoundingClientRect();
                          var i,
                            r,
                            a,
                            o = t.dataset[e.name + "Class"] || e.class,
                            s =
                              "string" == typeof t.dataset[e.name + "Id"]
                                ? t.dataset[e.name + "Id"]
                                : n,
                            c =
                              "string" == typeof t.dataset[e.name + "Offset"]
                                ? t.dataset[e.name + "Offset"].split(",")
                                : e.offset,
                            l = t.dataset[e.name + "Repeat"],
                            h = t.dataset[e.name + "Call"],
                            u = t.dataset[e.name + "Target"],
                            p = (a =
                              void 0 !== u
                                ? document.querySelector("".concat(u))
                                : t).getBoundingClientRect();
                          (i = p.top + e.instance.scroll.y),
                            (r = p.left + e.instance.scroll.x);
                          var d = i + a.offsetHeight,
                            f = r + a.offsetWidth;
                          "#header" === u && console.log(i, d),
                            (l = "false" != l && (null != l || e.repeat));
                          var m = e.getRelativeOffset(c),
                            g = {
                              el: t,
                              targetEl: a,
                              id: s,
                              class: o,
                              top: (i += m[0]),
                              bottom: (d -= m[1]),
                              left: r,
                              right: f,
                              offset: c,
                              progress: 0,
                              repeat: l,
                              inView: !1,
                              call: h,
                            };
                          (e.els[s] = g),
                            t.classList.contains(o) && e.setInView(e.els[s], s);
                        });
                  },
                },
                {
                  key: "updateElements",
                  value: function () {
                    var e = this;
                    Object.entries(this.els).forEach(function (t) {
                      var n = vm(t, 2),
                        i = n[0],
                        r = n[1],
                        a =
                          r.targetEl.getBoundingClientRect().top +
                          e.instance.scroll.y,
                        o = a + r.targetEl.offsetHeight,
                        s = e.getRelativeOffset(r.offset);
                      (e.els[i].top = a + s[0]), (e.els[i].bottom = o - s[1]);
                    }),
                      (this.hasScrollTicking = !1);
                  },
                },
                {
                  key: "getRelativeOffset",
                  value: function (e) {
                    var t = [0, 0];
                    if (e)
                      for (var n = 0; n < e.length; n++)
                        "string" == typeof e[n]
                          ? e[n].includes("%")
                            ? (t[n] = parseInt(
                                (e[n].replace("%", "") * this.windowHeight) /
                                  100
                              ))
                            : (t[n] = parseInt(e[n]))
                          : (t[n] = e[n]);
                    return t;
                  },
                },
                {
                  key: "scrollTo",
                  value: function (e) {
                    var t =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : {},
                      n = parseInt(t.offset) || 0,
                      i = !!t.callback && t.callback;
                    if ("string" == typeof e) {
                      if ("top" === e) e = this.html;
                      else if ("bottom" === e)
                        e = this.html.offsetHeight - window.innerHeight;
                      else if (!(e = document.querySelector(e))) return;
                    } else if ("number" == typeof e) e = parseInt(e);
                    else if (!e || !e.tagName)
                      return void console.warn(
                        "`target` parameter is not valid"
                      );
                    if (
                      ((n =
                        "number" != typeof e
                          ? e.getBoundingClientRect().top +
                            n +
                            this.instance.scroll.y
                          : e + n),
                      i)
                    ) {
                      n = n.toFixed();
                      var r = function e() {
                        window.pageYOffset.toFixed() === n &&
                          (window.removeEventListener("scroll", e), i());
                      };
                      window.addEventListener("scroll", r);
                    }
                    window.scrollTo({ top: n, behavior: "smooth" });
                  },
                },
                {
                  key: "update",
                  value: function () {
                    this.addElements(), this.detectElements();
                  },
                },
                {
                  key: "destroy",
                  value: function () {
                    gm(um(n.prototype), "destroy", this).call(this),
                      window.removeEventListener(
                        "scroll",
                        this.checkScroll,
                        !1
                      );
                  },
                },
              ]),
              n
            );
          })(bm)),
        Am = Object.getOwnPropertySymbols,
        Lm = Object.prototype.hasOwnProperty,
        Pm = Object.prototype.propertyIsEnumerable;
      function Rm(e) {
        if (null == e)
          throw new TypeError(
            "Object.assign cannot be called with null or undefined"
          );
        return Object(e);
      }
      var km = (function () {
        try {
          if (!Object.assign) return !1;
          var e = new String("abc");
          if (((e[5] = "de"), "5" === Object.getOwnPropertyNames(e)[0]))
            return !1;
          for (var t = {}, n = 0; n < 10; n++)
            t["_" + String.fromCharCode(n)] = n;
          if (
            "0123456789" !==
            Object.getOwnPropertyNames(t)
              .map(function (e) {
                return t[e];
              })
              .join("")
          )
            return !1;
          var i = {};
          return (
            "abcdefghijklmnopqrst".split("").forEach(function (e) {
              i[e] = e;
            }),
            "abcdefghijklmnopqrst" ===
              Object.keys(Object.assign({}, i)).join("")
          );
        } catch (e) {
          return !1;
        }
      })()
        ? Object.assign
        : function (e, t) {
            for (var n, i, r = Rm(e), a = 1; a < arguments.length; a++) {
              for (var o in (n = Object(arguments[a])))
                Lm.call(n, o) && (r[o] = n[o]);
              if (Am) {
                i = Am(n);
                for (var s = 0; s < i.length; s++)
                  Pm.call(n, i[s]) && (r[i[s]] = n[i[s]]);
              }
            }
            return r;
          };
      function Cm() {}
      Cm.prototype = {
        on: function (e, t, n) {
          var i = this.e || (this.e = {});
          return (i[e] || (i[e] = [])).push({ fn: t, ctx: n }), this;
        },
        once: function (e, t, n) {
          var i = this;
          function r() {
            i.off(e, r), t.apply(n, arguments);
          }
          return (r._ = t), this.on(e, r, n);
        },
        emit: function (e) {
          for (
            var t = [].slice.call(arguments, 1),
              n = ((this.e || (this.e = {}))[e] || []).slice(),
              i = 0,
              r = n.length;
            i < r;
            i++
          )
            n[i].fn.apply(n[i].ctx, t);
          return this;
        },
        off: function (e, t) {
          var n = this.e || (this.e = {}),
            i = n[e],
            r = [];
          if (i && t)
            for (var a = 0, o = i.length; a < o; a++)
              i[a].fn !== t && i[a].fn._ !== t && r.push(i[a]);
          return r.length ? (n[e] = r) : delete n[e], this;
        },
      };
      var Om = Cm,
        Nm = Sm(function (e, t) {
          (function () {
            (null !== t ? t : this).Lethargy = (function () {
              function e(e, t, n, i) {
                (this.stability = null != e ? Math.abs(e) : 8),
                  (this.sensitivity = null != t ? 1 + Math.abs(t) : 100),
                  (this.tolerance = null != n ? 1 + Math.abs(n) : 1.1),
                  (this.delay = null != i ? i : 150),
                  (this.lastUpDeltas = function () {
                    var e, t, n;
                    for (
                      n = [], e = 1, t = 2 * this.stability;
                      1 <= t ? e <= t : e >= t;
                      1 <= t ? e++ : e--
                    )
                      n.push(null);
                    return n;
                  }.call(this)),
                  (this.lastDownDeltas = function () {
                    var e, t, n;
                    for (
                      n = [], e = 1, t = 2 * this.stability;
                      1 <= t ? e <= t : e >= t;
                      1 <= t ? e++ : e--
                    )
                      n.push(null);
                    return n;
                  }.call(this)),
                  (this.deltasTimestamp = function () {
                    var e, t, n;
                    for (
                      n = [], e = 1, t = 2 * this.stability;
                      1 <= t ? e <= t : e >= t;
                      1 <= t ? e++ : e--
                    )
                      n.push(null);
                    return n;
                  }.call(this));
              }
              return (
                (e.prototype.check = function (e) {
                  var t;
                  return (
                    null != (e = e.originalEvent || e).wheelDelta
                      ? (t = e.wheelDelta)
                      : null != e.deltaY
                      ? (t = -40 * e.deltaY)
                      : (null == e.detail && 0 !== e.detail) ||
                        (t = -40 * e.detail),
                    this.deltasTimestamp.push(Date.now()),
                    this.deltasTimestamp.shift(),
                    t > 0
                      ? (this.lastUpDeltas.push(t),
                        this.lastUpDeltas.shift(),
                        this.isInertia(1))
                      : (this.lastDownDeltas.push(t),
                        this.lastDownDeltas.shift(),
                        this.isInertia(-1))
                  );
                }),
                (e.prototype.isInertia = function (e) {
                  var t, n, i, r, a, o, s;
                  return null ===
                    (t = -1 === e ? this.lastDownDeltas : this.lastUpDeltas)[0]
                    ? e
                    : !(
                        this.deltasTimestamp[2 * this.stability - 2] +
                          this.delay >
                          Date.now() && t[0] === t[2 * this.stability - 1]
                      ) &&
                        ((i = t.slice(0, this.stability)),
                        (n = t.slice(this.stability, 2 * this.stability)),
                        (s = i.reduce(function (e, t) {
                          return e + t;
                        })),
                        (a = n.reduce(function (e, t) {
                          return e + t;
                        })),
                        (o = s / i.length),
                        (r = a / n.length),
                        Math.abs(o) < Math.abs(r * this.tolerance) &&
                          this.sensitivity < Math.abs(r) &&
                          e);
                }),
                (e.prototype.showLastUpDeltas = function () {
                  return this.lastUpDeltas;
                }),
                (e.prototype.showLastDownDeltas = function () {
                  return this.lastDownDeltas;
                }),
                e
              );
            })();
          }.call(Mm));
        }),
        Im = "onwheel" in document,
        Dm = "onmousewheel" in document,
        jm =
          "ontouchstart" in window ||
          window.TouchEvent ||
          (window.DocumentTouch && document instanceof DocumentTouch),
        Fm = navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
        Hm = !!window.navigator.msPointerEnabled,
        Bm = "onkeydown" in document,
        zm = navigator.userAgent.indexOf("Firefox") > -1,
        Um = Object.prototype.toString,
        Gm = Object.prototype.hasOwnProperty;
      function Wm(e, t) {
        return function () {
          return e.apply(t, arguments);
        };
      }
      var Vm = Nm.Lethargy,
        qm = "virtualscroll",
        Xm = Ym;
      function Ym(e) {
        !(function (e) {
          if (!e)
            return console.warn("bindAll requires at least one argument.");
          var t = Array.prototype.slice.call(arguments, 1);
          if (0 === t.length)
            for (var n in e)
              Gm.call(e, n) &&
                "function" == typeof e[n] &&
                "[object Function]" == Um.call(e[n]) &&
                t.push(n);
          for (var i = 0; i < t.length; i++) {
            var r = t[i];
            e[r] = Wm(e[r], e);
          }
        })(
          this,
          "_onWheel",
          "_onMouseWheel",
          "_onTouchStart",
          "_onTouchMove",
          "_onKeyDown"
        ),
          (this.el = window),
          e && e.el && ((this.el = e.el), delete e.el),
          (this.options = km(
            {
              mouseMultiplier: 1,
              touchMultiplier: 2,
              firefoxMultiplier: 15,
              keyStep: 120,
              preventTouch: !1,
              unpreventTouchClass: "vs-touchmove-allowed",
              limitInertia: !1,
              useKeyboard: !0,
              useTouch: !0,
            },
            e
          )),
          this.options.limitInertia && (this._lethargy = new Vm()),
          (this._emitter = new Om()),
          (this._event = { y: 0, x: 0, deltaX: 0, deltaY: 0 }),
          (this.touchStartX = null),
          (this.touchStartY = null),
          (this.bodyTouchAction = null),
          void 0 !== this.options.passive &&
            (this.listenerOptions = { passive: this.options.passive });
      }
      function Jm(e, t, n) {
        return (1 - n) * e + n * t;
      }
      function Zm(e) {
        var t = {};
        if (window.getComputedStyle) {
          var n = getComputedStyle(e),
            i = n.transform || n.webkitTransform || n.mozTransform,
            r = i.match(/^matrix3d\((.+)\)$/);
          return (
            r
              ? ((t.x = r ? parseFloat(r[1].split(", ")[12]) : 0),
                (t.y = r ? parseFloat(r[1].split(", ")[13]) : 0))
              : ((r = i.match(/^matrix\((.+)\)$/)),
                (t.x = r ? parseFloat(r[1].split(", ")[4]) : 0),
                (t.y = r ? parseFloat(r[1].split(", ")[5]) : 0)),
            t
          );
        }
      }
      function Qm(e) {
        for (var t = []; e && e !== document; e = e.parentNode) t.push(e);
        return t;
      }
      (Ym.prototype._notify = function (e) {
        var t = this._event;
        (t.x += t.deltaX),
          (t.y += t.deltaY),
          this._emitter.emit(qm, {
            x: t.x,
            y: t.y,
            deltaX: t.deltaX,
            deltaY: t.deltaY,
            originalEvent: e,
          });
      }),
        (Ym.prototype._onWheel = function (e) {
          var t = this.options;
          if (!this._lethargy || !1 !== this._lethargy.check(e)) {
            var n = this._event;
            (n.deltaX = e.wheelDeltaX || -1 * e.deltaX),
              (n.deltaY = e.wheelDeltaY || -1 * e.deltaY),
              zm &&
                1 == e.deltaMode &&
                ((n.deltaX *= t.firefoxMultiplier),
                (n.deltaY *= t.firefoxMultiplier)),
              (n.deltaX *= t.mouseMultiplier),
              (n.deltaY *= t.mouseMultiplier),
              this._notify(e);
          }
        }),
        (Ym.prototype._onMouseWheel = function (e) {
          if (!this.options.limitInertia || !1 !== this._lethargy.check(e)) {
            var t = this._event;
            (t.deltaX = e.wheelDeltaX ? e.wheelDeltaX : 0),
              (t.deltaY = e.wheelDeltaY ? e.wheelDeltaY : e.wheelDelta),
              this._notify(e);
          }
        }),
        (Ym.prototype._onTouchStart = function (e) {
          var t = e.targetTouches ? e.targetTouches[0] : e;
          (this.touchStartX = t.pageX), (this.touchStartY = t.pageY);
        }),
        (Ym.prototype._onTouchMove = function (e) {
          var t = this.options;
          t.preventTouch &&
            !e.target.classList.contains(t.unpreventTouchClass) &&
            e.preventDefault();
          var n = this._event,
            i = e.targetTouches ? e.targetTouches[0] : e;
          (n.deltaX = (i.pageX - this.touchStartX) * t.touchMultiplier),
            (n.deltaY = (i.pageY - this.touchStartY) * t.touchMultiplier),
            (this.touchStartX = i.pageX),
            (this.touchStartY = i.pageY),
            this._notify(e);
        }),
        (Ym.prototype._onKeyDown = function (e) {
          var t = this._event;
          t.deltaX = t.deltaY = 0;
          var n = window.innerHeight - 40;
          switch (e.keyCode) {
            case 37:
            case 38:
              t.deltaY = this.options.keyStep;
              break;
            case 39:
            case 40:
              t.deltaY = -this.options.keyStep;
              break;
            case e.shiftKey:
              t.deltaY = n;
              break;
            case 32:
              t.deltaY = -n;
              break;
            default:
              return;
          }
          this._notify(e);
        }),
        (Ym.prototype._bind = function () {
          Im &&
            this.el.addEventListener(
              "wheel",
              this._onWheel,
              this.listenerOptions
            ),
            Dm &&
              this.el.addEventListener(
                "mousewheel",
                this._onMouseWheel,
                this.listenerOptions
              ),
            jm &&
              this.options.useTouch &&
              (this.el.addEventListener(
                "touchstart",
                this._onTouchStart,
                this.listenerOptions
              ),
              this.el.addEventListener(
                "touchmove",
                this._onTouchMove,
                this.listenerOptions
              )),
            Hm &&
              Fm &&
              ((this.bodyTouchAction = document.body.style.msTouchAction),
              (document.body.style.msTouchAction = "none"),
              this.el.addEventListener("MSPointerDown", this._onTouchStart, !0),
              this.el.addEventListener("MSPointerMove", this._onTouchMove, !0)),
            Bm &&
              this.options.useKeyboard &&
              document.addEventListener("keydown", this._onKeyDown);
        }),
        (Ym.prototype._unbind = function () {
          Im && this.el.removeEventListener("wheel", this._onWheel),
            Dm && this.el.removeEventListener("mousewheel", this._onMouseWheel),
            jm &&
              (this.el.removeEventListener("touchstart", this._onTouchStart),
              this.el.removeEventListener("touchmove", this._onTouchMove)),
            Hm &&
              Fm &&
              ((document.body.style.msTouchAction = this.bodyTouchAction),
              this.el.removeEventListener(
                "MSPointerDown",
                this._onTouchStart,
                !0
              ),
              this.el.removeEventListener(
                "MSPointerMove",
                this._onTouchMove,
                !0
              )),
            Bm &&
              this.options.useKeyboard &&
              document.removeEventListener("keydown", this._onKeyDown);
        }),
        (Ym.prototype.on = function (e, t) {
          this._emitter.on(qm, e, t);
          var n = this._emitter.e;
          n && n[qm] && 1 === n[qm].length && this._bind();
        }),
        (Ym.prototype.off = function (e, t) {
          this._emitter.off(qm, e, t);
          var n = this._emitter.e;
          (!n[qm] || n[qm].length <= 0) && this._unbind();
        }),
        (Ym.prototype.reset = function () {
          var e = this._event;
          (e.x = 0), (e.y = 0);
        }),
        (Ym.prototype.destroy = function () {
          this._emitter.off(), this._unbind();
        });
      var Km = 0.1,
        $m = "function" == typeof Float32Array;
      function eg(e, t) {
        return 1 - 3 * t + 3 * e;
      }
      function tg(e, t) {
        return 3 * t - 6 * e;
      }
      function ng(e) {
        return 3 * e;
      }
      function ig(e, t, n) {
        return ((eg(t, n) * e + tg(t, n)) * e + ng(t)) * e;
      }
      function rg(e, t, n) {
        return 3 * eg(t, n) * e * e + 2 * tg(t, n) * e + ng(t);
      }
      function ag(e) {
        return e;
      }
      var og = function (e, t, n, i) {
          if (!(0 <= e && e <= 1 && 0 <= n && n <= 1))
            throw new Error("bezier x values must be in [0, 1] range");
          if (e === t && n === i) return ag;
          for (
            var r = $m ? new Float32Array(11) : new Array(11), a = 0;
            a < 11;
            ++a
          )
            r[a] = ig(a * Km, e, n);
          return function (a) {
            return 0 === a
              ? 0
              : 1 === a
              ? 1
              : ig(
                  (function (t) {
                    for (var i = 0, a = 1; 10 !== a && r[a] <= t; ++a) i += Km;
                    --a;
                    var o = i + ((t - r[a]) / (r[a + 1] - r[a])) * Km,
                      s = rg(o, e, n);
                    return s >= 0.001
                      ? (function (e, t, n, i) {
                          for (var r = 0; r < 4; ++r) {
                            var a = rg(t, n, i);
                            if (0 === a) return t;
                            t -= (ig(t, n, i) - e) / a;
                          }
                          return t;
                        })(t, o, e, n)
                      : 0 === s
                      ? o
                      : (function (e, t, n, i, r) {
                          var a,
                            o,
                            s = 0;
                          do {
                            (a = ig((o = t + (n - t) / 2), i, r) - e) > 0
                              ? (n = o)
                              : (t = o);
                          } while (Math.abs(a) > 1e-7 && ++s < 10);
                          return o;
                        })(t, i, i + Km, e, n);
                  })(a),
                  t,
                  i
                );
          };
        },
        sg = (function (e) {
          hm(n, e);
          var t = mm(n);
          function n() {
            var e,
              i =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : {};
            return (
              rm(this, n),
              history.scrollRestoration &&
                (history.scrollRestoration = "manual"),
              window.scrollTo(0, 0),
              (e = t.call(this, i)).inertia && (e.lerp = 0.1 * e.inertia),
              (e.isScrolling = !1),
              (e.isDraggingScrollbar = !1),
              (e.isTicking = !1),
              (e.hasScrollTicking = !1),
              (e.parallaxElements = {}),
              (e.stop = !1),
              (e.scrollbarContainer = i.scrollbarContainer),
              (e.checkKey = e.checkKey.bind(dm(e))),
              window.addEventListener("keydown", e.checkKey, !1),
              e
            );
          }
          return (
            om(n, [
              {
                key: "init",
                value: function () {
                  var e = this;
                  this.html.classList.add(this.smoothClass),
                    this.html.setAttribute(
                      "data-".concat(this.name, "-direction"),
                      this.direction
                    ),
                    (this.instance = lm(
                      { delta: { x: 0, y: 0 } },
                      this.instance
                    )),
                    (this.vs = new Xm({
                      el: this.scrollFromAnywhere ? document : this.el,
                      mouseMultiplier:
                        navigator.platform.indexOf("Win") > -1 ? 1 : 0.4,
                      firefoxMultiplier: this.firefoxMultiplier,
                      touchMultiplier: this.touchMultiplier,
                      useKeyboard: !1,
                      passive: !0,
                    })),
                    this.vs.on(function (t) {
                      e.stop ||
                        e.isDraggingScrollbar ||
                        requestAnimationFrame(function () {
                          e.updateDelta(t), e.isScrolling || e.startScrolling();
                        });
                    }),
                    this.setScrollLimit(),
                    this.initScrollBar(),
                    this.addSections(),
                    this.addElements(),
                    this.checkScroll(!0),
                    this.transformElements(!0, !0),
                    gm(um(n.prototype), "init", this).call(this);
                },
              },
              {
                key: "setScrollLimit",
                value: function () {
                  if (
                    ((this.instance.limit.y =
                      this.el.offsetHeight - this.windowHeight),
                    "horizontal" === this.direction)
                  ) {
                    for (
                      var e = 0, t = this.el.children, n = 0;
                      n < t.length;
                      n++
                    )
                      e += t[n].offsetWidth;
                    this.instance.limit.x = e - this.windowWidth;
                  }
                },
              },
              {
                key: "startScrolling",
                value: function () {
                  (this.startScrollTs = Date.now()),
                    (this.isScrolling = !0),
                    this.checkScroll(),
                    this.html.classList.add(this.scrollingClass);
                },
              },
              {
                key: "stopScrolling",
                value: function () {
                  cancelAnimationFrame(this.checkScrollRaf),
                    this.scrollToRaf &&
                      (cancelAnimationFrame(this.scrollToRaf),
                      (this.scrollToRaf = null)),
                    (this.isScrolling = !1),
                    (this.instance.scroll.y = Math.round(
                      this.instance.scroll.y
                    )),
                    this.html.classList.remove(this.scrollingClass);
                },
              },
              {
                key: "checkKey",
                value: function (e) {
                  var t = this;
                  if (this.stop)
                    9 == e.keyCode &&
                      requestAnimationFrame(function () {
                        (t.html.scrollTop = 0),
                          (document.body.scrollTop = 0),
                          (t.html.scrollLeft = 0),
                          (document.body.scrollLeft = 0);
                      });
                  else {
                    switch (e.keyCode) {
                      case 9:
                        requestAnimationFrame(function () {
                          (t.html.scrollTop = 0),
                            (document.body.scrollTop = 0),
                            (t.html.scrollLeft = 0),
                            (document.body.scrollLeft = 0),
                            t.scrollTo(document.activeElement, {
                              offset: -window.innerHeight / 2,
                            });
                        });
                        break;
                      case 38:
                        this.instance.delta[this.directionAxis] -= 240;
                        break;
                      case 40:
                        this.instance.delta[this.directionAxis] += 240;
                        break;
                      case 33:
                        this.instance.delta[this.directionAxis] -=
                          window.innerHeight;
                        break;
                      case 34:
                        this.instance.delta[this.directionAxis] +=
                          window.innerHeight;
                        break;
                      case 36:
                        this.instance.delta[this.directionAxis] -=
                          this.instance.limit[this.directionAxis];
                        break;
                      case 35:
                        this.instance.delta[this.directionAxis] +=
                          this.instance.limit[this.directionAxis];
                        break;
                      case 32:
                        document.activeElement instanceof HTMLInputElement ||
                          document.activeElement instanceof
                            HTMLTextAreaElement ||
                          (e.shiftKey
                            ? (this.instance.delta[this.directionAxis] -=
                                window.innerHeight)
                            : (this.instance.delta[this.directionAxis] +=
                                window.innerHeight));
                        break;
                      default:
                        return;
                    }
                    this.instance.delta[this.directionAxis] < 0 &&
                      (this.instance.delta[this.directionAxis] = 0),
                      this.instance.delta[this.directionAxis] >
                        this.instance.limit[this.directionAxis] &&
                        (this.instance.delta[this.directionAxis] =
                          this.instance.limit[this.directionAxis]),
                      this.stopScrolling(),
                      (this.isScrolling = !0),
                      this.checkScroll(),
                      this.html.classList.add(this.scrollingClass);
                  }
                },
              },
              {
                key: "checkScroll",
                value: function () {
                  var e = this,
                    t =
                      arguments.length > 0 &&
                      void 0 !== arguments[0] &&
                      arguments[0];
                  if (t || this.isScrolling || this.isDraggingScrollbar) {
                    this.hasScrollTicking ||
                      ((this.checkScrollRaf = requestAnimationFrame(
                        function () {
                          return e.checkScroll();
                        }
                      )),
                      (this.hasScrollTicking = !0)),
                      this.updateScroll();
                    var i = Math.abs(
                        this.instance.delta[this.directionAxis] -
                          this.instance.scroll[this.directionAxis]
                      ),
                      r = Date.now() - this.startScrollTs;
                    if (
                      (!this.animatingScroll &&
                        r > 100 &&
                        ((i < 0.5 &&
                          0 != this.instance.delta[this.directionAxis]) ||
                          (i < 0.5 &&
                            0 == this.instance.delta[this.directionAxis])) &&
                        this.stopScrolling(),
                      Object.entries(this.sections).forEach(function (t) {
                        var n = vm(t, 2),
                          i = (n[0], n[1]);
                        i.persistent ||
                        (e.instance.scroll[e.directionAxis] >
                          i.offset[e.directionAxis] &&
                          e.instance.scroll[e.directionAxis] <
                            i.limit[e.directionAxis])
                          ? ("horizontal" === e.direction
                              ? e.transform(
                                  i.el,
                                  -e.instance.scroll[e.directionAxis],
                                  0
                                )
                              : e.transform(
                                  i.el,
                                  0,
                                  -e.instance.scroll[e.directionAxis]
                                ),
                            i.inView ||
                              ((i.inView = !0),
                              (i.el.style.opacity = 1),
                              (i.el.style.pointerEvents = "all"),
                              i.el.setAttribute(
                                "data-".concat(e.name, "-section-inview"),
                                ""
                              )))
                          : (i.inView &&
                              ((i.inView = !1),
                              (i.el.style.opacity = 0),
                              (i.el.style.pointerEvents = "none"),
                              i.el.removeAttribute(
                                "data-".concat(e.name, "-section-inview")
                              )),
                            e.transform(i.el, 0, 0));
                      }),
                      this.getDirection && this.addDirection(),
                      this.getSpeed &&
                        (this.addSpeed(), (this.speedTs = Date.now())),
                      this.detectElements(),
                      this.transformElements(),
                      this.hasScrollbar)
                    ) {
                      var a =
                        (this.instance.scroll[this.directionAxis] /
                          this.instance.limit[this.directionAxis]) *
                        this.scrollBarLimit[this.directionAxis];
                      "horizontal" === this.direction
                        ? this.transform(this.scrollbarThumb, a, 0)
                        : this.transform(this.scrollbarThumb, 0, a);
                    }
                    gm(um(n.prototype), "checkScroll", this).call(this),
                      (this.hasScrollTicking = !1);
                  }
                },
              },
              {
                key: "resize",
                value: function () {
                  (this.windowHeight = window.innerHeight),
                    (this.windowWidth = window.innerWidth),
                    this.checkContext(),
                    (this.windowMiddle = {
                      x: this.windowWidth / 2,
                      y: this.windowHeight / 2,
                    }),
                    this.update();
                },
              },
              {
                key: "updateDelta",
                value: function (e) {
                  var t,
                    n =
                      this[this.context] && this[this.context].gestureDirection
                        ? this[this.context].gestureDirection
                        : this.gestureDirection;
                  (t =
                    "both" === n
                      ? e.deltaX + e.deltaY
                      : "vertical" === n
                      ? e.deltaY
                      : "horizontal" === n
                      ? e.deltaX
                      : e.deltaY),
                    (this.instance.delta[this.directionAxis] -=
                      t * this.multiplier),
                    this.instance.delta[this.directionAxis] < 0 &&
                      (this.instance.delta[this.directionAxis] = 0),
                    this.instance.delta[this.directionAxis] >
                      this.instance.limit[this.directionAxis] &&
                      (this.instance.delta[this.directionAxis] =
                        this.instance.limit[this.directionAxis]);
                },
              },
              {
                key: "updateScroll",
                value: function (e) {
                  this.isScrolling || this.isDraggingScrollbar
                    ? (this.instance.scroll[this.directionAxis] = Jm(
                        this.instance.scroll[this.directionAxis],
                        this.instance.delta[this.directionAxis],
                        this.lerp
                      ))
                    : this.instance.scroll[this.directionAxis] >
                      this.instance.limit[this.directionAxis]
                    ? this.setScroll(
                        this.instance.scroll[this.directionAxis],
                        this.instance.limit[this.directionAxis]
                      )
                    : this.instance.scroll.y < 0
                    ? this.setScroll(
                        this.instance.scroll[this.directionAxis],
                        0
                      )
                    : this.setScroll(
                        this.instance.scroll[this.directionAxis],
                        this.instance.delta[this.directionAxis]
                      );
                },
              },
              {
                key: "addDirection",
                value: function () {
                  this.instance.delta.y > this.instance.scroll.y
                    ? "down" !== this.instance.direction &&
                      (this.instance.direction = "down")
                    : this.instance.delta.y < this.instance.scroll.y &&
                      "up" !== this.instance.direction &&
                      (this.instance.direction = "up"),
                    this.instance.delta.x > this.instance.scroll.x
                      ? "right" !== this.instance.direction &&
                        (this.instance.direction = "right")
                      : this.instance.delta.x < this.instance.scroll.x &&
                        "left" !== this.instance.direction &&
                        (this.instance.direction = "left");
                },
              },
              {
                key: "addSpeed",
                value: function () {
                  this.instance.delta[this.directionAxis] !=
                  this.instance.scroll[this.directionAxis]
                    ? (this.instance.speed =
                        (this.instance.delta[this.directionAxis] -
                          this.instance.scroll[this.directionAxis]) /
                        Math.max(1, Date.now() - this.speedTs))
                    : (this.instance.speed = 0);
                },
              },
              {
                key: "initScrollBar",
                value: function () {
                  if (
                    ((this.scrollbar = document.createElement("span")),
                    (this.scrollbarThumb = document.createElement("span")),
                    this.scrollbar.classList.add(
                      "".concat(this.scrollbarClass)
                    ),
                    this.scrollbarThumb.classList.add(
                      "".concat(this.scrollbarClass, "_thumb")
                    ),
                    this.scrollbar.append(this.scrollbarThumb),
                    this.scrollbarContainer
                      ? this.scrollbarContainer.append(this.scrollbar)
                      : document.body.append(this.scrollbar),
                    (this.getScrollBar = this.getScrollBar.bind(this)),
                    (this.releaseScrollBar = this.releaseScrollBar.bind(this)),
                    (this.moveScrollBar = this.moveScrollBar.bind(this)),
                    this.scrollbarThumb.addEventListener(
                      "mousedown",
                      this.getScrollBar
                    ),
                    window.addEventListener("mouseup", this.releaseScrollBar),
                    window.addEventListener("mousemove", this.moveScrollBar),
                    (this.hasScrollbar = !1),
                    "horizontal" == this.direction)
                  ) {
                    if (
                      this.instance.limit.x + this.windowWidth <=
                      this.windowWidth
                    )
                      return;
                  } else if (
                    this.instance.limit.y + this.windowHeight <=
                    this.windowHeight
                  )
                    return;
                  (this.hasScrollbar = !0),
                    (this.scrollbarBCR =
                      this.scrollbar.getBoundingClientRect()),
                    (this.scrollbarHeight = this.scrollbarBCR.height),
                    (this.scrollbarWidth = this.scrollbarBCR.width),
                    "horizontal" === this.direction
                      ? (this.scrollbarThumb.style.width = "".concat(
                          (this.scrollbarWidth * this.scrollbarWidth) /
                            (this.instance.limit.x + this.scrollbarWidth),
                          "px"
                        ))
                      : (this.scrollbarThumb.style.height = "".concat(
                          (this.scrollbarHeight * this.scrollbarHeight) /
                            (this.instance.limit.y + this.scrollbarHeight),
                          "px"
                        )),
                    (this.scrollbarThumbBCR =
                      this.scrollbarThumb.getBoundingClientRect()),
                    (this.scrollBarLimit = {
                      x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                      y: this.scrollbarHeight - this.scrollbarThumbBCR.height,
                    });
                },
              },
              {
                key: "reinitScrollBar",
                value: function () {
                  if (
                    ((this.hasScrollbar = !1), "horizontal" == this.direction)
                  ) {
                    if (
                      this.instance.limit.x + this.windowWidth <=
                      this.windowWidth
                    )
                      return;
                  } else if (
                    this.instance.limit.y + this.windowHeight <=
                    this.windowHeight
                  )
                    return;
                  (this.hasScrollbar = !0),
                    (this.scrollbarBCR =
                      this.scrollbar.getBoundingClientRect()),
                    (this.scrollbarHeight = this.scrollbarBCR.height),
                    (this.scrollbarWidth = this.scrollbarBCR.width),
                    "horizontal" === this.direction
                      ? (this.scrollbarThumb.style.width = "".concat(
                          (this.scrollbarWidth * this.scrollbarWidth) /
                            (this.instance.limit.x + this.scrollbarWidth),
                          "px"
                        ))
                      : (this.scrollbarThumb.style.height = "".concat(
                          (this.scrollbarHeight * this.scrollbarHeight) /
                            (this.instance.limit.y + this.scrollbarHeight),
                          "px"
                        )),
                    (this.scrollbarThumbBCR =
                      this.scrollbarThumb.getBoundingClientRect()),
                    (this.scrollBarLimit = {
                      x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                      y: this.scrollbarHeight - this.scrollbarThumbBCR.height,
                    });
                },
              },
              {
                key: "destroyScrollBar",
                value: function () {
                  this.scrollbarThumb.removeEventListener(
                    "mousedown",
                    this.getScrollBar
                  ),
                    window.removeEventListener(
                      "mouseup",
                      this.releaseScrollBar
                    ),
                    window.removeEventListener("mousemove", this.moveScrollBar),
                    this.scrollbar.remove();
                },
              },
              {
                key: "getScrollBar",
                value: function (e) {
                  (this.isDraggingScrollbar = !0),
                    this.checkScroll(),
                    this.html.classList.remove(this.scrollingClass),
                    this.html.classList.add(this.draggingClass);
                },
              },
              {
                key: "releaseScrollBar",
                value: function (e) {
                  (this.isDraggingScrollbar = !1),
                    this.html.classList.add(this.scrollingClass),
                    this.html.classList.remove(this.draggingClass);
                },
              },
              {
                key: "moveScrollBar",
                value: function (e) {
                  var t = this;
                  this.isDraggingScrollbar &&
                    requestAnimationFrame(function () {
                      var n =
                          (((100 * (e.clientX - t.scrollbarBCR.left)) /
                            t.scrollbarWidth) *
                            t.instance.limit.x) /
                          100,
                        i =
                          (((100 * (e.clientY - t.scrollbarBCR.top)) /
                            t.scrollbarHeight) *
                            t.instance.limit.y) /
                          100;
                      i > 0 &&
                        i < t.instance.limit.y &&
                        (t.instance.delta.y = i),
                        n > 0 &&
                          n < t.instance.limit.x &&
                          (t.instance.delta.x = n);
                    });
                },
              },
              {
                key: "addElements",
                value: function () {
                  var e = this;
                  (this.els = {}),
                    (this.parallaxElements = {}),
                    this.el
                      .querySelectorAll("[data-".concat(this.name, "]"))
                      .forEach(function (t, n) {
                        var i,
                          r,
                          a,
                          o = Qm(t),
                          s = Object.entries(e.sections)
                            .map(function (e) {
                              var t = vm(e, 2);
                              return t[0], t[1];
                            })
                            .find(function (e) {
                              return o.includes(e.el);
                            }),
                          c = t.dataset[e.name + "Class"] || e.class,
                          l =
                            "string" == typeof t.dataset[e.name + "Id"]
                              ? t.dataset[e.name + "Id"]
                              : "el" + n,
                          h = t.dataset[e.name + "Repeat"],
                          u = t.dataset[e.name + "Call"],
                          p = t.dataset[e.name + "Position"],
                          d = t.dataset[e.name + "Delay"],
                          f = t.dataset[e.name + "Direction"],
                          m = "string" == typeof t.dataset[e.name + "Sticky"],
                          g =
                            !!t.dataset[e.name + "Speed"] &&
                            parseFloat(t.dataset[e.name + "Speed"]) / 10,
                          v =
                            "string" == typeof t.dataset[e.name + "Offset"]
                              ? t.dataset[e.name + "Offset"].split(",")
                              : e.offset,
                          y = t.dataset[e.name + "Target"],
                          _ = (a =
                            void 0 !== y
                              ? document.querySelector("".concat(y))
                              : t).getBoundingClientRect();
                        null === s || s.inView
                          ? ((i = _.top + e.instance.scroll.y - Zm(a).y),
                            (r = _.left + e.instance.scroll.x - Zm(a).x))
                          : ((i = _.top - Zm(s.el).y - Zm(a).y),
                            (r = _.left - Zm(s.el).x - Zm(a).x));
                        var w = i + a.offsetHeight,
                          x = r + a.offsetWidth,
                          b = { x: (x - r) / 2 + r, y: (w - i) / 2 + i };
                        if (m) {
                          var M = t.getBoundingClientRect(),
                            S = M.top,
                            T = M.left,
                            E = { x: T - r, y: S - i };
                          (i += window.innerHeight),
                            (r += window.innerWidth),
                            (w =
                              S +
                              a.offsetHeight -
                              t.offsetHeight -
                              E[e.directionAxis]),
                            (b = {
                              x:
                                ((x =
                                  T +
                                  a.offsetWidth -
                                  t.offsetWidth -
                                  E[e.directionAxis]) -
                                  r) /
                                  2 +
                                r,
                              y: (w - i) / 2 + i,
                            });
                        }
                        h = "false" != h && (null != h || e.repeat);
                        var A = [0, 0];
                        if (v)
                          if ("horizontal" === e.direction) {
                            for (var L = 0; L < v.length; L++)
                              "string" == typeof v[L]
                                ? v[L].includes("%")
                                  ? (A[L] = parseInt(
                                      (v[L].replace("%", "") * e.windowWidth) /
                                        100
                                    ))
                                  : (A[L] = parseInt(v[L]))
                                : (A[L] = v[L]);
                            (r += A[0]), (x -= A[1]);
                          } else {
                            for (L = 0; L < v.length; L++)
                              "string" == typeof v[L]
                                ? v[L].includes("%")
                                  ? (A[L] = parseInt(
                                      (v[L].replace("%", "") * e.windowHeight) /
                                        100
                                    ))
                                  : (A[L] = parseInt(v[L]))
                                : (A[L] = v[L]);
                            (i += A[0]), (w -= A[1]);
                          }
                        var P = {
                          el: t,
                          id: l,
                          class: c,
                          section: s,
                          top: i,
                          middle: b,
                          bottom: w,
                          left: r,
                          right: x,
                          offset: v,
                          progress: 0,
                          repeat: h,
                          inView: !1,
                          call: u,
                          speed: g,
                          delay: d,
                          position: p,
                          target: a,
                          direction: f,
                          sticky: m,
                        };
                        (e.els[l] = P),
                          t.classList.contains(c) && e.setInView(e.els[l], l),
                          (!1 !== g || m) && (e.parallaxElements[l] = P);
                      });
                },
              },
              {
                key: "addSections",
                value: function () {
                  var e = this;
                  this.sections = {};
                  var t = this.el.querySelectorAll(
                    "[data-".concat(this.name, "-section]")
                  );
                  0 === t.length && (t = [this.el]),
                    t.forEach(function (t, n) {
                      var i =
                          "string" == typeof t.dataset[e.name + "Id"]
                            ? t.dataset[e.name + "Id"]
                            : "section" + n,
                        r = t.getBoundingClientRect(),
                        a = {
                          x: r.left - 1.5 * window.innerWidth - Zm(t).x,
                          y: r.top - 1.5 * window.innerHeight - Zm(t).y,
                        },
                        o = {
                          x: a.x + r.width + 2 * window.innerWidth,
                          y: a.y + r.height + 2 * window.innerHeight,
                        },
                        s = "string" == typeof t.dataset[e.name + "Persistent"];
                      t.setAttribute("data-scroll-section-id", i);
                      var c = {
                        el: t,
                        offset: a,
                        limit: o,
                        inView: !1,
                        persistent: s,
                        id: i,
                      };
                      e.sections[i] = c;
                    });
                },
              },
              {
                key: "transform",
                value: function (e, t, n, i) {
                  var r;
                  if (i) {
                    var a = Zm(e),
                      o = Jm(a.x, t, i),
                      s = Jm(a.y, n, i);
                    r = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,"
                      .concat(o, ",")
                      .concat(s, ",0,1)");
                  } else
                    r = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,"
                      .concat(t, ",")
                      .concat(n, ",0,1)");
                  (e.style.webkitTransform = r),
                    (e.style.msTransform = r),
                    (e.style.transform = r);
                },
              },
              {
                key: "transformElements",
                value: function (e) {
                  var t = this,
                    n =
                      arguments.length > 1 &&
                      void 0 !== arguments[1] &&
                      arguments[1],
                    i = this.instance.scroll.x + this.windowWidth,
                    r = this.instance.scroll.y + this.windowHeight,
                    a = {
                      x: this.instance.scroll.x + this.windowMiddle.x,
                      y: this.instance.scroll.y + this.windowMiddle.y,
                    };
                  Object.entries(this.parallaxElements).forEach(function (o) {
                    var s = vm(o, 2),
                      c = (s[0], s[1]),
                      l = !1;
                    if ((e && (l = 0), c.inView || n))
                      switch (c.position) {
                        case "top":
                          l = t.instance.scroll[t.directionAxis] * -c.speed;
                          break;
                        case "elementTop":
                          l = (r - c.top) * -c.speed;
                          break;
                        case "bottom":
                          l =
                            (t.instance.limit[t.directionAxis] -
                              r +
                              t.windowHeight) *
                            c.speed;
                          break;
                        case "left":
                          l = t.instance.scroll[t.directionAxis] * -c.speed;
                          break;
                        case "elementLeft":
                          l = (i - c.left) * -c.speed;
                          break;
                        case "right":
                          l =
                            (t.instance.limit[t.directionAxis] -
                              i +
                              t.windowHeight) *
                            c.speed;
                          break;
                        default:
                          l =
                            (a[t.directionAxis] - c.middle[t.directionAxis]) *
                            -c.speed;
                      }
                    c.sticky &&
                      (l = c.inView
                        ? "horizontal" === t.direction
                          ? t.instance.scroll.x - c.left + window.innerWidth
                          : t.instance.scroll.y - c.top + window.innerHeight
                        : "horizontal" === t.direction
                        ? t.instance.scroll.x < c.left - window.innerWidth &&
                          t.instance.scroll.x < c.left - window.innerWidth / 2
                          ? 0
                          : t.instance.scroll.x > c.right &&
                            t.instance.scroll.x > c.right + 100 &&
                            c.right - c.left + window.innerWidth
                        : t.instance.scroll.y < c.top - window.innerHeight &&
                          t.instance.scroll.y < c.top - window.innerHeight / 2
                        ? 0
                        : t.instance.scroll.y > c.bottom &&
                          t.instance.scroll.y > c.bottom + 100 &&
                          c.bottom - c.top + window.innerHeight),
                      !1 !== l &&
                        ("horizontal" === c.direction ||
                        ("horizontal" === t.direction &&
                          "vertical" !== c.direction)
                          ? t.transform(c.el, l, 0, !e && c.delay)
                          : t.transform(c.el, 0, l, !e && c.delay));
                  });
                },
              },
              {
                key: "scrollTo",
                value: function (e) {
                  var t = this,
                    n =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {},
                    i = parseInt(n.offset) || 0,
                    r = n.duration || 1e3,
                    a = n.easing || [0.25, 0, 0.35, 1],
                    o = !!n.disableLerp,
                    s = !!n.callback && n.callback;
                  if (((a = og.apply(void 0, ym(a))), "string" == typeof e)) {
                    if ("top" === e) e = 0;
                    else if ("bottom" === e) e = this.instance.limit.y;
                    else if ("left" === e) e = 0;
                    else if ("right" === e) e = this.instance.limit.x;
                    else if (!(e = document.querySelector(e))) return;
                  } else if ("number" == typeof e) e = parseInt(e);
                  else if (!e || !e.tagName)
                    return void console.warn("`target` parameter is not valid");
                  if ("number" != typeof e) {
                    var c = Qm(e).includes(this.el);
                    if (!c) return;
                    var l = e.getBoundingClientRect(),
                      h = l.top,
                      u = l.left,
                      p = Qm(e),
                      d = p.find(function (e) {
                        return Object.entries(t.sections)
                          .map(function (e) {
                            var t = vm(e, 2);
                            return t[0], t[1];
                          })
                          .find(function (t) {
                            return t.el == e;
                          });
                      }),
                      f = 0;
                    (f = d
                      ? Zm(d)[this.directionAxis]
                      : -this.instance.scroll[this.directionAxis]),
                      (i =
                        "horizontal" === this.direction
                          ? u + i - f
                          : h + i - f);
                  } else i = e + i;
                  var m = parseFloat(this.instance.delta[this.directionAxis]),
                    g = Math.max(
                      0,
                      Math.min(i, this.instance.limit[this.directionAxis])
                    ),
                    v = g - m,
                    y = function (e) {
                      o
                        ? "horizontal" === t.direction
                          ? t.setScroll(m + v * e, t.instance.delta.y)
                          : t.setScroll(t.instance.delta.x, m + v * e)
                        : (t.instance.delta[t.directionAxis] = m + v * e);
                    };
                  (this.animatingScroll = !0),
                    this.stopScrolling(),
                    this.startScrolling();
                  var _ = Date.now(),
                    w = function e() {
                      var n = (Date.now() - _) / r;
                      n > 1
                        ? (y(1),
                          (t.animatingScroll = !1),
                          0 == r && t.update(),
                          s && s())
                        : ((t.scrollToRaf = requestAnimationFrame(e)), y(a(n)));
                    };
                  w();
                },
              },
              {
                key: "update",
                value: function () {
                  this.setScrollLimit(),
                    this.addSections(),
                    this.addElements(),
                    this.detectElements(),
                    this.updateScroll(),
                    this.transformElements(!0),
                    this.reinitScrollBar(),
                    this.checkScroll(!0);
                },
              },
              {
                key: "startScroll",
                value: function () {
                  this.stop = !1;
                },
              },
              {
                key: "stopScroll",
                value: function () {
                  this.stop = !0;
                },
              },
              {
                key: "setScroll",
                value: function (e, t) {
                  this.instance = lm(
                    lm({}, this.instance),
                    {},
                    { scroll: { x: e, y: t }, delta: { x: e, y: t }, speed: 0 }
                  );
                },
              },
              {
                key: "destroy",
                value: function () {
                  gm(um(n.prototype), "destroy", this).call(this),
                    this.stopScrolling(),
                    this.html.classList.remove(this.smoothClass),
                    this.vs.destroy(),
                    this.destroyScrollBar(),
                    window.removeEventListener("keydown", this.checkKey, !1);
                },
              },
            ]),
            n
          );
        })(bm);
      const cg = (function () {
        function e() {
          var t =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          rm(this, e),
            (this.options = t),
            Object.assign(this, xm, t),
            (this.smartphone = xm.smartphone),
            t.smartphone && Object.assign(this.smartphone, t.smartphone),
            (this.tablet = xm.tablet),
            t.tablet && Object.assign(this.tablet, t.tablet),
            this.smooth ||
              "horizontal" != this.direction ||
              console.warn(
                " `smooth:false` & `horizontal` direction are not yet compatible"
              ),
            this.tablet.smooth ||
              "horizontal" != this.tablet.direction ||
              console.warn(
                " `smooth:false` & `horizontal` direction are not yet compatible (tablet)"
              ),
            this.smartphone.smooth ||
              "horizontal" != this.smartphone.direction ||
              console.warn(
                " `smooth:false` & `horizontal` direction are not yet compatible (smartphone)"
              ),
            this.init();
        }
        return (
          om(e, [
            {
              key: "init",
              value: function () {
                if (
                  ((this.options.isMobile =
                    /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                      navigator.userAgent
                    ) ||
                    ("MacIntel" === navigator.platform &&
                      navigator.maxTouchPoints > 1) ||
                    window.innerWidth < this.tablet.breakpoint),
                  (this.options.isTablet =
                    this.options.isMobile &&
                    window.innerWidth >= this.tablet.breakpoint),
                  (this.smooth && !this.options.isMobile) ||
                  (this.tablet.smooth && this.options.isTablet) ||
                  (this.smartphone.smooth &&
                    this.options.isMobile &&
                    !this.options.isTablet)
                    ? (this.scroll = new sg(this.options))
                    : (this.scroll = new Em(this.options)),
                  this.scroll.init(),
                  window.location.hash)
                ) {
                  var e = window.location.hash.slice(
                      1,
                      window.location.hash.length
                    ),
                    t = document.getElementById(e);
                  t && this.scroll.scrollTo(t);
                }
              },
            },
            {
              key: "update",
              value: function () {
                this.scroll.update();
              },
            },
            {
              key: "start",
              value: function () {
                this.scroll.startScroll();
              },
            },
            {
              key: "stop",
              value: function () {
                this.scroll.stopScroll();
              },
            },
            {
              key: "scrollTo",
              value: function (e, t) {
                this.scroll.scrollTo(e, t);
              },
            },
            {
              key: "setScroll",
              value: function (e, t) {
                this.scroll.setScroll(e, t);
              },
            },
            {
              key: "on",
              value: function (e, t) {
                this.scroll.setEvents(e, t);
              },
            },
            {
              key: "off",
              value: function (e, t) {
                this.scroll.unsetEvents(e, t);
              },
            },
            {
              key: "destroy",
              value: function () {
                this.scroll.destroy();
              },
            },
          ]),
          e
        );
      })();
      var lg = __webpack_require__(41),
        hg = __webpack_require__.n(lg),
        ug = __webpack_require__(766),
        pg = __webpack_require__(503),
        dg = __webpack_require__.n(pg);
      Sd.registerPlugin(Jf), hg()();
      const fg = new Jo(),
        mg = fg.load("./textures/alpha/alphaRing.jpg"),
        gg = fg.load("./textures/alpha/alphaTexture.jpg"),
        vg = fg.load("./textures/displacement/displacement.jpg"),
        yg = fg.load("./textures/img/id.jpg"),
        _g = fg.load("./textures/img/astralys.jpg"),
        wg = fg.load("./textures/img/auriane.jpg"),
        xg = fg.load("./textures/img/folio2020.jpg"),
        bg = fg.load("./textures/img/folio2019.jpg"),
        Mg = fg.load("./textures/img/gamovore.jpg"),
        Sg = fg.load("./textures/img/internship.jpg"),
        Tg = fg.load("./textures/img/mmorpion.jpg"),
        Eg = fg.load("./textures/img/laDette.jpg"),
        Ag = fg.load("./textures/img/motionIntro.jpg"),
        Lg = fg.load("./textures/img/outroId.jpg"),
        Pg = fg.load("./textures/img/3dBackground.jpg"),
        Rg = fg.load("./textures/img/animayo.jpg"),
        kg = fg.load("./textures/img/cmsFolio.jpg"),
        Cg = fg.load("./textures/img/letterMask.jpg"),
        Og = fg.load("./textures/img/newspaper.jpg"),
        Ng = fg.load("./textures/img/terreDeBois.jpg"),
        Ig = fg.load("./textures/img/mushrooms.jpg"),
        Dg = fg.load("./textures/img/dressOn.jpg"),
        jg = fg.load("./textures/img/jamOn.jpg"),
        Fg = new Xo().load([
          "./textures/environmentMaps/px.jpg",
          "./textures/environmentMaps/nx.jpg",
          "./textures/environmentMaps/py.jpg",
          "./textures/environmentMaps/ny.jpg",
          "./textures/environmentMaps/pz.jpg",
          "./textures/environmentMaps/nz.jpg",
        ]),
        Hg = document.querySelector("body"),
        Bg = document.querySelector("html"),
        zg = document.querySelector("#app"),
        Ug = document.querySelector(".canvas--main"),
        Gg = document.querySelector(".canvas--noise"),
        Wg = document.querySelector(".loaderContainer"),
        Vg = document.querySelector(".progress--number"),
        qg = document.querySelectorAll(".progress--button"),
        Xg = document.querySelector(".menuReveal"),
        Yg = document.querySelector(".hamburgerWrapper"),
        Jg = document.querySelector(".lineContainer--1"),
        Zg = document.querySelector(".lineContainer--3"),
        Qg = document.querySelector(".lineContainer--4"),
        Kg = document.querySelector(".lineContainer--2 .line--1"),
        $g = document.querySelector(".lineContainer--2 .line--2"),
        ev = document.querySelector(".lineContainer--3 .line--1"),
        tv = document.querySelector(".lineContainer--3 .line--2"),
        nv = document.querySelectorAll(".lineContainer--3 .line"),
        iv = document.querySelector(".lineContainer--4 .line--1"),
        rv = document.querySelector(".lineContainer--4 .line--2"),
        av = document.querySelectorAll(".lineContainer--4 .line"),
        ov = document.querySelectorAll(".homeLink"),
        sv = document.querySelector(".homeLink--about"),
        cv = document.querySelector(".homeLink--work"),
        lv = document.querySelector(".homeLink--showreel"),
        hv = document.querySelectorAll(".linkWrapper .media a"),
        uv = document.querySelectorAll(".menuReveal .linkWrapper .link"),
        pv = document.querySelector(".menuReveal .linkWrapper .link--home"),
        dv = document.querySelector(".menuReveal .linkWrapper .link--about"),
        fv = document.querySelector(".menuReveal .linkWrapper .link--work"),
        mv = document.querySelector(".menuReveal .linkWrapper .link--showreel"),
        gv = document.querySelector(".container--home"),
        vv = document.querySelector(".container--about"),
        yv = document.querySelector(".container--work"),
        _v = document.querySelector(".workRevealMask"),
        wv = document.querySelector(".workRevealContainer"),
        xv = document.querySelector("video"),
        bv = document.querySelector(".rotateMobileIndication"),
        Mv = document.querySelectorAll(".projectWrapper"),
        Sv = document.querySelector(".projectWrapper--1"),
        Tv = document.querySelector(".projectWrapper--2"),
        Ev = document.querySelector(".projectWrapper--3"),
        Av = document.querySelector(".projectWrapper--4"),
        Lv = document.querySelector(".projectWrapper--5"),
        Pv = document.querySelector(".projectWrapper--6"),
        Rv = document.querySelector(".projectWrapper--7"),
        kv = document.querySelector(".projectWrapper--8"),
        Cv = document.querySelector(".projectWrapper--9"),
        Ov = document.querySelector(".projectWrapper--10"),
        Nv = document.querySelector(".projectWrapper--11"),
        Iv = document.querySelector(".projectWrapper--12"),
        Dv = document.querySelector(".projectWrapper--13"),
        jv = document.querySelector(".projectWrapper--14"),
        Fv = document.querySelector(".projectWrapper--15"),
        Hv = document.querySelector(".projectWrapper--16"),
        Bv = document.querySelector(".projectWrapper--17"),
        zv = document.querySelector(".projectWrapper--18"),
        Uv = document.querySelector(".projectWrapper--19"),
        Gv = document.querySelector(".projectWrapper--20"),
        Wv = document.querySelectorAll("img"),
        Vv = document.querySelector(".aboutWrapper--2 img"),
        qv = document.querySelector(".workRevealWrapper p"),
        Xv = document.querySelector(
          ".workRevealContainer .workRevealWrapper .section--2 img"
        ),
        Yv = document.querySelector(".workRevealContainer .linkProject"),
        Jv = document.querySelectorAll(".workRevealContainer .title"),
        Zv = document.querySelectorAll(".cursor"),
        Qv = document.querySelector(".cursor--dot"),
        Kv = document.querySelector(".cursor--main"),
        $v = document.querySelector(".cursor--indication"),
        ey = document.querySelector(".cursor--follower"),
        ty = document.querySelector(".cursorLoader"),
        ny = document.querySelector(".heySection"),
        iy = document.querySelector(".container--about .title--about"),
        ry = document.querySelector(".aboutWrapper--2"),
        ay = document.querySelector(".container--about .title--course"),
        oy = document.querySelector(".courseSection--1"),
        sy = document.querySelector(".courseSection--2"),
        cy = document.querySelector(".courseSection--3"),
        ly = document.querySelector(".container--about .title--skills"),
        hy = document.querySelector(".skillsSection--1"),
        uy = document.querySelector(".skillsSection--2"),
        py = document.querySelector(".skillsSection--3");
      Qv.style.transform = "rotate(45deg)";
      let dy,
        fy,
        my,
        gy = "home",
        vy = yg,
        yy = !1,
        _y = !1,
        wy = !0,
        xy = !0,
        by = !1,
        My = !1,
        Sy = !1,
        Ty = !0,
        Ey = !1,
        Ay = !1,
        Ly = 0,
        Py = 0.065,
        Ry = { x: window.innerWidth / 2, y: window.innerHeight / 2 },
        ky = { x: Ry.x, y: Ry.y },
        Cy = Sd.quickSetter(Qv, "x", "px"),
        Oy = Sd.quickSetter(Qv, "y", "px"),
        Ny = { x: window.innerWidth / 2, y: window.innerHeight / 2 },
        Iy = { x: Ny.x, y: Ny.y },
        Dy = Sd.quickSetter(Kv, "x", "px"),
        jy = Sd.quickSetter(Kv, "y", "px"),
        Fy = { x: window.innerWidth / 2, y: window.innerHeight / 2 },
        Hy = { x: Fy.x, y: Fy.y },
        By = Sd.quickSetter($v, "x", "px"),
        zy = Sd.quickSetter($v, "y", "px"),
        Uy = { x: window.innerWidth / 2, y: window.innerHeight / 2 },
        Gy = { x: Uy.x, y: Uy.y },
        Wy = Sd.quickSetter(ey, "x", "px"),
        Vy = Sd.quickSetter(ey, "y", "px"),
        qy = 0,
        Xy = 0,
        Yy = 0,
        Jy = 0,
        Zy = setTimeout(h_, 500),
        Qy = 0,
        Ky = !1,
        $y = 0,
        e_ = window.innerWidth / 2,
        t_ = window.innerHeight / 2,
        n_ = 0.003,
        i_ = 2.5,
        r_ = new N(0, 0),
        a_ = (new N(0, 0), !0),
        o_ = new ug.Howl({
          src: ["/"],
          loop: !0,
          volume: 0.5,
        }),
        s_ = new ug.Howl({
          src: ["/"],
          loop: !0,
          volume: 0,
        });
      function c_(e) {
        e.addEventListener("mouseenter", () => {
          Sd.to(Qv, 0.5, {
            padding: "25px",
            borderRadius: "100%",
            background: "transparent",
            border: "1px solid #ffffff",
            ease: "power3",
          }),
            Sd.to(Kv, 0.5, {
              opacity: 0,
              padding: "30px",
              borderRadius: "100%",
              ease: "power3",
            }),
            Sd.to($v, 0.5, { opacity: 0, ease: "power3" }),
            Sd.to(ey, 0.5, {
              opacity: 0,
              padding: "40px",
              borderRadius: "100%",
              ease: "power3",
            });
        }),
          e.addEventListener("mouseleave", () => {
            Sd.to(Qv, 0.5, {
              padding: "0",
              borderRadius: "0%",
              background: "#b1b1b1",
              border: "0pw solid transparent",
              ease: "power3.in",
            }),
              Sd.to(Kv, 0.5, {
                opacity: 1,
                borderRadius: "0%",
                padding: "0px",
                ease: "power3.in",
              }),
              Sd.to($v, 0.5, { opacity: 1, ease: "power3.in" }),
              Sd.to(ey, 0.5, {
                opacity: 0.5,
                borderRadius: "0%",
                padding: "0px",
                ease: "power3.in",
              });
          });
      }
      function l_(e) {
        e.forEach((e) => {
          e.addEventListener("mousemove", () => {
            Sd.to(Qv, 0.35, {
              padding: "20px",
              borderRadius: "100%",
              ease: "power3",
            }),
              Sd.to(Kv, 0.35, {
                opacity: 0,
                borderRadius: "100%",
                ease: "power3",
              }),
              Sd.to($v, 0.35, { opacity: 0, ease: "power3" }),
              Sd.to(".octagon", 0.35, {
                background: "rgba(177, 177, 177, 1)",
                ease: "power3",
              }),
              Sd.to(ey, 0.35, {
                opacity: 0,
                borderRadius: "100%",
                ease: "power3",
              });
          }),
            e.addEventListener("mouseleave", () => {
              Sd.to(Qv, 0.35, {
                padding: "0",
                borderRadius: "0%",
                ease: "power3.in",
              }),
                Sd.to(Kv, 0.35, {
                  opacity: 1,
                  borderRadius: "0%",
                  ease: "power3.in",
                }),
                Sd.to($v, 0.35, { opacity: 1, ease: "power3.in" }),
                Sd.to(".octagon", 0.35, {
                  background: "rgba(177, 177, 177, 0)",
                  ease: "power3.in",
                }),
                Sd.to(ey, 0.35, {
                  opacity: 0.5,
                  borderRadius: "0%",
                  ease: "power3.in",
                });
            }),
            e.addEventListener("click", () => {
              Sd.to(Qv, 0.35, {
                padding: "0",
                borderRadius: "0%",
                ease: "power3.in",
              }),
                Sd.to(Kv, 0.35, {
                  opacity: 1,
                  borderRadius: "0%",
                  ease: "power3.in",
                }),
                Sd.to(".octagon", 0.35, {
                  background: "rgba(177, 177, 177, 0)",
                  ease: "power3.in",
                }),
                Sd.to(ey, 0.35, {
                  opacity: 0.5,
                  borderRadius: "0%",
                  ease: "power3.in",
                });
            });
        });
      }
      function h_() {
        1 == Sy &&
          0 == Ay &&
          "showreel" != gy &&
          "workReveal" != gy &&
          Sd.to(".cursor--indication span", 0.5, {
            opacity: 1,
            ease: "power3.in",
          });
      }
      (xv.src = "./textures/video/reel.mp4"),
        (xv.volume = 0.15),
        (Vv.src = "./textures/img/profile.jpg");
      const u_ = (e, t, n) => e * (1 - n) + t * n,
        p_ = (e) => (e * Math.PI) / 180,
        d_ = new (class {
          constructor(e) {
            Object.assign(this, e),
              (this.active = !0),
              (this.hover = !1),
              window.matchMedia("(max-width: 767px)").matches
                ? (this.settings = {
                    width: 50,
                    height: 6.9,
                    amplitude: -0.18,
                    hoverHeight: 1,
                    hoverAmplitude: -0.12,
                    speed: 5,
                  })
                : (this.settings = {
                    width: 60,
                    height: 6.9,
                    amplitude: -0.18,
                    hoverHeight: 1,
                    hoverAmplitude: -0.12,
                    speed: 5,
                  }),
              this.init();
          }
          init() {
            (this.hover = !0),
              this.button.addEventListener("click", () => {
                (this.active = !this.active),
                  this.button.classList.toggle("active");
              }),
              c_(this.button),
              (this.ctx = this.soundCanvas.getContext("2d")),
              (this.width = this.soundCanvas.clientWidth),
              (this.height = this.soundCanvas.clientHeight),
              (this.amp = 0),
              (this.h = 0),
              (this.soundCanvas.width = this.width),
              (this.soundCanvas.height = this.height),
              (this.soundCanvas.style.width = `${this.width}px`),
              (this.soundCanvas.style.height = `${this.height}px`),
              this.ctx.scale(1, 1);
          }
          clear() {
            this.ctx.clearRect(
              0,
              0,
              this.soundCanvas.width,
              this.soundCanvas.height
            );
          }
          draw(e) {
            this.ctx.fillStyle = this.color;
            for (let t = 0; t < this.settings.width; t++) {
              this.ctx.beginPath();
              const n =
                  this.width / 2 - (this.settings.width / 2) * 0.5 + 0.6 * t,
                i = e * this.settings.speed + t * this.amp,
                r = this.height / 2 + -Math.cos(i) * this.h;
              this.ctx.ellipse(n, r, 0.5, 0.5, p_(360), 0, p_(360)),
                this.ctx.closePath(),
                this.ctx.fill();
            }
          }
          animate(e) {
            let t = this.hover ? this.settings.hoverHeight : 0;
            (t = this.active ? this.settings.height : t),
              (this.h = u_(this.h, t, 0.04));
            let n = this.hover ? this.settings.hoverAmplitude : 0;
            (n = this.active ? this.settings.amplitude : n),
              (this.amp = u_(this.amp, n, 0.04)),
              this.clear(),
              this.draw(e);
          }
        })({
          button: document.querySelector(".musicWrapper"),
          soundCanvas: document.querySelector(".canvas--music"),
          color: "#b1b1b1",
        });
      d_.button.addEventListener("click", () => {
        a_
          ? ((a_ = !1), o_.fade(0.5, 0, 1e3))
          : ((a_ = !0), o_.fade(0, 0.5, 1e3));
      });
      const f_ = new (dg().LoadQueue)(!1);
      (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
        navigator.userAgent
      ) ||
        window.matchMedia("(max-width: 1024px)").matches) &&
        document.addEventListener("click", () => {
          Bg.requestFullscreen
            ? Bg.requestFullscreen()
            : Bg.mozRequestFullScreen
            ? Bg.mozRequestFullScreen()
            : Bg.webkitRequestFullscreen
            ? Bg.webkitRequestFullscreen()
            : Bg.msRequestFullscreen && Bg.msRequestFullscreen();
        }),
        f_.on("progress", (e) => {
          let t = Math.floor(100 * e.progress);
          (Vg.innerHTML = t),
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
              navigator.userAgent
            ) ||
              window.matchMedia("(max-width: 1024px)").matches ||
              setTimeout(function () {
                Zv.forEach((e) => {
                  e.style.display = "block";
                }),
                  Sd.to(Kv, 0.25, { opacity: 1, ease: "power3" }),
                  Sd.to(Qv, 0.25, { opacity: 1, ease: "power3" }),
                  Sd.to(ey, 0.25, { opacity: 0.5, ease: "power3" });
              }, 25);
        }),
        f_.on("complete", () => {
          l_(qg),
            Sd.to(Gg, 3, { opacity: 1, ease: "power3" }),
            Sd.to(Vg, 0.75, {
              opacity: 0,
              clipPath: "inset(100% 0% 0% 0%)",
              transform: "translateY(-15px)",
              ease: "power3",
            }),
            Sd.to(qg, 0.75, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              transform: "translateY(0)",
              ease: "power3",
            }),
            qg.forEach((e) => {
              e.addEventListener("click", () => {
                o_.play(),
                  s_.play(),
                  Sd.to(qg, 0.75, {
                    opacity: 0,
                    clipPath: "inset(100% 0% 0% 0%)",
                    transform: "translateY(-15px)",
                    ease: "power3",
                  }),
                  setTimeout(function () {
                    (Wg.style.display = "none"),
                      setTimeout(function () {
                        (zg.style.pointerEvents = "all"),
                          (Yg.style.pointerEvents = "all"),
                          (d_.button.style.pointerEvents = "all"),
                          ov.forEach((e) => {
                            e.style.pointerEvents = "all";
                          });
                      }, 600),
                      Sd.to(y_.position, 1.5, { z: 1.5, ease: "power3" }),
                      Sd.to(".container--home", 1.5, {
                        transform: "scale(1)",
                        ease: "power3",
                      }),
                      Sd.to(".homeLink", 1, {
                        opacity: 0.6,
                        ease: "power3",
                        delay: 0.55,
                      }),
                      Sd.to(zg, 1.5, { opacity: 1, ease: "power3" }),
                      Sd.to(".musicWrapper", 1.5, {
                        opacity: 1,
                        ease: "power3",
                      }),
                      Sd.to(".hamburgerWrapper", 1.5, {
                        opacity: 1,
                        ease: "power3",
                      }),
                      Sd.to(Ug, 1.5, { opacity: 1, ease: "power3" }),
                      setTimeout(function () {
                        (Sy = !0),
                          Sy &&
                            Sd.to(".cursor--indication span", 0.5, {
                              opacity: 1,
                              ease: "power3.in",
                            });
                      }, 1500);
                  }, 1e3);
              });
            });
        }),
        f_.on("fileload", function () {}),
        f_.loadFile("./textures/alpha/alphaRing.jpg"),
        f_.loadFile("./textures/alpha/alphaTexture.jpg"),
        f_.loadFile("./textures/displacement/displacement.jpg"),
        f_.loadFile("./textures/models/scene.gltf");
      const m_ = new Pr(),
        g_ = new Pr(),
        v_ = { width: window.innerWidth, height: window.innerHeight };
      window.addEventListener("resize", () => {
        (v_.width = window.innerWidth),
          (v_.height = window.innerHeight),
          (y_.aspect = v_.width / v_.height),
          y_.updateProjectionMatrix(),
          H_.setSize(v_.width, v_.height),
          H_.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
          B_.setSize(v_.width, v_.height),
          B_.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      });
      const y_ = new pn(45, v_.width / v_.height, 0.1, 1e3);
      (y_.position.z = 0.75), m_.add(y_);
      const __ = new pn(45, v_.width / v_.height, 0.1, 1e3);
      g_.add(__);
      let w_ = new ut(11645361),
        x_ = new ut(16777215),
        b_ = new ut(1381911);
      const M_ = new Ps(w_, 1.2);
      m_.add(M_);
      const S_ = new Ts(w_, 1.2);
      (S_.position.y = 3), (S_.position.z = 4), m_.add(S_);
      const T_ = new mo({
          metalness: 0.5,
          roughness: 0.1,
          transparent: !0,
          opacity: 1,
          envMap: Fg,
          color: new ut(b_),
        }),
        E_ = new mo({
          metalness: 0.8,
          roughness: 0,
          transparent: !0,
          opacity: 0.15,
          envMap: Fg,
          alphaMap: mg,
        }),
        A_ = new mt({ wireframe: !0, transparent: !0, opacity: 0.015 });
      let L_,
        P_ = new hn({
          vertexShader:
            "precision mediump float;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main(){\r\n  vUv=uv;\r\n  \r\n  \r\n  gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);\r\n}",
          fragmentShader:
            "uniform sampler2D u_texture1;\r\nuniform sampler2D u_texture2;\r\nuniform sampler2D u_displacement;\r\n\r\nuniform float u_dispFactor;\r\nuniform float u_effectFactor;\r\nuniform float u_alpha;\r\nuniform float u_mouseIntensity;\r\nuniform float u_mouseRange;\r\n\r\nuniform vec2 u_mouse;\r\nuniform vec2 u_mousePos;\r\n\r\n\r\nvarying vec2 vUv;\r\n\r\nfloat circle(in vec2 _st, in float _radius, in float blurriness){\r\n    vec2 dist = _st;\r\n    return 1.-smoothstep(_radius-(_radius*blurriness), _radius+(_radius*blurriness), dot(dist,dist)*3.0);\r\n}\r\n\r\nvoid main(){\r\n\r\n  vec2 uv=vUv;\r\n\r\n  //Point\r\n  vec2 ratio = u_mousePos * PR;\r\n\r\n  vec2 st = gl_FragCoord.xy / ratio.xy - vec2(0.5);\r\n\r\n  \tst.y *= u_mousePos.y / u_mousePos.x;\r\n\r\n\tvec2 mouse = u_mouse * -0.5;\r\n\t\r\n\tvec2 circlePos = st + mouse;\r\n\tfloat finalCircle = circle(circlePos, u_mouseIntensity, u_mouseRange)*5.0;\r\n  \r\n  //TEXTURE DISPLACEMENT\r\n  vec4 disp=texture2D(u_displacement,uv.yx);\r\n  \r\n  vec2 distortedPosition=vec2(uv.x,uv.y+u_dispFactor*(disp*u_effectFactor));\r\n  vec2 distortedPosition2=vec2(uv.x,uv.y-(1.-u_dispFactor)*(disp*u_effectFactor));\r\n  \r\n  vec4 _texture=texture2D(u_texture1,distortedPosition);\r\n  vec4 _texture2=texture2D(u_texture2,distortedPosition2);\r\n  \r\n  //FINAL MIX\r\n  vec4 finalTexture=mix(_texture,_texture2,u_dispFactor) * finalCircle;\r\n\r\n  finalTexture.a = u_alpha;\r\n\r\n  gl_FragColor=finalTexture;\r\n\r\n}\r\n",
          side: 1,
          transparent: !0,
          uniforms: {
            u_alpha: { value: 0 },
            u_texture1: { type: "t", value: gg },
            u_texture2: { type: "t", value: gg },
            u_displacement: { type: "t", value: vg },
            u_dispFactor: { type: "f", value: 0 },
            u_effectFactor: { type: "f", value: 1 },
            u_mouse: { value: r_ },
            u_mouseIntensity: { value: 0.01 },
            u_mouseRange: { value: 20 },
            u_mousePos: { value: new N(window.innerWidth, window.innerHeight) },
          },
          defines: { PR: window.devicePixelRatio.toFixed(1) },
        }),
        R_ = new Ic();
      (R_.crossOrigin = !0),
        R_.load("./textures/models/scene.gltf", function (e) {
          (L_ = e.scene),
            L_.traverse((e) => {
              e.isMesh && (e.material = T_);
            }),
            (L_.rotation.x = 1 * Math.PI),
            (L_.position.y = 0.0325),
            (L_.position.x = 0.01),
            L_.scale.set(0.1, 0.1, 0.1),
            m_.add(L_);
        });
      let k_ = new rn(
        new (class extends Ht {
          constructor(e = 0.5, t = 1, n = 8, i = 1, r = 0, a = 2 * Math.PI) {
            super(),
              (this.type = "RingGeometry"),
              (this.parameters = {
                innerRadius: e,
                outerRadius: t,
                thetaSegments: n,
                phiSegments: i,
                thetaStart: r,
                thetaLength: a,
              }),
              (n = Math.max(3, n));
            const o = [],
              s = [],
              c = [],
              l = [];
            let h = e;
            const u = (t - e) / (i = Math.max(1, i)),
              p = new W(),
              d = new N();
            for (let e = 0; e <= i; e++) {
              for (let e = 0; e <= n; e++) {
                const i = r + (e / n) * a;
                (p.x = h * Math.cos(i)),
                  (p.y = h * Math.sin(i)),
                  s.push(p.x, p.y, p.z),
                  c.push(0, 0, 1),
                  (d.x = (p.x / t + 1) / 2),
                  (d.y = (p.y / t + 1) / 2),
                  l.push(d.x, d.y);
              }
              h += u;
            }
            for (let e = 0; e < i; e++) {
              const t = e * (n + 1);
              for (let e = 0; e < n; e++) {
                const i = e + t,
                  r = i,
                  a = i + n + 1,
                  s = i + n + 2,
                  c = i + 1;
                o.push(r, a, c), o.push(a, s, c);
              }
            }
            this.setIndex(o),
              this.setAttribute("position", new At(s, 3)),
              this.setAttribute("normal", new At(c, 3)),
              this.setAttribute("uv", new At(l, 2));
          }
        })(0.4, 0.4025, 8),
        E_
      );
      k_.scale.set(2.8, 2.8, 2.8), (k_.position.z = -6);
      let C_ = k_.clone();
      C_.scale.set(4.2, 4.2, 4.2), (C_.rotation.z = 0.25 * Math.PI);
      let O_ = k_.clone();
      O_.scale.set(6.3, 6.3, 6.3);
      let N_ = k_.clone();
      N_.scale.set(9.45, 9.45, 9.45), (N_.rotation.z = 0.25 * Math.PI);
      let I_ = k_.clone();
      I_.scale.set(14.175, 14.175, 14.175);
      let D_ = new rn(
        new (class extends Ht {
          constructor(
            e = 1,
            t = 8,
            n = 6,
            i = 0,
            r = 2 * Math.PI,
            a = 0,
            o = Math.PI
          ) {
            super(),
              (this.type = "SphereGeometry"),
              (this.parameters = {
                radius: e,
                widthSegments: t,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: a,
                thetaLength: o,
              }),
              (t = Math.max(3, Math.floor(t))),
              (n = Math.max(2, Math.floor(n)));
            const s = Math.min(a + o, Math.PI);
            let c = 0;
            const l = [],
              h = new W(),
              u = new W(),
              p = [],
              d = [],
              f = [],
              m = [];
            for (let p = 0; p <= n; p++) {
              const g = [],
                v = p / n;
              let y = 0;
              0 == p && 0 == a
                ? (y = 0.5 / t)
                : p == n && s == Math.PI && (y = -0.5 / t);
              for (let n = 0; n <= t; n++) {
                const s = n / t;
                (h.x = -e * Math.cos(i + s * r) * Math.sin(a + v * o)),
                  (h.y = e * Math.cos(a + v * o)),
                  (h.z = e * Math.sin(i + s * r) * Math.sin(a + v * o)),
                  d.push(h.x, h.y, h.z),
                  u.copy(h).normalize(),
                  f.push(u.x, u.y, u.z),
                  m.push(s + y, 1 - v),
                  g.push(c++);
              }
              l.push(g);
            }
            for (let e = 0; e < n; e++)
              for (let i = 0; i < t; i++) {
                const t = l[e][i + 1],
                  r = l[e][i],
                  o = l[e + 1][i],
                  c = l[e + 1][i + 1];
                (0 !== e || a > 0) && p.push(t, r, c),
                  (e !== n - 1 || s < Math.PI) && p.push(r, o, c);
              }
            this.setIndex(p),
              this.setAttribute("position", new At(d, 3)),
              this.setAttribute("normal", new At(f, 3)),
              this.setAttribute("uv", new At(m, 2));
          }
        })(35, 100, 100),
        A_
      );
      D_.position.z = -27.5;
      let j_ = new rn(
        new (class extends Ht {
          constructor(
            e = 1,
            t = 1,
            n = 1,
            i = 8,
            r = 1,
            a = !1,
            o = 0,
            s = 2 * Math.PI
          ) {
            super(),
              (this.type = "CylinderGeometry"),
              (this.parameters = {
                radiusTop: e,
                radiusBottom: t,
                height: n,
                radialSegments: i,
                heightSegments: r,
                openEnded: a,
                thetaStart: o,
                thetaLength: s,
              });
            const c = this;
            (i = Math.floor(i)), (r = Math.floor(r));
            const l = [],
              h = [],
              u = [],
              p = [];
            let d = 0;
            const f = [],
              m = n / 2;
            let g = 0;
            function v(n) {
              const r = d,
                a = new N(),
                f = new W();
              let v = 0;
              const y = !0 === n ? e : t,
                _ = !0 === n ? 1 : -1;
              for (let e = 1; e <= i; e++)
                h.push(0, m * _, 0), u.push(0, _, 0), p.push(0.5, 0.5), d++;
              const w = d;
              for (let e = 0; e <= i; e++) {
                const t = (e / i) * s + o,
                  n = Math.cos(t),
                  r = Math.sin(t);
                (f.x = y * r),
                  (f.y = m * _),
                  (f.z = y * n),
                  h.push(f.x, f.y, f.z),
                  u.push(0, _, 0),
                  (a.x = 0.5 * n + 0.5),
                  (a.y = 0.5 * r * _ + 0.5),
                  p.push(a.x, a.y),
                  d++;
              }
              for (let e = 0; e < i; e++) {
                const t = r + e,
                  i = w + e;
                !0 === n ? l.push(i, i + 1, t) : l.push(i + 1, i, t), (v += 3);
              }
              c.addGroup(g, v, !0 === n ? 1 : 2), (g += v);
            }
            !(function () {
              const a = new W(),
                v = new W();
              let y = 0;
              const _ = (t - e) / n;
              for (let c = 0; c <= r; c++) {
                const l = [],
                  g = c / r,
                  y = g * (t - e) + e;
                for (let e = 0; e <= i; e++) {
                  const t = e / i,
                    r = t * s + o,
                    c = Math.sin(r),
                    f = Math.cos(r);
                  (v.x = y * c),
                    (v.y = -g * n + m),
                    (v.z = y * f),
                    h.push(v.x, v.y, v.z),
                    a.set(c, _, f).normalize(),
                    u.push(a.x, a.y, a.z),
                    p.push(t, 1 - g),
                    l.push(d++);
                }
                f.push(l);
              }
              for (let e = 0; e < i; e++)
                for (let t = 0; t < r; t++) {
                  const n = f[t][e],
                    i = f[t + 1][e],
                    r = f[t + 1][e + 1],
                    a = f[t][e + 1];
                  l.push(n, i, a), l.push(i, r, a), (y += 6);
                }
              c.addGroup(g, y, 0), (g += y);
            })(),
              !1 === a && (e > 0 && v(!0), t > 0 && v(!1)),
              this.setIndex(l),
              this.setAttribute("position", new At(h, 3)),
              this.setAttribute("normal", new At(u, 3)),
              this.setAttribute("uv", new At(p, 2));
          }
        })(30, 30, 35.4, 100, 1, !0, 0.5 * Math.PI, Math.PI),
        P_
      );
      j_.position.z = -27.5;
      let F_ = new Mr();
      (F_.position.z = 0.05), F_.add(k_, C_, O_, N_, I_), m_.add(D_, F_);
      const H_ = new Ar({ canvas: Ug, antialias: !0, alpha: !0 });
      H_.setSize(v_.width, v_.height),
        H_.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      const B_ = new Ar({ canvas: Gg, antialias: !0, alpha: !0 });
      B_.setSize(v_.width, v_.height),
        B_.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      let z_ = new tm(B_),
        U_ = new im(g_, __);
      z_.addPass(U_);
      let G_ = new Kf({
        uniforms: {
          tDiffuse: { value: null },
          amount: { value: 0 },
          intensity: { value: 0.08 },
        },
        vertexShader:
          "    varying vec2 vUv;\r\n    void main() {\r\n      vUv = uv;\r\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n    }",
        fragmentShader:
          "    uniform float amount;\r\n    uniform float intensity;\r\n    uniform sampler2D tDiffuse;\r\n    varying vec2 vUv;\r\n  \r\n    float random( vec2 p )\r\n    {\r\n      vec2 K1 = vec2(\r\n        23.14069263277926, // e^pi (Gelfond's constant)\r\n        2.665144142690225 // 2^sqrt(2) (GelfondSchneider constant)\r\n      );\r\n      return fract( cos( dot(p,K1) ) * 12345.6789 );\r\n    }\r\n  \r\n    void main() {\r\n  \r\n      vec4 color = texture2D( tDiffuse, vUv );\r\n      vec2 uvRandom = vUv;\r\n      uvRandom.y *= random(vec2(uvRandom.y,amount));\r\n      color.rgb += random(uvRandom)*intensity; \r\n      gl_FragColor = vec4(color);\r\n    }",
      });
      function W_() {
        window.matchMedia("(max-width: 767px)").matches
          ? (Sd.to(".menuReveal .linkWrapper--2 .link", 0.75, {
              opacity: 0,
              clipPath: "inset(100% 0% 0% 0%)",
              transform: "translateY(-125px)",
              stagger: { each: 0.05, from: "start" },
              ease: "power3.in",
            }),
            Sd.to(".menuReveal .linkWrapper--1 .media", 0.75, {
              opacity: 0,
              clipPath: "inset(100% 0% 0% 0%)",
              transform: "translateY(-125px)",
              stagger: { each: 0.025, from: "start" },
              ease: "power3.in",
            }),
            Sd.to(".menuReveal .linkWrapper--2 .link", 0, {
              clipPath: "inset(0% 0% 100% 0%)",
              transform: "translateY(125px)",
              delay: 1.25,
            }),
            Sd.to(".menuReveal .linkWrapper--1 .media", 0, {
              clipPath: "inset(0% 0% 100% 0%)",
              transform: "translateY(125px)",
              delay: 1.25,
            }))
          : (Sd.to(".menuReveal .linkWrapper--2 .link", 0.75, {
              opacity: 0,
              clipPath: "inset(100% 0% 0% 0%)",
              transform: "translateY(-250px)",
              stagger: { each: 0.05, from: "start" },
              ease: "power3.in",
            }),
            Sd.to(".menuReveal .linkWrapper--1 .media", 0.75, {
              opacity: 0,
              clipPath: "inset(100% 0% 0% 0%)",
              transform: "translateY(-250px)",
              stagger: { each: 0.025, from: "start" },
              ease: "power3.in",
            }),
            Sd.to(".menuReveal .linkWrapper--2 .link", 0, {
              clipPath: "inset(0% 0% 100% 0%)",
              transform: "translateY(250px)",
              delay: 1.25,
            }),
            Sd.to(".menuReveal .linkWrapper--1 .media", 0, {
              clipPath: "inset(0% 0% 100% 0%)",
              transform: "translateY(250px)",
              delay: 1.25,
            }));
      }
      function V_() {
        "home" == gy &&
          (Sd.to(E_, 0.75, { opacity: 0, ease: "power3" }),
          Sd.to(T_, 0.75, { opacity: 0, ease: "power3" }),
          Sd.to(".container--home", 0.75, { opacity: 0, ease: "power3" }),
          Sd.to(".container--home", 0, {
            transform: "scale(1.17)",
            delay: 0.75,
          }),
          Sd.to(".homeLink", 0.75, { opacity: 0, ease: "power3" }),
          setTimeout(function () {
            m_.remove(F_, L_),
              Sd.to(".menuReveal .linkWrapper--2 .link", 1, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                transform: "translateY(0)",
                stagger: 0.05,
                ease: "power3",
              }),
              Sd.to(".menuReveal .linkWrapper--1 .media", 1, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                transform: "translateY(0)",
                stagger: 0.025,
                ease: "power3",
              });
          }, 750)),
          "work" == gy &&
            ((wy = !0),
            Sd.to(".projectName", 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(".projectCat", 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(".projectName", 0, { transform: "scale(1.17)", delay: 0.75 }),
            Sd.to(".projectCat", 0, { transform: "scale(1.17)", delay: 0.75 }),
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
              navigator.userAgent
            ) || window.matchMedia("(max-width: 1024px)").matches
              ? (Sd.to(E_, 0.75, { opacity: 0, ease: "power3" }),
                setTimeout(function () {
                  m_.remove(F_);
                }, 750))
              : (setTimeout(function () {
                  m_.remove(j_);
                }, 750),
                Sd.to(P_.uniforms.u_alpha, 0.75, { value: 0, ease: "power3" }),
                Sd.to(".projectName .mask--1 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "end" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--2 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "start" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--3 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "end" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--4 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "start" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--5 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "end" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--6 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "start" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--7 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "end" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--8 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "start" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--9 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "end" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--10 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "start" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--11 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "end" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--12 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "start" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--13 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "end" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--14 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "start" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--15 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "end" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--16 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "start" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--17 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "end" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--18 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "start" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--19 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "end" },
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--20 .char", 0.5, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  stagger: { each: Py, from: "start" },
                  ease: "power3",
                })),
            setTimeout(function () {
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent
              ) ||
                window.matchMedia("(max-width: 1024px)").matches ||
                ((P_.uniforms.u_texture1.value = gg),
                (P_.uniforms.u_texture2.value = yg),
                Sd.to(P_.uniforms.u_dispFactor, 0.75, {
                  value: 0,
                  ease: "power3",
                })),
                Sd.to(".menuReveal .linkWrapper--2 .link", 1, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  transform: "translateY(0)",
                  stagger: 0.05,
                  ease: "power3",
                }),
                Sd.to(".menuReveal .linkWrapper--1 .media", 1, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  transform: "translateY(0)",
                  stagger: 0.025,
                  ease: "power3",
                }),
                Mv.forEach((e) => {
                  e.style.display = "none";
                });
            }, 750)),
          "about" == gy &&
            ((wy = !0),
            Sd.to(E_, 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(".container--about .title", 0.75, {
              opacity: 0,
              ease: "power3",
            }),
            Sd.to(".container--about .aboutWrapper", 0.75, {
              opacity: 0,
              ease: "power3",
            }),
            Sd.to(".container--about .scrollIndication", 0.75, {
              opacity: 0,
              ease: "power3",
            }),
            Sd.to(".container--about .title", 0, {
              transform: "scale(1.17)",
              delay: 0.75,
            }),
            Sd.to(".container--about .aboutWrapper", 0, {
              transform: "scale(1.17)",
              delay: 0.75,
            }),
            setTimeout(function () {
              m_.remove(F_, L_),
                Sd.to(".menuReveal .linkWrapper--2 .link", 1, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  transform: "translateY(0)",
                  stagger: 0.05,
                  ease: "power3",
                }),
                Sd.to(".menuReveal .linkWrapper--1 .media", 1, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  transform: "translateY(0)",
                  stagger: 0.025,
                  ease: "power3",
                });
            }, 750)),
          ("home" != gy && "about" != gy && "work" != gy) ||
            (ew.stop(),
            Jg.classList.add("switch"),
            Kg.classList.add("switch"),
            $g.classList.add("switch"),
            (Yg.style.pointerEvents = "none"),
            ov.forEach((e) => {
              e.style.pointerEvents = "none";
            }),
            (Xg.style.zIndex = "1"),
            (Xg.style.pointerEvents = "all"),
            (Ay = !0),
            Sd.to(y_.position, 0.75, { z: 1, delay: 0.5 }),
            setTimeout(function () {
              ew.scrollTo("top", 0),
                ew.update(),
                Jf.refresh(),
                iv.classList.add("switch"),
                rv.classList.add("switch"),
                ev.classList.add("switch"),
                tv.classList.add("switch"),
                Zg.classList.add("switch"),
                Qg.classList.add("switch"),
                setTimeout(function () {
                  (Yg.style.pointerEvents = "all"), (yy = !0);
                }, 700);
            }, 750)),
          "workReveal" == gy &&
            (setTimeout(function () {
              Jg.classList.add("switch"),
                Kg.classList.add("switch"),
                $g.classList.add("switch"),
                nv.forEach((e) => {
                  e.classList.add("switchHeight");
                }),
                av.forEach((e) => {
                  e.classList.add("switchHeight");
                });
            }, 750),
            (Yg.style.pointerEvents = "none"),
            setTimeout(function () {
              ev.classList.add("switch"),
                tv.classList.add("switch"),
                tv.classList.add("switch"),
                iv.classList.add("switch"),
                rv.classList.add("switch"),
                Zg.classList.add("switch"),
                Qg.classList.add("switch"),
                m_.remove(j_),
                setTimeout(function () {
                  (Yg.style.pointerEvents = "all"), (yy = !0);
                }, 2500);
            }, 2250)),
          "showreel" == gy && Y_();
      }
      function q_() {
        ew.stop(),
          "home" == gy &&
            (m_.add(F_, L_),
            setTimeout(function () {
              Sd.to(E_, 1.5, { opacity: 0.15, ease: "power3" }),
                Sd.to(T_, 1.5, { opacity: 1, ease: "power3" }),
                Sd.to(".container--home", 1.5, {
                  opacity: 1,
                  transform: "scale(1)",
                  ease: "power3",
                }),
                Sd.to(".homeLink", 1, {
                  opacity: 0.6,
                  ease: "power3",
                  delay: 0.55,
                }),
                (gv.style.display = "flex"),
                (vv.style.display = "none"),
                (yv.style.display = "none"),
                setTimeout(function () {
                  ov.forEach((e) => {
                    e.style.pointerEvents = "all";
                  });
                }, 750);
            }, 1e3)),
          "about" == gy &&
            (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
              navigator.userAgent
            ) || window.matchMedia("(max-width: 1024px)").matches
              ? (Sd.to(".heySection span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(50px)",
                }),
                Sd.to(".container--about .title--about span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform:
                    "translateY(125px) rotateX(-90deg) rotateY(-45deg) rotateZ(-45deg)",
                }),
                Sd.to(".aboutWrapper--2 p", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  transform: "translateY(25px)",
                  opacity: 0,
                }),
                Sd.to(".container--about .title--course span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform:
                    "translateY(125px) rotateX(-90deg) rotateY(-45deg) rotateZ(-45deg)",
                }),
                Sd.to(".courseSection--1 p", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  transform: "translateY(25px)",
                  opacity: 0,
                }),
                Sd.to(".courseSection--2 p", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  transform: "translateY(25px)",
                  opacity: 0,
                }),
                Sd.to(".courseSection--3 p", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  transform: "translateY(25px)",
                  opacity: 0,
                }),
                Sd.to(".container--about .title--skills span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform:
                    "translateY(125px) rotateX(-90deg) rotateY(-45deg) rotateZ(-45deg)",
                }),
                Sd.to(".skillsSection--1 span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(125px)",
                }),
                Sd.to(".skillsSection--1 li", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(25px)",
                }),
                Sd.to(".skillsSection--2 span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(125px)",
                }),
                Sd.to(".skillsSection--2 li", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(25px)",
                }),
                Sd.to(".skillsSection--3 span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(125px)",
                }),
                Sd.to(".skillsSection--3 li", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(25px)",
                }))
              : (Sd.to(".heySection span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(250px)",
                }),
                Sd.to(".container--about .title--about span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform:
                    "translateY(250px) rotateX(-90deg) rotateY(-45deg) rotateZ(-45deg)",
                }),
                Sd.to(".aboutWrapper--2 p", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  transform: "translateY(50px)",
                  opacity: 0,
                }),
                Sd.to(".container--about .title--course span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform:
                    "translateY(250px) rotateX(-90deg) rotateY(-45deg) rotateZ(-45deg)",
                }),
                Sd.to(".courseSection--1 p", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  transform: "translateY(50px)",
                  opacity: 0,
                }),
                Sd.to(".courseSection--2 p", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  transform: "translateY(50px)",
                  opacity: 0,
                }),
                Sd.to(".courseSection--3 p", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  transform: "translateY(50px)",
                  opacity: 0,
                }),
                Sd.to(".container--about .title--skills span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform:
                    "translateY(250px) rotateX(-90deg) rotateY(-45deg) rotateZ(-45deg)",
                }),
                Sd.to(".skillsSection--1 span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(250px)",
                }),
                Sd.to(".skillsSection--1 li", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(50px)",
                }),
                Sd.to(".skillsSection--2 span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(250px)",
                }),
                Sd.to(".skillsSection--2 li", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(50px)",
                }),
                Sd.to(".skillsSection--3 span", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(250px)",
                }),
                Sd.to(".skillsSection--3 li", 0, {
                  clipPath: "inset(0% 0% 100% 0%)",
                  opacity: 0,
                  transform: "translateY(50px)",
                })),
            m_.add(F_, L_),
            Wv.forEach((e) => {
              e.style.pointerEvents = "all";
            }),
            setTimeout(function () {
              Sd.to(E_, 1.5, { opacity: 0.15, ease: "power3" }),
                Sd.to(".container--about .title", 1.5, {
                  opacity: 1,
                  transform: "scale(1)",
                  ease: "power3",
                }),
                Sd.to(".container--about .aboutWrapper", 1.5, {
                  opacity: 1,
                  transform: "scale(1)",
                  ease: "power3",
                }),
                Sd.to(".container--about .scrollIndication", 1, {
                  opacity: 1,
                  ease: "power3",
                  delay: 0.55,
                }),
                setTimeout(function () {
                  ew.start(), (wy = !1);
                }, 700),
                (gv.style.display = "none"),
                (vv.style.display = "flex"),
                (yv.style.display = "none");
            }, 1e3)),
          "work" == gy &&
            (Mv.forEach((e) => {
              e.style.display = "flex";
            }),
            m_.add(j_),
            (_y = !1),
            setTimeout(function () {
              Sd.to(".projectName", 1.5, {
                opacity: 1,
                transform: "scale(1)",
                ease: "power3",
              }),
                Sd.to(".projectCat", 1.5, {
                  opacity: 1,
                  transform: "scale(1)",
                  ease: "power3",
                }),
                Sd.to(".projectName .mask--1 .char", 0.5, {
                  opacity: 0,
                  clipPath: "inset(100% 0% 0% 0%)",
                  stagger: { each: Py, from: "end" },
                  ease: "power3",
                }),
                setTimeout(function () {
                  ew.start();
                }, 300),
                /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                  navigator.userAgent
                ) || window.matchMedia("(max-width: 1024px)").matches
                  ? (Sd.to(E_, 1.5, { opacity: 0.15, ease: "power3" }),
                    m_.add(F_))
                  : ((P_.uniforms.u_texture1.value = gg),
                    (P_.uniforms.u_texture2.value = yg),
                    Sd.to(P_.uniforms.u_dispFactor, 1.5, {
                      value: 1,
                      ease: "power3",
                    }),
                    Sd.to(P_.uniforms.u_alpha, 1.5, {
                      value: 0.35,
                      ease: "power3",
                    })),
                (wy = !1),
                (gv.style.display = "none"),
                (vv.style.display = "none"),
                (yv.style.display = "flex"),
                m_.remove(L_);
            }, 1e3),
            setTimeout(() => {
              _y = !0;
            }, 1750)),
          ("home" != gy && "about" != gy && "work" != gy) ||
            (W_(),
            (Ay = !1),
            (Xg.style.pointerEvents = "none"),
            Zg.classList.remove("switch"),
            Qg.classList.remove("switch"),
            ev.classList.remove("switch"),
            tv.classList.remove("switch"),
            iv.classList.remove("switch"),
            rv.classList.remove("switch"),
            (Yg.style.pointerEvents = "none"),
            setTimeout(function () {
              Jg.classList.remove("switch"),
                Kg.classList.remove("switch"),
                $g.classList.remove("switch"),
                ew.update(),
                Jf.refresh(),
                setTimeout(function () {
                  (Xg.style.zIndex = "-1"),
                    (Yg.style.pointerEvents = "all"),
                    (yy = !1);
                }, 700),
                Sd.to(y_.position, 1.5, { z: 1.5, ease: "power3" });
            }, 1e3)),
          "workReveal" == gy &&
            ((gy = "work"),
            m_.add(j_),
            Sd.to(A_, 1.5, { opacity: 0.015, ease: "power3", delay: 1.25 }),
            Sd.to(A_.color, 1.5, {
              r: x_.r,
              g: x_.g,
              b: x_.b,
              ease: "power3",
              delay: 1.25,
            }),
            (_y = !1),
            Wv.forEach((e) => {
              e.style.pointerEvents = "none";
            }),
            Sd.to(".workRevealContainer", 0.75, { opacity: 0, ease: "power3" }),
            Zg.classList.remove("switch"),
            Qg.classList.remove("switch"),
            ev.classList.remove("switch"),
            tv.classList.remove("switch"),
            iv.classList.remove("switch"),
            rv.classList.remove("switch"),
            nv.forEach((e) => {
              e.classList.remove("switchHeight");
            }),
            av.forEach((e) => {
              e.classList.remove("switchHeight");
            }),
            (Yg.style.pointerEvents = "none"),
            setTimeout(function () {
              setTimeout(function () {
                Jg.classList.remove("switch"),
                  Kg.classList.remove("switch"),
                  $g.classList.remove("switch"),
                  (yy = !1),
                  setTimeout(function () {
                    Yg.style.pointerEvents = "all";
                  }, 1250);
              }, 700),
                ew.update(),
                Jf.refresh(),
                setTimeout(function () {
                  (_y = !0), ew.start(), (wy = !1);
                }, 2e3),
                setTimeout(function () {
                  (d_.color = "#b1b1b1"),
                    Sd.to(".musicWrapper", 0.1, { opacity: 0, ease: "power3" }),
                    Sd.to(".musicWrapper", 0.1, {
                      opacity: 1,
                      ease: "power3",
                      delay: 0.1,
                    });
                }, 210),
                Sd.to(".projectName", 1.5, {
                  opacity: 1,
                  transform: "scale(1)",
                  ease: "power3",
                  delay: 1.25,
                }),
                Sd.to(".projectCat", 1.5, {
                  opacity: 1,
                  transform: "scale(1)",
                  ease: "power3",
                  delay: 1.25,
                }),
                /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                  navigator.userAgent
                ) || window.matchMedia("(max-width: 1024px)").matches
                  ? (Sd.to(E_, 1.5, {
                      opacity: 0.15,
                      ease: "power3",
                      delay: 1.25,
                    }),
                    Sd.to(".workRevealContainer .titleProject .title--2", 0, {
                      opacity: 0,
                      clipPath: "inset(0% 0% 100% 0%)",
                      transform: "translateY(75px)",
                    }),
                    Sd.to(".workRevealContainer .linkProject a", 0, {
                      opacity: 0,
                      clipPath: "inset(0% 0% 100% 0%)",
                      transform: "translateY(25px)",
                    }),
                    Sd.to(qv, 0, {
                      transform: "translateY(75px)",
                      opacity: 0,
                      clipPath: "inset(0% 0% 100% 0%)",
                    }),
                    Sd.to(".workRevealWrapper .section--2 img", 0, {
                      opacity: 0,
                      clipPath: "inset(0% 0% 100% 0%)",
                      transform: "translateY(75px)",
                    }))
                  : (Sd.to(P_.uniforms.u_alpha, 1.5, {
                      value: 0.35,
                      ease: "power3",
                      delay: 0.5,
                    }),
                    Sd.to(P_.uniforms.u_mouseIntensity, 1.5, {
                      value: 0.01,
                      ease: "power3",
                      delay: 0.5,
                    }),
                    Sd.to(P_.uniforms.u_mouseRange, 1.5, {
                      value: 20,
                      ease: "power3",
                      delay: 0.5,
                    }),
                    Sd.to(".workRevealContainer .titleProject .title--2", 0, {
                      opacity: 0,
                      clipPath: "inset(0% 0% 100% 0%)",
                      transform: "translateY(150px)",
                    }),
                    Sd.to(".workRevealContainer .linkProject a", 0, {
                      opacity: 0,
                      clipPath: "inset(0% 0% 100% 0%)",
                      transform: "translateY(50px)",
                    }),
                    Sd.to(qv, 0, {
                      transform: "translateY(150px)",
                      opacity: 0,
                      clipPath: "inset(0% 0% 100% 0%)",
                    }),
                    Sd.to(".workRevealWrapper .section--2 img", 0, {
                      opacity: 0,
                      clipPath: "inset(0% 0% 100% 0%)",
                      transform: "translateY(150px)",
                    })),
                Sd.to(_v, 0, { clipPath: "inset(0% 0% 100% 0%)" }),
                Sd.to(_v, 0, { clipPath: "inset(100% 0% 0% 0%)", delay: 1.25 }),
                Jv.forEach((e) => {
                  e.innerHTML = "";
                }),
                (qv.innerHTML = ""),
                (Yv.innerHTML = ""),
                (wv.style.display = "none"),
                Sd.to(".workRevealContainer .title--1", 0, {
                  transform: "scale(1.17)",
                });
            }, 750)),
          "showreel" == gy && J_();
      }
      function X_() {
        if (((gy = "workReveal"), 1 == _y)) {
          switch (
            (V_(),
            ew.stop(),
            Wv.forEach((e) => {
              e.style.pointerEvents = "all";
            }),
            (wy = !0),
            dy)
          ) {
            case "id2021":
              Jv.forEach((e) => {
                e.innerHTML = "ID 2021";
              }),
                (qv.innerHTML =
                  "Immersions Digitales 2021 is a WebGl experience created in order to introduce the open days of the year from my technical faculty in Tarbes (France). We were three to work on this project, including a 3D modeler and two developers. As a developer, I imagined and developed a large part of 2D/3D animations and the micro interactions. We were awarded by an honorable mention on Awwwards.<br><br>Technologies used :<br>HTML, SCSS, JavaScript, Three.js, GLSL, GSAP"),
                (Xv.src = "./textures/img/idWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://www.immersions-digitales.fr/" target="_blank">Launch Website</a>');
              break;
            case "astralys":
              Jv.forEach((e) => {
                e.innerHTML = "ASTRALYS";
              }),
                (qv.innerHTML =
                  "Astralys is a WebGl experience originally created as part of a university project. Its purpose is to show our solar system on scale, with several informations on the different elements that compose it. I was in charge of developing the whole website.<br><br>Technologies used :<br>HTML, CSS, JavaScript, Three.js"),
                (Xv.src = "./textures/img/astralysWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://astralys.thomalecornu.fr/" target="_blank">Launch Website</a>');
              break;
            case "terreDeBois":
              Jv.forEach((e) => {
                e.innerHTML = "TERRE DE BOIS";
              }),
                (qv.innerHTML =
                  "Proposal of a new corporate identity for a company named Terre de Bois. This corporation is  a cooperative of eco-builders with 20 years of expertise in construction industry.<br><br>Software used :<br>Adobe Illustrator"),
                (Xv.src = "./textures/img/terreDeBoisWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://www.behance.net/gallery/114896841/Terre-de-Bois" target="_blank">See on Behance</a>');
              break;
            case "auriane":
              Jv.forEach((e) => {
                e.innerHTML = "AURIANE";
              }),
                (qv.innerHTML =
                  "Portfolio created in two days for a friend. Through this project, I sought to reproduce minimalists design and animations. Layout inspired by Paul & Henriette website from Aristide Benoist.<br><br>Technologies used :<br>HTML, SCSS, JavaScript, Locomotive Scroll"),
                (Xv.src = "./textures/img/aurianeWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://auriane.thomalecornu.fr/" target="_blank">Launch Website</a>');
              break;
            case "cmsFolio":
              Jv.forEach((e) => {
                e.innerHTML = "CMS FOLIO";
              }),
                (qv.innerHTML =
                  "CMS folio is a web development project with a content management system. The website uses a database to alter and add dynamically the content of each project.</br></br>Technologies used :</br>PHP, SQL, HTML, CSS"),
                (Xv.src = "./textures/img/cmsFolioWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://cmsfolio.thomalecornu.fr/" target="_blank">Launch Website</a>');
              break;
            case "newspaper":
              Jv.forEach((e) => {
                e.innerHTML = "NEWSPAPER";
              }),
                (qv.innerHTML =
                  "Newspaper is a 3D motion design video. The purpose was to create in group, a newspaper of one week, in any support of our choice. I imagined and created the video, inspired by BBC.</br></br>Softwares used :</br>Adobe After Effects, Trapcode Particular"),
                (Xv.src = "./textures/img/newspaperWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://www.behance.net/gallery/114896361/Newspaper" target="_blank">Watch on Behance</a>');
              break;
            case "jamOn":
              Jv.forEach((e) => {
                e.innerHTML = "JAM-ON";
              }),
                (qv.innerHTML =
                  "JAM-ON is a web model created for a graphic design project. The purpose was to create a graphic identity for a jam website, targeting a population under 25 years old.<br><br>Software used :<br>Adobe XD"),
                (Xv.src = "./textures/img/jamOnWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://www.behance.net/gallery/114896117/JAM-ON" target="_blank">See on Behance</a>');
              break;
            case "folio2020":
              Jv.forEach((e) => {
                e.innerHTML = "FOLIO 2020";
              }),
                (qv.innerHTML =
                  "This is my personal portfolio for 2020. Layout inspired by Richard Mattka's portfolio.</br></br>Technologies used :</br>HTML, CSS, JavaScript, PHP"),
                (Xv.src = "./textures/img/folio2020Work.jpg"),
                (Yv.innerHTML =
                  '<a href="https://folio2020.thomalecornu.fr/" target="_blank">Launch Website</a>');
              break;
            case "internship":
              Jv.forEach((e) => {
                e.innerHTML = "INTERNSHIP";
              }),
                (qv.innerHTML =
                  "At the end of my first year internship at GSP Publicit, we had to do a video of presentation. I chosed motion design, because in my opinion, this is what illustrates the best the company and the tasks they are performing.<br><br>Software used :<br>Adobe After Effects"),
                (Xv.src = "./textures/img/internshipWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://www.behance.net/gallery/114895861/Internship" target="_blank">Watch on Behance</a>');
              break;
            case "gamovore":
              Jv.forEach((e) => {
                e.innerHTML = "GAMOVORE";
              }),
                (qv.innerHTML =
                  "Gamovore is a dynamic web project. The goal was to create an encyclopedia, which references video games by categories and classes with a rating.</br></br>Technologies used :</br>PHP, HTML, CSS"),
                (Xv.src = "./textures/img/gamovoreWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://gamovore.thomalecornu.fr/" target="_blank">Launch Website</a>');
              break;
            case "dresson":
              Jv.forEach((e) => {
                e.innerHTML = "DRESSON";
              }),
                (qv.innerHTML =
                  "DressOn is a web model produced during a project management course. The objective was to create a brand image of our choice with a graphic identity of its own.<br><br>Software used :<br>Adobe XD"),
                (Xv.src = "./textures/img/dressOnWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://www.behance.net/gallery/114895709/DressOn" target="_blank">See on Behance</a>');
              break;
            case "mmorpion":
              Jv.forEach((e) => {
                e.innerHTML = "MMORPION";
              }),
                (qv.innerHTML =
                  "MMORPION is a dynamic web project. The aim was to recreate the famous game of noughts and crosses in PHP.</br></br>Technologies used :</br>PHP, HTML, CSS"),
                (Xv.src = "./textures/img/mmorpionWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://mmorpion.thomalecornu.fr/" target="_blank">Launch Website</a>');
              break;
            case "mushrooms":
              Jv.forEach((e) => {
                e.innerHTML = "MUSHROOMS";
              }),
                (qv.innerHTML =
                  "Accomplishment of several mushrooms inspired by the famous game Mario. We had to do three, with the character design of our choice.<br><br>Software used :<br>Adobe Illustrator"),
                (Xv.src = "./textures/img/mushroomsWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://www.behance.net/gallery/114895327/Mushrooms" target="_blank">See on Behance</a>');
              break;
            case "yasuo":
              Jv.forEach((e) => {
                e.innerHTML = "YASUO";
              }),
                (qv.innerHTML =
                  "Yasuo is a 3D animation made during my free time.<br><br>Softwares used :<br>Adobe After Effects, Trapcode Particular, Plexus"),
                (Xv.src = "./textures/img/3dBackgroundWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://www.behance.net/gallery/114895183/Yasuo" target="_blank">Watch on Behance</a>');
              break;
            case "folio2019":
              Jv.forEach((e) => {
                e.innerHTML = "FOLIO 2019";
              }),
                (qv.innerHTML =
                  "This is my personal portfolio for 2019.</br></br>Technologies used :</br>HTML, CSS"),
                (Xv.src = "./textures/img/folio2019Work.jpg"),
                (Yv.innerHTML =
                  '<a href="http://folio2019.thomalecornu.fr/" target="_blank">Launch Website</a>');
              break;
            case "laDette":
              Jv.forEach((e) => {
                e.innerHTML = "LA DETTE";
              }),
                (qv.innerHTML =
                  "Group work as part of a communication course, we had to do a multimedia content to explain the appearance of debt. I made the video entirely in motion design to make the subject as clear as possible.<br><br>Softwares used :<br>Adobe After Effects, Trapcode Particular"),
                (Xv.src = "./textures/img/laDetteWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://www.behance.net/gallery/114895015/Aux-origines-de-la-dette" target="_blank">Watch on Behance</a>');
              break;
            case "animayo":
              Jv.forEach((e) => {
                e.innerHTML = "ANIMAYO";
              }),
                (qv.innerHTML =
                  "Animayo is an animation, visual effects and video game festival. I made this design as part of a spanish class, for the dream-themed illustration contest.<br><br>Software used :<br>Adobe Illustrator"),
                (Xv.src = "./textures/img/animayoWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://www.behance.net/gallery/114894841/Animayo" target="_blank">See on Behance</a>');
              break;
            case "outroId":
              Jv.forEach((e) => {
                e.innerHTML = "OUTRO ID";
              }),
                (qv.innerHTML =
                  "Outro ID is an animation produced for the Immersions Digitales 2020 teaser and the TV studio workshop.<br><br>Softwares used :<br>Adobe After Effects, Trapcode Particular"),
                (Xv.src = "./textures/img/outroIdWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://www.behance.net/gallery/114894651/Outro-ID" target="_blank">Watch on Behance</a>');
              break;
            case "letterMask":
              Jv.forEach((e) => {
                e.innerHTML = "LETTER MASK";
              }),
                (qv.innerHTML =
                  "Letter mask is an illustration made for a design class. The goal was to inlay a character in a letter, using layers masks.<br><br>Software used :<br>Adobe Photoshop"),
                (Xv.src = "./textures/img/letterMaskWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://www.behance.net/gallery/114894027/Letter-mask" target="_blank">See on Behance</a>');
              break;
            case "motionIntro":
              Jv.forEach((e) => {
                e.innerHTML = "MOTION INTRO";
              }),
                (qv.innerHTML =
                  "Motion intro is a motion design animation made during my free time.<br><br>Software used :<br>Adobe After Effects"),
                (Xv.src = "./textures/img/motionIntroWork.jpg"),
                (Yv.innerHTML =
                  '<a href="https://www.behance.net/gallery/114893481/Motion-intro" target="_blank">Watch on Behance</a>');
          }
          let e = document.querySelectorAll(
            ".workRevealContainer .linkProject a"
          );
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) || window.matchMedia("(max-width: 1024px)").matches
            ? Sd.to(E_, 0.75, { opacity: 0, ease: "power3" })
            : (Sd.to(P_.uniforms.u_mouseIntensity, 5, {
                value: 0.25,
                ease: "power3",
              }),
              Sd.to(P_.uniforms.u_mouseRange, 5, {
                value: 100,
                ease: "power3",
              }),
              Sd.to(P_.uniforms.u_alpha, 0.75, {
                value: 0,
                ease: "power3",
                delay: 0.75,
              }),
              l_(e)),
            (wv.style.display = "flex"),
            Sd.to(".projectName", 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(".projectCat", 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(".workRevealContainer", 0, { opacity: 1, ease: "power3" }),
            setTimeout(function () {
              Sd.to(".projectName", 0, { transform: "scale(1.17)" }),
                Sd.to(".projectCat", 0, { transform: "scale(1.17)" }),
                setTimeout(function () {
                  (d_.color = "#151617"),
                    Sd.to(".musicWrapper", 0.1, { opacity: 0, ease: "power3" }),
                    Sd.to(".musicWrapper", 0.1, {
                      opacity: 1,
                      ease: "power3",
                      delay: 0.1,
                    });
                }, 210),
                Sd.to(".workRevealContainer .title--1", 1.5, {
                  opacity: 1,
                  transform: "scale(1)",
                  ease: "power3",
                  delay: 0.5,
                }),
                Sd.to(".workRevealContainer .title--1", 1.5, {
                  opacity: 0,
                  ease: "power3",
                  delay: 1.25,
                }),
                Sd.to(".workRevealContainer .titleProject .title--2", 1, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  transform: "translateY(0)",
                  ease: "power3",
                  delay: 2.25,
                }),
                Sd.to(qv, 1, {
                  opacity: 1,
                  transform: "translateY(0)",
                  clipPath: "inset(0% 0% 0% 0%)",
                  ease: "power3",
                  delay: 2.5,
                }),
                Sd.to(".workRevealWrapper .section--2 img", 1, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  transform: "translateY(0)",
                  ease: "power3",
                  delay: 2.5,
                }),
                Sd.to(".workRevealContainer .linkProject a", 1, {
                  opacity: 1,
                  clipPath: "inset(0% 0% 0% 0%)",
                  transform: "translateY(0)",
                  ease: "power3",
                  delay: 2.75,
                }),
                Sd.to(_v, 0, { clipPath: "inset(0% 0% 0% 0%)" }),
                /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                  navigator.userAgent
                ) || window.matchMedia("(max-width: 1024px)").matches
                  ? (Sd.to(A_, 1.5, {
                      opacity: 0.025,
                      ease: "power3",
                      delay: 0.25,
                    }),
                    Sd.to(A_.color, 1.5, {
                      r: b_.r,
                      g: b_.g,
                      b: b_.b,
                      ease: "power3",
                      delay: 0.25,
                    }))
                  : (Sd.to(A_, 1.5, {
                      opacity: 0.035,
                      ease: "power3",
                      delay: 0.25,
                    }),
                    Sd.to(A_.color, 1.5, {
                      r: b_.r,
                      g: b_.g,
                      b: b_.b,
                      ease: "power3",
                      delay: 0.25,
                    }));
            }, 1500);
        }
      }
      function Y_() {
        ew.stop(),
          (gy = "showreel"),
          (My = !1),
          (Yg.style.pointerEvents = "none"),
          bv.classList.add("switch"),
          ov.forEach((e) => {
            e.style.pointerEvents = "none";
          }),
          (d_.button.style.pointerEvents = "none"),
          (zg.style.pointerEvents = "none"),
          (Xg.style.pointerEvents = "none"),
          Sd.to(".hamburgerWrapper", 0, { opacity: 1, delay: 2 }),
          Sd.to(Qv, 0.5, { opacity: 1, ease: "power3.in" }),
          Sd.to(Kv, 0.5, {
            opacity: 1,
            padding: "0px",
            borderRadius: "0%",
            ease: "power3.in",
          }),
          Sd.to(".octagon", 0.5, {
            background: "rgba(177, 177, 177, 0)",
            ease: "power3.in",
          }),
          Sd.to(".cursorLoader", 0.5, { opacity: 0, ease: "power3.in" }),
          Sd.to(ey, 0.5, {
            opacity: 0.5,
            padding: "0px",
            borderRadius: "0%",
            ease: "power3.in",
          }),
          Sd.to(".container--home", 0, {
            transform: "scale(1.17)",
            delay: 2.25,
          }),
          Sd.to(E_, 0, { opacity: 0, delay: 2.25 }),
          Sd.to(T_, 0, { opacity: 0, delay: 2.25 }),
          xv.play(),
          setTimeout(function () {
            Sd.to(".showreelRevealContainer", 0, {
              clipPath: "inset(0% 0% 0% 0%)",
              opacity: 1,
              ease: "power3",
            }),
              setTimeout(function () {
                Jg.classList.add("switch"),
                  Kg.classList.add("switch"),
                  $g.classList.add("switch"),
                  o_.fade(0, 0, 1e3);
              }, 250),
              setTimeout(function () {
                iv.classList.add("switch"),
                  rv.classList.add("switch"),
                  ev.classList.add("switch"),
                  tv.classList.add("switch"),
                  Zg.classList.add("switch"),
                  Qg.classList.add("switch"),
                  (Xg.style.zIndex = "-1"),
                  Sd.to(y_.position, 0, { z: 1 }),
                  m_.remove(F_, L_),
                  setTimeout(function () {
                    (yy = !0), (Yg.style.pointerEvents = "all");
                  }, 700);
              }, 750);
          }, 1e3);
      }
      function J_() {
        Sd.to(".showreelRevealContainer", 0.75, { opacity: 0, ease: "power3" }),
          Sd.to(".showreelRevealContainer", 0, {
            clipPath: "inset(50% 0% 50% 0%)",
            delay: 1,
          }),
          m_.add(F_, L_),
          (wy = !0),
          (Xg.style.zIndex = "-1"),
          (gv.style.display = "flex"),
          (vv.style.display = "none"),
          (yv.style.display = "none"),
          1 == a_ && o_.fade(0, 0.5, 1e3),
          (gy = "home"),
          Zg.classList.remove("switch"),
          Qg.classList.remove("switch"),
          ev.classList.remove("switch"),
          tv.classList.remove("switch"),
          iv.classList.remove("switch"),
          rv.classList.remove("switch"),
          (Yg.style.pointerEvents = "none"),
          setTimeout(function () {
            xv.pause(), (xv.currentTime = 0), bv.classList.remove("switch");
          }, 750),
          setTimeout(function () {
            Sd.to(E_, 1.5, { opacity: 0.15, ease: "power3" }),
              Sd.to(T_, 1.5, { opacity: 1, ease: "power3" }),
              Sd.to(".container--home", 1.5, {
                opacity: 1,
                transform: "scale(1)",
                ease: "power3",
              }),
              Sd.to(".musicWrapper", 1.5, { opacity: 1, ease: "power3" }),
              Sd.to("#app", 1.5, { opacity: 1, ease: "power3" }),
              Sd.to(".homeLink", 1, {
                opacity: 0.6,
                ease: "power3",
                delay: 0.55,
              }),
              Sd.to(".container--about .title", 0, {
                opacity: 0,
                transform: "scale(1.17)",
              }),
              Sd.to(".container--about .aboutWrapper", 0, {
                opacity: 0,
                transform: "scale(1.17)",
              }),
              Sd.to(".container--about .scrollIndication", 0, { opacity: 0 }),
              Sd.to(y_.position, 1.5, { z: 1.5, ease: "power3" }),
              Jg.classList.remove("switch"),
              Kg.classList.remove("switch"),
              $g.classList.remove("switch"),
              ew.update(),
              Jf.refresh(),
              setTimeout(function () {
                ov.forEach((e) => {
                  e.style.pointerEvents = "all";
                }),
                  (Yg.style.pointerEvents = "all"),
                  (d_.button.style.pointerEvents = "all"),
                  (zg.style.pointerEvents = "all"),
                  (yy = !1);
              }, 750);
          }, 1e3);
      }
      function Z_() {
        0 == yy &&
          1 == Ty &&
          ((My = !0),
          (Ky = !1),
          K_(),
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) ||
            window.matchMedia("(max-width: 1024px)").matches ||
            ew.stop());
      }
      function Q_() {
        0 == yy && ((My = !1), ew.start(), (Ky = !0), $_());
      }
      function K_() {
        0 == Ky &&
          0 == Ey &&
          "work" != gy &&
          "workReveal" != gy &&
          (Qy < 100 && (ty.innerHTML = ++Qy),
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) || window.matchMedia("(max-width: 1024px)").matches
            ? Qy >= 20 &&
              (o_.fade(0, 0, 1e3),
              1 == a_ && (s_.fade(0.1, 0, 2e3), s_.play()),
              (Kv.style.padding = 20 + Qy / 2 + "px"),
              (ty.style.transform =
                "translate(-50%, -50%) scale(" + (0.75 + Qy / 75) + ")"),
              Sd.to("#app", 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(".musicWrapper", 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(".hamburgerWrapper", 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(Qv, 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(Kv, 0.5, {
                opacity: 1,
                borderRadius: "100%",
                ease: "power3",
              }),
              Sd.to($v, 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(".octagon", 0.5, {
                background: "rgba(177, 177, 177, 1)",
                ease: "power3",
              }),
              Sd.to(".cursorLoader", 0.5, { opacity: 1, ease: "power3" }),
              Sd.to(ey, 0.5, {
                opacity: 0,
                padding: "55px",
                borderRadius: "100%",
                ease: "power3",
              }),
              (Yg.style.pointerEvents = "none"),
              (d_.button.style.pointerEvents = "none"),
              "home" == gy &&
                (Sd.to(".homeLink", 0.5, { opacity: 0, ease: "power3" }),
                ov.forEach((e) => {
                  e.style.pointerEvents = "none";
                })),
              "about" == gy &&
                (Wv.forEach((e) => {
                  e.style.pointerEvents = "none";
                }),
                Sd.to(T_, 0.5, { opacity: 1, ease: "power3" })))
            : Qy >= 5 &&
              ((Kv.style.padding = 20 + Qy / 2 + "px"),
              (ty.style.transform =
                "translate(-50%, -50%) scale(" + (0.75 + Qy / 75) + ")"),
              o_.fade(0, 0, 1e3),
              1 == a_ && (s_.fade(0.1, 0, 2e3), s_.play()),
              Sd.to("#app", 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(".musicWrapper", 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(".hamburgerWrapper", 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(Qv, 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(Kv, 0.5, {
                opacity: 1,
                borderRadius: "100%",
                ease: "power3",
              }),
              Sd.to($v, 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(".octagon", 0.5, {
                background: "rgba(177, 177, 177, 1)",
                ease: "power3",
              }),
              Sd.to(".cursorLoader", 0.5, { opacity: 1, ease: "power3" }),
              Sd.to(ey, 0.5, {
                opacity: 0,
                padding: "55px",
                borderRadius: "100%",
                ease: "power3",
              }),
              (Yg.style.pointerEvents = "none"),
              (d_.button.style.pointerEvents = "none"),
              "home" == gy &&
                (Sd.to(".homeLink", 0.5, { opacity: 0, ease: "power3" }),
                ov.forEach((e) => {
                  e.style.pointerEvents = "none";
                })),
              "about" == gy &&
                (Wv.forEach((e) => {
                  e.style.pointerEvents = "none";
                }),
                Sd.to(T_, 0.5, { opacity: 1, ease: "power3" }))),
          100 == Qy &&
            ((Qy = 100),
            Sd.to(Qv, 0.5, { opacity: 1, ease: "power3.in" }),
            Sd.to(Kv, 0.5, {
              opacity: 1,
              padding: "0px",
              borderRadius: "0%",
              ease: "power3.in",
            }),
            Sd.to(".octagon", 0.5, {
              background: "rgba(177, 177, 177, 0)",
              ease: "power3.in",
            }),
            Sd.to(".cursorLoader", 0.5, { opacity: 0, ease: "power3.in" }),
            Sd.to(ey, 0.5, {
              opacity: 0.5,
              padding: "0px",
              borderRadius: "0%",
              ease: "power3.in",
            }),
            s_.stop(),
            (Ey = !0),
            Y_(),
            setTimeout(function () {
              (Qy = 0), (Ey = !1);
            }, 100)),
          setTimeout(K_, 50));
      }
      function $_() {
        1 == Ky &&
          Qy > 0 &&
          ((ty.innerHTML = --Qy),
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) || window.matchMedia("(max-width: 1024px)").matches
            ? (Qy >= 20 &&
                Qy < 100 &&
                ((Kv.style.padding = 20 + Qy / 2 + "px"),
                (ty.style.transform =
                  "translate(-50%, -50%) scale(" + (0.75 + Qy / 75) + ")")),
              Qy >= 20 &&
                Qy < 100 &&
                1 == a_ &&
                "work" != gy &&
                "workReveal" != gy &&
                (o_.fade(0, 0.5, 1e3), s_.stop()),
              Qy > 0 &&
                Qy <= 20 &&
                ("home" == gy || "about" == gy) &&
                (Sd.to("#app", 0.5, { opacity: 1, ease: "power3.in" }),
                Sd.to(".musicWrapper", 0.5, { opacity: 1, ease: "power3.in" }),
                Sd.to(".hamburgerWrapper", 0.5, {
                  opacity: 1,
                  ease: "power3.in",
                }),
                Sd.to(Qv, 0.5, { opacity: 1, ease: "power3.in" }),
                Sd.to(Kv, 0.5, {
                  opacity: 1,
                  padding: "0px",
                  borderRadius: "0%",
                  ease: "power3.in",
                }),
                Sd.to($v, 0.5, { opacity: 1, ease: "power3.in" }),
                Sd.to(".octagon", 0.5, {
                  background: "rgba(177, 177, 177, 0)",
                  ease: "power3.in",
                }),
                Sd.to(".cursorLoader", 0.5, { opacity: 0, ease: "power3.in" }),
                Sd.to(ey, 0.5, {
                  opacity: 0.5,
                  padding: "0px",
                  borderRadius: "0%",
                  ease: "power3.in",
                }),
                (Yg.style.pointerEvents = "all"),
                (d_.button.style.pointerEvents = "all"),
                "home" == gy &&
                  (Sd.to(".homeLink", 0.5, { opacity: 0.6, ease: "power3.in" }),
                  ov.forEach((e) => {
                    e.style.pointerEvents = "all";
                  })),
                "about" == gy &&
                  (Wv.forEach((e) => {
                    e.style.pointerEvents = "all";
                  }),
                  Sd.to(T_, 0.5, { opacity: 0, ease: "power3.in" }))))
            : (Qy >= 5 &&
                Qy < 100 &&
                ((Kv.style.padding = 20 + Qy / 2 + "px"),
                (ty.style.transform =
                  "translate(-50%, -50%) scale(" + (0.75 + Qy / 75) + ")")),
              Qy > 1 &&
                Qy < 100 &&
                1 == a_ &&
                "work" != gy &&
                "workReveal" != gy &&
                (o_.fade(0, 0.5, 1e3), s_.stop()),
              Qy > 0 &&
                Qy <= 5 &&
                ("home" == gy || "about" == gy) &&
                (Sd.to("#app", 0.5, { opacity: 1, ease: "power3.in" }),
                Sd.to(".musicWrapper", 0.5, { opacity: 1, ease: "power3.in" }),
                Sd.to(".hamburgerWrapper", 0.5, {
                  opacity: 1,
                  ease: "power3.in",
                }),
                Sd.to(Qv, 0.5, { opacity: 1, ease: "power3.in" }),
                Sd.to(Kv, 0.5, {
                  opacity: 1,
                  padding: "0px",
                  borderRadius: "0%",
                  ease: "power3.in",
                }),
                Sd.to($v, 0.5, { opacity: 1, ease: "power3.in" }),
                Sd.to(".octagon", 0.5, {
                  background: "rgba(177, 177, 177, 0)",
                  ease: "power3.in",
                }),
                Sd.to(".cursorLoader", 0.5, { opacity: 0, ease: "power3.in" }),
                Sd.to(ey, 0.5, {
                  opacity: 0.5,
                  padding: "0px",
                  borderRadius: "0%",
                  ease: "power3.in",
                }),
                (Yg.style.pointerEvents = "all"),
                (d_.button.style.pointerEvents = "all"),
                "home" == gy &&
                  (Sd.to(".homeLink", 0.5, { opacity: 0.6, ease: "power3.in" }),
                  ov.forEach((e) => {
                    e.style.pointerEvents = "all";
                  })),
                "about" == gy &&
                  (Wv.forEach((e) => {
                    e.style.pointerEvents = "all";
                  }),
                  Sd.to(T_, 0.5, { opacity: 0, ease: "power3.in" })))),
          setTimeout($_, 15));
      }
      (G_.renderToScreen = !0),
        z_.addPass(G_),
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        ) ||
          window.matchMedia("(max-width: 1024px)").matches ||
          (c_(Yg), l_(ov)),
        Yg.addEventListener("click", () => {
          yy ? q_() : V_();
        }),
        pv.addEventListener("click", () => {
          1 == yy &&
            ((gv.style.display = "flex"),
            (vv.style.display = "none"),
            (yv.style.display = "none"),
            (xy = !1),
            setTimeout(function () {
              xy = !0;
            }, 1500),
            (gy = "home"),
            q_(),
            ew.update(),
            Jf.refresh());
        }),
        dv.addEventListener("click", () => {
          1 == yy &&
            ((gv.style.display = "none"),
            (vv.style.display = "flex"),
            (yv.style.display = "none"),
            Sd.to(".container--about .title", 0, { transform: "scale(1.17)" }),
            Sd.to(".container--about .aboutWrapper", 0, {
              transform: "scale(1.17)",
            }),
            (gy = "about"),
            q_(),
            ew.update(),
            Jf.refresh());
        }),
        sv.addEventListener("click", () => {
          1 == xy &&
            (Sd.to(T_, 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(".container--home", 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(".container--home", 0, {
              transform: "scale(1.17)",
              delay: 0.75,
            }),
            Sd.to(".homeLink", 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(".container--about .title", 0, { transform: "scale(1.17)" }),
            Sd.to(".container--about .aboutWrapper", 0, {
              transform: "scale(1.17)",
            }),
            (Yg.style.pointerEvents = "none"),
            ov.forEach((e) => {
              e.style.pointerEvents = "none";
            }),
            (gy = "about"),
            q_(),
            ew.update(),
            Jf.refresh(),
            (Ty = !1),
            setTimeout(function () {
              Ty = !0;
            }, 1700));
        }),
        fv.addEventListener("click", () => {
          1 == yy &&
            ((gv.style.display = "none"),
            (vv.style.display = "none"),
            (yv.style.display = "flex"),
            Sd.to(".projectName", 0, { transform: "scale(1.17)" }),
            Sd.to(".projectCat", 0, { transform: "scale(1.17)" }),
            (gy = "work"),
            q_(),
            setTimeout(() => {
              _y = !0;
            }, 1750),
            ew.update(),
            Jf.refresh());
        }),
        cv.addEventListener("click", () => {
          1 == xy &&
            (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
              navigator.userAgent
            ) ||
              window.matchMedia("(max-width: 1024px)").matches ||
              Sd.to(E_, 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(T_, 0.75, { opacity: 0, ease: "power3" }),
            (Yg.style.pointerEvents = "none"),
            ov.forEach((e) => {
              e.style.pointerEvents = "none";
            }),
            Sd.to(".container--home", 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(".container--home", 0, {
              transform: "scale(1.17)",
              delay: 0.75,
            }),
            Sd.to(".homeLink", 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(".projectName", 0, { transform: "scale(1.17)" }),
            Sd.to(".projectCat", 0, { transform: "scale(1.17)" }),
            (gy = "work"),
            q_(),
            (Ty = !1),
            setTimeout(() => {
              (_y = !0), (Ty = !0);
            }, 1750),
            ew.update(),
            Jf.refresh());
        }),
        lv.addEventListener("click", () => {
          Sd.to(T_, 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(E_, 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(".container--home", 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(".container--home", 0, {
              transform: "scale(1.17)",
              delay: 0.75,
            }),
            Sd.to(".homeLink", 0.75, { opacity: 0, ease: "power3" }),
            Sd.to(".musicWrapper", 0.75, { opacity: 0, ease: "power3" }),
            (gy = "showreel"),
            V_();
        }),
        mv.addEventListener("click", () => {
          1 == yy &&
            ((Xg.style.pointerEvents = "none"),
            (gy = "showreel"),
            W_(),
            Sd.to(".musicWrapper", 0.75, { opacity: 0, ease: "power3" }),
            setTimeout(function () {
              V_();
            }, 500));
        }),
        xv.addEventListener("ended", () => {
          J_();
        }),
        (xv.onclick = function () {
          xv.paused ? xv.play() : xv.pause();
        }),
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        ) ||
          window.matchMedia("(max-width: 1024px)").matches ||
          (uv.forEach((e) => {
            e.addEventListener("mouseenter", () => {
              Sd.to(Qv, 0.5, { opacity: 0, ease: "power3" }),
                Sd.to(Kv, 0.5, {
                  opacity: 1,
                  padding: "45px",
                  borderRadius: "100%",
                  ease: "power3",
                }),
                Sd.to($v, 0.5, { opacity: 0, ease: "power3" }),
                Sd.to(".octagon", 0.5, {
                  background: "rgba(177, 177, 177, 1)",
                  ease: "power3",
                }),
                Sd.to(ey, 0.5, {
                  opacity: 0,
                  padding: "55px",
                  borderRadius: "100%",
                  ease: "power3",
                });
            }),
              e.addEventListener("mouseleave", () => {
                Sd.to(Qv, 0.5, { opacity: 1, ease: "power3.in" }),
                  Sd.to(Kv, 0.5, {
                    opacity: 1,
                    padding: "0px",
                    borderRadius: "0%",
                    ease: "power3.in",
                  }),
                  Sd.to($v, 0.5, { opacity: 1, ease: "power3.in" }),
                  Sd.to(".octagon", 0.5, {
                    background: "rgba(177, 177, 177, 0)",
                    ease: "power3.in",
                  }),
                  Sd.to(ey, 0.5, {
                    opacity: 0.5,
                    padding: "0px",
                    borderRadius: "0%",
                    ease: "power3.in",
                  });
              }),
              e.addEventListener("click", () => {
                1 == yy &&
                  (Sd.to(Qv, 0.5, { opacity: 1, ease: "power3.in" }),
                  Sd.to(Kv, 0.5, {
                    opacity: 1,
                    padding: "0px",
                    borderRadius: "0%",
                    ease: "power3.in",
                  }),
                  Sd.to(".octagon", 0.5, {
                    background: "rgba(177, 177, 177, 0)",
                    ease: "power3.in",
                  }),
                  Sd.to(ey, 0.5, {
                    opacity: 0.5,
                    padding: "0px",
                    borderRadius: "0%",
                    ease: "power3.in",
                  }));
              });
          }),
          pv.addEventListener("mouseenter", () => {
            Sd.to(".link .mask--home .char", 0.5, {
              opacity: 0,
              clipPath: "inset(100% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            });
          }),
          pv.addEventListener("mouseleave", () => {
            Sd.to(".link .mask--home .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            });
          }),
          dv.addEventListener("mouseenter", () => {
            Sd.to(".link .mask--about .char", 0.5, {
              opacity: 0,
              clipPath: "inset(0% 0% 100% 0%)",
              stagger: { each: Py, from: "start" },
              ease: "power3",
            });
          }),
          dv.addEventListener("mouseleave", () => {
            Sd.to(".link .mask--about .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "start" },
              ease: "power3",
            });
          }),
          fv.addEventListener("mouseenter", () => {
            Sd.to(".link .mask--work .char", 0.5, {
              opacity: 0,
              clipPath: "inset(100% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            });
          }),
          fv.addEventListener("mouseleave", () => {
            Sd.to(".link .mask--work .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            });
          }),
          mv.addEventListener("mouseenter", () => {
            Sd.to(".link .mask--showreel .char", 0.5, {
              opacity: 0,
              clipPath: "inset(0% 0% 100% 0%)",
              stagger: { each: Py, from: "start" },
              ease: "power3",
            });
          }),
          mv.addEventListener("mouseleave", () => {
            Sd.to(".link .mask--showreel .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "start" },
              ease: "power3",
            });
          }),
          l_(hv)),
        Mv.forEach((e) => {
          e.addEventListener("mouseover", () => {
            Sd.to(Qv, 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(Kv, 0.5, {
                opacity: 1,
                padding: "45px",
                borderRadius: "100%",
                ease: "power3",
              }),
              Sd.to($v, 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(".octagon", 0.5, {
                background: "rgba(177, 177, 177, 1)",
                ease: "power3",
              }),
              Sd.to(ey, 0.5, {
                opacity: 0,
                padding: "55px",
                borderRadius: "100%",
                ease: "power3",
              });
          }),
            e.addEventListener("mouseleave", () => {
              Sd.to(Qv, 0.5, { opacity: 1, ease: "power3.in" }),
                Sd.to(Kv, 0.5, {
                  opacity: 1,
                  padding: "0px",
                  borderRadius: "0%",
                  ease: "power3.in",
                }),
                Sd.to($v, 0.5, { opacity: 1, ease: "power3.in" }),
                Sd.to(".octagon", 0.5, {
                  background: "rgba(177, 177, 177, 0)",
                  ease: "power3.in",
                }),
                Sd.to(ey, 0.5, {
                  opacity: 0.5,
                  padding: "0px",
                  borderRadius: "0%",
                  ease: "power3.in",
                });
            }),
            e.addEventListener("click", () => {
              1 == _y &&
                (Sd.to(Qv, 0.5, { opacity: 1, ease: "power3.in" }),
                Sd.to(Kv, 0.5, {
                  opacity: 1,
                  padding: "0px",
                  borderRadius: "0%",
                  ease: "power3.in",
                }),
                Sd.to(".octagon", 0.5, {
                  background: "rgba(177, 177, 177, 0)",
                  ease: "power3.in",
                }),
                Sd.to(ey, 0.5, {
                  opacity: 0.5,
                  padding: "0px",
                  borderRadius: "0%",
                  ease: "power3.in",
                }));
            });
        }),
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        ) ||
          window.matchMedia("(max-width: 1024px)").matches ||
          (Vv.addEventListener("mousemove", () => {
            Sd.to(Qv, 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(Kv, 0.5, {
                opacity: 1,
                padding: "45px",
                borderRadius: "100%",
                ease: "power3",
              }),
              Sd.to($v, 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(".octagon", 0.5, {
                background: "rgba(177, 177, 177, 1)",
                ease: "power3",
              }),
              Sd.to(ey, 0.5, {
                opacity: 0,
                padding: "55px",
                borderRadius: "100%",
                ease: "power3",
              });
          }),
          Vv.addEventListener("mouseleave", () => {
            Sd.to(Qv, 0.5, { opacity: 1, ease: "power3.in" }),
              Sd.to(Kv, 0.5, {
                opacity: 1,
                padding: "0px",
                borderRadius: "0%",
                ease: "power3.in",
              }),
              Sd.to($v, 0.5, { opacity: 1, ease: "power3.in" }),
              Sd.to(".octagon", 0.5, {
                background: "rgba(177, 177, 177, 0)",
                ease: "power3.in",
              }),
              Sd.to(ey, 0.5, {
                opacity: 0.5,
                padding: "0px",
                borderRadius: "0%",
                ease: "power3.in",
              });
          }),
          Xv.addEventListener("mouseenter", () => {
            Sd.to(Qv, 0.5, { opacity: 0, ease: "power3" }),
              Sd.to(Kv, 0.5, {
                opacity: 1,
                padding: "45px",
                borderRadius: "100%",
                ease: "power3",
              }),
              Sd.to(".octagon", 0.5, {
                background: "rgba(177, 177, 177, 1)",
                ease: "power3",
              }),
              Sd.to(ey, 0.5, {
                opacity: 0,
                padding: "55px",
                borderRadius: "100%",
                ease: "power3",
              });
          }),
          Xv.addEventListener("mouseleave", () => {
            Sd.to(Qv, 0.5, { opacity: 1, ease: "power3.in" }),
              Sd.to(Kv, 0.5, {
                opacity: 1,
                padding: "0px",
                borderRadius: "0%",
                ease: "power3.in",
              }),
              Sd.to(".octagon", 0.5, {
                background: "rgba(177, 177, 177, 0)",
                ease: "power3.in",
              }),
              Sd.to(ey, 0.5, {
                opacity: 0.5,
                padding: "0px",
                borderRadius: "0%",
                ease: "power3.in",
              });
          }),
          Sv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 0,
              clipPath: "inset(100% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != yg &&
                ((vy = yg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = yg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = yg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Tv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != _g &&
                ((vy = _g),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = _g),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = _g),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Ev.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != Ng &&
                ((vy = Ng),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = Ng),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = Ng),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Av.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != wg &&
                ((vy = wg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = wg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = wg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Lv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != kg &&
                ((vy = kg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = kg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = kg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Pv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != Og &&
                ((vy = Og),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = Og),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = Og),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Rv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != jg &&
                ((vy = jg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = jg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = jg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          kv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != xg &&
                ((vy = xg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = xg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = xg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Cv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != Sg &&
                ((vy = Sg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = Sg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = Sg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Ov.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != Mg &&
                ((vy = Mg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = Mg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = Mg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Nv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != Dg &&
                ((vy = Dg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = Dg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = Dg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Iv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != Tg &&
                ((vy = Tg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = Tg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = Tg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Dv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != Ig &&
                ((vy = Ig),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = Ig),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = Ig),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          jv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != Pg &&
                ((vy = Pg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = Pg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = Pg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Fv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != bg &&
                ((vy = bg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = bg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = bg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Hv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != Eg &&
                ((vy = Eg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = Eg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = Eg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Bv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != Rg &&
                ((vy = Rg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = Rg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = Rg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          zv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != Lg &&
                ((vy = Lg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = Lg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = Lg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Uv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != Cg &&
                ((vy = Cg),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = Cg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = Cg),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          }),
          Gv.addEventListener("mouseenter", () => {
            Sd.to(".projectName .mask--1 .char", 0.5, {
              opacity: 1,
              clipPath: "inset(0% 0% 0% 0%)",
              stagger: { each: Py, from: "end" },
              ease: "power3",
            }),
              Sd.to(".projectName .mask--2 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--3 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--4 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--5 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--6 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--7 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--8 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--9 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--10 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--11 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--12 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--13 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--14 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--15 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--16 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--17 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--18 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--19 .char", 0.5, {
                opacity: 1,
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: { each: Py, from: "end" },
                ease: "power3",
              }),
              Sd.to(".projectName .mask--20 .char", 0.5, {
                opacity: 0,
                clipPath: "inset(100% 0% 0% 0%)",
                stagger: { each: Py, from: "start" },
                ease: "power3",
              }),
              vy != Ag &&
                ((vy = Ag),
                P_.uniforms.u_dispFactor.value >= 0 &&
                P_.uniforms.u_dispFactor.value <= 0.5
                  ? ((P_.uniforms.u_texture2.value = Ag),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 1,
                      ease: "power3",
                    }))
                  : ((P_.uniforms.u_texture1.value = Ag),
                    Sd.to(P_.uniforms.u_dispFactor, 1, {
                      value: 0,
                      ease: "power3",
                    })));
          })),
        Sv.addEventListener("click", () => {
          (dy = "id2021"), X_();
        }),
        Tv.addEventListener("click", () => {
          (dy = "astralys"), X_();
        }),
        Ev.addEventListener("click", () => {
          (dy = "terreDeBois"), X_();
        }),
        Av.addEventListener("click", () => {
          (dy = "auriane"), X_();
        }),
        Lv.addEventListener("click", () => {
          (dy = "cmsFolio"), X_();
        }),
        Pv.addEventListener("click", () => {
          (dy = "newspaper"), X_();
        }),
        Rv.addEventListener("click", () => {
          (dy = "jamOn"), X_();
        }),
        kv.addEventListener("click", () => {
          (dy = "folio2020"), X_();
        }),
        Cv.addEventListener("click", () => {
          (dy = "internship"), X_();
        }),
        Ov.addEventListener("click", () => {
          (dy = "gamovore"), X_();
        }),
        Nv.addEventListener("click", () => {
          (dy = "dresson"), X_();
        }),
        Iv.addEventListener("click", () => {
          (dy = "mmorpion"), X_();
        }),
        Dv.addEventListener("click", () => {
          (dy = "mushrooms"), X_();
        }),
        jv.addEventListener("click", () => {
          (dy = "yasuo"), X_();
        }),
        Fv.addEventListener("click", () => {
          (dy = "folio2019"), X_();
        }),
        Hv.addEventListener("click", () => {
          (dy = "laDette"), X_();
        }),
        Bv.addEventListener("click", () => {
          (dy = "animayo"), X_();
        }),
        zv.addEventListener("click", () => {
          (dy = "outroId"), X_();
        }),
        Uv.addEventListener("click", () => {
          (dy = "letterMask"), X_();
        }),
        Gv.addEventListener("click", () => {
          (dy = "motionIntro"), X_();
        }),
        zg.addEventListener("mousedown", () => {
          Z_();
        }),
        document.addEventListener("mouseup", () => {
          Q_();
        }),
        zg.addEventListener("touchstart", () => {
          Z_();
        }),
        document.addEventListener("touchend", () => {
          Q_();
        });
      const ew = new cg({
        el: Hg,
        smooth: !0,
        lerp: 0.065,
        multiplier: 0.475,
        getDirection: !0,
        reloadOnContextChange: !0,
        smartphone: { smooth: !0 },
        tablet: { smooth: !0 },
      });
      if (
        (ew.stop(),
        ew.on("scroll", Jf.update),
        Jf.scrollerProxy(Hg, {
          scrollTop(e) {
            return arguments.length
              ? ew.scrollTo(e, 0, 0)
              : ew.scroll.instance.scroll.y;
          },
          getBoundingClientRect: () => ({
            top: 0,
            left: 0,
            width: window.innerWidth,
            height: window.innerHeight,
          }),
        }),
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        ) || window.matchMedia("(max-width: 1024px)").matches)
      );
      else {
        let e = { skew: 0 },
          t = Sd.quickSetter(".skewElem", "skewY", "deg"),
          n = Sd.utils.clamp(-20, 20);
        Jf.create({
          onUpdate: (i) => {
            let r = n(i.getVelocity() / -315);
            Math.abs(r) > Math.abs(e.skew) &&
              ((e.skew = r),
              Sd.to(e, {
                skew: 0,
                duration: 0.25,
                ease: "power3",
                overwrite: !0,
                onUpdate: () => t(e.skew),
              }));
          },
        });
      }
      Sd.to(
        { a: 0 },
        {
          a: 1,
          scrollTrigger: {
            scroller: Hg,
            ease: "power3",
            onUpdate: (e) => {
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent
              ) ||
                window.matchMedia("(max-width: 1024px)").matches ||
                ("showreel" != gy &&
                  ((k_.rotation.z = -7 * e.progress),
                  (C_.rotation.z = -7 * e.progress + 0.25 * Math.PI),
                  (O_.rotation.z = -7 * e.progress),
                  (N_.rotation.z = -7 * e.progress + 0.25 * Math.PI),
                  (I_.rotation.z = -7 * e.progress)));
            },
          },
        }
      ),
        new IntersectionObserver(
          function (e) {
            e.forEach((e) => {
              1 == e.isIntersecting &&
                0 == wy &&
                Sd.to(".heySection span", 1.25, {
                  clipPath: "inset(0% 0% 0% 0%)",
                  opacity: 1,
                  transform: "translateY(0)",
                  stagger: 0.2,
                  ease: "power3",
                });
            });
          },
          { threshold: 0.5 }
        ).observe(ny);
      const tw = new IntersectionObserver(
        function (e) {
          e.forEach((e) => {
            1 == e.isIntersecting &&
              0 == wy &&
              Sd.to(".container--about .title--about span", 1.25, {
                opacity: 1,
                transform: "translateY(0) rotateX(0) rotateY(0) rotateZ(0)",
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: 0.1,
                ease: "power3",
              });
          });
        },
        { threshold: 0.5 }
      );
      "ABOUT".split("").forEach((e) => {
        const t = document.createElement("span");
        (t.innerHTML = e), iy.append(t);
      }),
        tw.observe(iy),
        (my =
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) || window.matchMedia("(max-width: 1024px)").matches
            ? 0.85
            : 0.35),
        new IntersectionObserver(
          function (e) {
            e.forEach((e) => {
              1 == e.isIntersecting &&
                0 == wy &&
                Sd.to(".aboutWrapper--2 p", 1.25, {
                  clipPath: "inset(0% 0% 0% 0%)",
                  opacity: 1,
                  transform: "translateY(0)",
                  stagger: 0.25,
                  ease: "power3",
                });
            });
          },
          { threshold: my }
        ).observe(ry);
      const nw = new IntersectionObserver(
        function (e) {
          e.forEach((e) => {
            1 == e.isIntersecting &&
              0 == wy &&
              Sd.to(".container--about .title--course span", 1.25, {
                opacity: 1,
                transform: "translateY(0) rotateX(0) rotateY(0) rotateZ(0)",
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: 0.1,
                ease: "power3",
              });
          });
        },
        { threshold: 0.5 }
      );
      "STUDIES".split("").forEach((e) => {
        const t = document.createElement("span");
        (t.innerHTML = e), ay.append(t);
      }),
        nw.observe(ay),
        new IntersectionObserver(
          function (e) {
            e.forEach((e) => {
              1 == e.isIntersecting &&
                0 == wy &&
                Sd.to(".courseSection--1 p", 1.25, {
                  clipPath: "inset(0% 0% 0% 0%)",
                  opacity: 1,
                  transform: "translateY(0)",
                  stagger: 0.25,
                  ease: "power3",
                });
            });
          },
          { threshold: 0.35 }
        ).observe(oy),
        new IntersectionObserver(
          function (e) {
            e.forEach((e) => {
              1 == e.isIntersecting &&
                0 == wy &&
                Sd.to(".courseSection--2 p", 1.25, {
                  clipPath: "inset(0% 0% 0% 0%)",
                  opacity: 1,
                  transform: "translateY(0)",
                  stagger: 0.25,
                  ease: "power3",
                });
            });
          },
          { threshold: 0.35 }
        ).observe(sy),
        new IntersectionObserver(
          function (e) {
            e.forEach((e) => {
              1 == e.isIntersecting &&
                0 == wy &&
                Sd.to(".courseSection--3 p", 1.25, {
                  clipPath: "inset(0% 0% 0% 0%)",
                  opacity: 1,
                  transform: "translateY(0)",
                  stagger: 0.25,
                  ease: "power3",
                });
            });
          },
          { threshold: 0.35 }
        ).observe(cy);
      const iw = new IntersectionObserver(
        function (e) {
          e.forEach((e) => {
            1 == e.isIntersecting &&
              0 == wy &&
              (Sd.to(".container--about .title--skills span", 1.25, {
                opacity: 1,
                transform: "translateY(0) rotateX(0) rotateY(0) rotateZ(0)",
                stagger: 0.1,
                ease: "power3",
                delay: 0,
              }),
              Sd.to(".container--about .title--skills span", 1.25, {
                clipPath: "inset(0% 0% 0% 0%)",
                stagger: 0.1,
                ease: "power3",
              }));
          });
        },
        { threshold: 0.5 }
      );
      function rw() {
        ("about" != gy && "work" != gy) ||
          0 != wy ||
          0 != My ||
          Sd.timeline({ default: { ease: "power3" } })
            .to(A_, 1, { opacity: 0.1 })
            .to(A_, 1, { opacity: 0.015, delay: -0.8 }),
          "about" == gy &&
            0 == wy &&
            0 == My &&
            (Sd.to(".container--about .scrollIndication", 0.5, {
              opacity: 0,
              delay: 0.25,
            }),
            Sd.timeline({ default: { ease: "power3" } })
              .to(E_, 1, { opacity: 1 })
              .to(E_, 1, { opacity: 0.15, delay: -0.8 }));
      }
      function aw() {
        "about" == gy && 0 == wy && 0 == My && (by = !0), rw();
      }
      function ow() {
        "about" == gy && 0 == wy && 0 == My && (by = !1), rw();
      }
      "SKILLS".split("").forEach((e) => {
        const t = document.createElement("span");
        (t.innerHTML = e), ly.append(t);
      }),
        iw.observe(ly),
        new IntersectionObserver(
          function (e) {
            e.forEach((e) => {
              1 == e.isIntersecting &&
                0 == wy &&
                (Sd.to(".skillsSection--1 span", 1.25, {
                  clipPath: "inset(0% 0% 0% 0%)",
                  opacity: 1,
                  transform: "translateY(0)",
                  ease: "power3",
                }),
                setTimeout(function () {
                  Sd.to(".skillsSection--1 li", 1.25, {
                    clipPath: "inset(0% 0% 0% 0%)",
                    opacity: 1,
                    transform: "translateY(0)",
                    stagger: 0.1,
                    ease: "power3",
                  });
                }, 300));
            });
          },
          { threshold: 0.35 }
        ).observe(hy),
        new IntersectionObserver(
          function (e) {
            e.forEach((e) => {
              1 == e.isIntersecting &&
                0 == wy &&
                (Sd.to(".skillsSection--2 span", 1.25, {
                  clipPath: "inset(0% 0% 0% 0%)",
                  opacity: 1,
                  transform: "translateY(0)",
                  ease: "power3",
                }),
                setTimeout(function () {
                  Sd.to(".skillsSection--2 li", 1.25, {
                    clipPath: "inset(0% 0% 0% 0%)",
                    opacity: 1,
                    transform: "translateY(0)",
                    stagger: 0.1,
                    ease: "power3",
                  });
                }, 300));
            });
          },
          { threshold: 0.35 }
        ).observe(uy),
        new IntersectionObserver(
          function (e) {
            e.forEach((e) => {
              1 == e.isIntersecting &&
                0 == wy &&
                (Sd.to(".skillsSection--3 span", 1.25, {
                  clipPath: "inset(0% 0% 0% 0%)",
                  opacity: 1,
                  transform: "translateY(0)",
                  ease: "power3",
                }),
                setTimeout(function () {
                  Sd.to(".skillsSection--3 li", 1.25, {
                    clipPath: "inset(0% 0% 0% 0%)",
                    opacity: 1,
                    transform: "translateY(0)",
                    stagger: 0.1,
                    ease: "power3",
                  });
                }, 300));
            });
          },
          { threshold: 0.35 }
        ).observe(py),
        (document.onkeydown = function (e) {
          "38" == (e = e || window.event).keyCode
            ? aw()
            : "40" == e.keyCode && ow();
        }),
        document.addEventListener("wheel", function (e) {
          !(function (e) {
            return e.wheelDeltaY ? e.wheelDeltaY > 0 : e.deltaY < 0;
          })(e)
            ? ow()
            : aw();
        }),
        Jf.addEventListener("refresh", () => ew.update()),
        Jf.refresh(),
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        ) ||
          window.matchMedia("(max-width: 1024px)").matches ||
          (Sd.set(Qv, { xPercent: -50, yPercent: -50 }),
          Sd.set(Kv, { xPercent: -50, yPercent: -50 }),
          Sd.set($v, { xPercent: -50, yPercent: -50 }),
          Sd.set(ey, { xPercent: -50, yPercent: -50 }),
          Sd.ticker.add(() => {
            (Ry.x += 1 * (ky.x - Ry.x)),
              (Ry.y += 1 * (ky.y - Ry.y)),
              (Ny.x += 1 * (Iy.x - Ny.x)),
              (Ny.y += 1 * (Iy.y - Ny.y)),
              (Fy.x += 1 * (Hy.x - Fy.x)),
              (Fy.y += 1 * (Hy.y - Fy.y)),
              (Uy.x += 1 * (Gy.x - Uy.x)),
              (Uy.y += 1 * (Gy.y - Uy.y)),
              Cy(Ry.x),
              Oy(Ry.y),
              Dy(Ny.x),
              jy(Ny.y),
              By(Fy.x),
              zy(Fy.y),
              Wy(Uy.x),
              Vy(Uy.y);
          }),
          document.addEventListener("mousemove", function (e) {
            Sd.to(".cursor--indication span", 0.5, {
              opacity: 0,
              ease: "power3",
            }),
              clearTimeout(Zy),
              (Zy = setTimeout(h_, 500)),
              (qy = e.clientX - e_),
              (Xy = e.clientY - t_),
              Sd.to(r_, 1.25, {
                x: (e.clientX / window.innerWidth) * 2 - 1,
                y: (-e.clientY / window.innerHeight) * 1 + 0.5,
                ease: "power3",
              }),
              Sd.to(ky, {
                duration: 0.2,
                x: e.x,
                y: e.y,
                ease: "power4.out",
                overwrite: !0,
              }),
              Sd.to(Iy, {
                duration: 0.4,
                x: e.x,
                y: e.y,
                ease: "power4.out",
                overwrite: !0,
              }),
              Sd.to(Hy, {
                duration: 0.4,
                x: e.x,
                y: e.y,
                ease: "power4.out",
                overwrite: !0,
              }),
              Sd.to(Gy, {
                duration: 0.5,
                x: e.x,
                y: e.y,
                ease: "power4.out",
                overwrite: !0,
              });
          }));
      let sw = function () {
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        ) ||
          window.matchMedia("(max-width: 1024px)").matches ||
          ((Yy = -25e-5 * qy),
          ($y = 25e-5 * qy),
          (Jy = 25e-5 * Xy),
          L_ &&
            ((L_.rotation.z += 0.025 * (Yy - L_.rotation.z * i_ * 0.5)),
            (L_.rotation.x +=
              0.025 * (Jy - (L_.rotation.x - 0.5 * Math.PI) * i_ * 0.5))),
          (k_.rotation.y += 0.02 * ($y - k_.rotation.y * i_ * 0.5)),
          (k_.rotation.x += 0.02 * (Jy - k_.rotation.x * i_ * 0.5)),
          (C_.rotation.y += 0.02 * ($y - C_.rotation.y * i_ * 0.5)),
          (C_.rotation.x += 0.02 * (Jy - C_.rotation.x * i_ * 0.7)),
          (O_.rotation.y += 0.02 * ($y - O_.rotation.y * i_ * 0.5)),
          (O_.rotation.x += 0.02 * (Jy - O_.rotation.x * i_ * 0.5)),
          (N_.rotation.y += 0.02 * ($y - N_.rotation.y * i_ * 0.5)),
          (N_.rotation.x += 0.02 * (Jy - N_.rotation.x * i_ * 0.5)),
          (I_.rotation.y += 0.02 * ($y - I_.rotation.y * i_ * 0.5)),
          (I_.rotation.x += 0.02 * (Jy - I_.rotation.x * i_ * 0.5)),
          (D_.rotation.y += 0.04 * ($y - D_.rotation.y * i_ * 0.6)),
          (D_.rotation.x += 0.04 * (Jy - D_.rotation.x * i_ * 0.6)),
          (j_.rotation.y += 0.04 * ($y - j_.rotation.y * i_ * 0.6)),
          (j_.rotation.x += 0.04 * (Jy - j_.rotation.x * i_ * 0.6))),
          1 == My && 1 == Sy && 0 == yy && "workReveal" != gy
            ? (G_.uniforms.intensity.value <= 0.15 &&
                (G_.uniforms.intensity.value +=
                  0.02 * G_.uniforms.intensity.value),
              G_.uniforms.intensity.value >= 0.15 &&
                (G_.uniforms.intensity.value = 0.15),
              ("home" != gy && "about" != gy) ||
                (E_.opacity <= 0.6 && (E_.opacity += 0.02 * E_.opacity),
                n_ <= 0.04 && (n_ += 0.04 * n_),
                n_ >= 0.04 && (n_ = 0.04),
                M_.intensity >= 1.2 &&
                  ((M_.intensity += 0.05 * M_.intensity),
                  (S_.intensity += 0.05 * S_.intensity)),
                M_.intensity >= 25 &&
                  ((M_.intensity = 25), (S_.intensity = 25)),
                y_.position.z >= 1 &&
                  ((y_.position.z -= 0.002 * y_.position.z),
                  (Ly += 5),
                  (y_.position.x += Math.cos(Ly) / 2e3)),
                y_.position.z <= 1 && (y_.position.z = 1),
                F_.position.z >= 0 && (F_.position.z += 0.02 * F_.position.z),
                F_.position.z >= 2 && (F_.position.z = 2)),
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent
              ) ||
                window.matchMedia("(max-width: 1024px)").matches ||
                ("work" == gy &&
                  G_.uniforms.intensity.value > 0.1 &&
                  (Sd.to("#app", 0.5, { opacity: 0, ease: "power3" }),
                  Sd.to(".musicWrapper", 0.5, { opacity: 0, ease: "power3" }),
                  Sd.to(".hamburgerWrapper", 0.5, {
                    opacity: 0,
                    ease: "power3",
                  }),
                  Sd.to(Qv, 0.5, { opacity: 0, ease: "power3" }),
                  Sd.to(Kv, 0.5, {
                    opacity: 0,
                    padding: "45px",
                    borderRadius: "100%",
                    ease: "power3",
                  }),
                  Sd.to($v, 0.5, { opacity: 0, ease: "power3" }),
                  Sd.to(".octagon", 0.5, {
                    background: "rgba(177, 177, 177, 1)",
                    ease: "power3",
                  }),
                  Sd.to(ey, 0.5, {
                    opacity: 0,
                    padding: "55px",
                    borderRadius: "100%",
                    ease: "power3",
                  }),
                  (Yg.style.pointerEvents = "none"),
                  (d_.button.style.pointerEvents = "none"),
                  Mv.forEach((e) => {
                    e.style.pointerEvents = "none";
                  }))))
            : 0 == My &&
              1 == Sy &&
              0 == yy &&
              "workReveal" != gy &&
              (G_.uniforms.intensity.value >= 0.08 &&
                (G_.uniforms.intensity.value -=
                  0.02 * G_.uniforms.intensity.value),
              E_.opacity >= 0.15 && (E_.opacity -= 0.02 * E_.opacity),
              n_ > 0.003 && (n_ -= 0.015 * n_),
              ("home" != gy && "about" != gy && "showreel" != gy) ||
                (M_.intensity >= 1.2 &&
                  ((M_.intensity -= 0.05 * M_.intensity),
                  (S_.intensity -= 0.05 * S_.intensity)),
                M_.intensity <= 1.2 &&
                  ((M_.intensity = 1.2), (S_.intensity = 1.2)),
                y_.position.z < 1.5 && (y_.position.z += 0.003 * y_.position.z),
                y_.position.z >= 1.5 && (y_.position.z = 1.5),
                (y_.position.x = !0) && ((y_.position.x = 0), (Ly = 0)),
                F_.position.z > 0.05 && (F_.position.z -= 0.02 * F_.position.z),
                F_.position.z <= 0.05 && (F_.position.z = 0.05)),
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent
              ) ||
                window.matchMedia("(max-width: 1024px)").matches ||
                ("work" == gy &&
                  G_.uniforms.intensity.value > 0.1 &&
                  (Sd.to("#app", 0.5, { opacity: 1, ease: "power3.in" }),
                  Sd.to(".musicWrapper", 0.5, {
                    opacity: 1,
                    ease: "power3.in",
                  }),
                  Sd.to(".hamburgerWrapper", 0.5, {
                    opacity: 1,
                    ease: "power3.in",
                  }),
                  Sd.to(Qv, 0.5, { opacity: 1, ease: "power3.in" }),
                  Sd.to(Kv, 0.5, {
                    opacity: 1,
                    padding: "0px",
                    borderRadius: "0%",
                    ease: "power3.in",
                  }),
                  Sd.to($v, 0.5, { opacity: 1, ease: "power3.in" }),
                  Sd.to(".octagon", 0.5, {
                    background: "rgba(177, 177, 177, 0)",
                    ease: "power3.in",
                  }),
                  Sd.to(ey, 0.5, {
                    opacity: 0.5,
                    padding: "0px",
                    borderRadius: "0%",
                    ease: "power3.in",
                  }),
                  Mv.forEach((e) => {
                    e.style.pointerEvents = "all";
                  }),
                  (Yg.style.pointerEvents = "all"),
                  (d_.button.style.pointerEvents = "all")))),
          by ? (F_.rotation.z += n_) : (F_.rotation.z -= n_),
          B_.render(g_, __),
          H_.render(m_, y_),
          G_.uniforms.amount.value <= 0 && (fy = !1),
          G_.uniforms.amount.value >= 0.5 && (fy = !0),
          0 == fy && (G_.uniforms.amount.value += 0.001),
          1 == fy && (G_.uniforms.amount.value -= 0.001);
        let e = performance.now() / 1e3;
        d_ && d_.animate(e), window.requestAnimationFrame(sw), z_.render();
      };
      sw();
    })();
})();
//# sourceMappingURL=bundle.ed070500c303d23e3f9c.js.map
